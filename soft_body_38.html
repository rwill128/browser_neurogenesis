// --- Math Helper Functions ---
        function sigmoid(x) { return 1 / (1 + Math.exp(-x)); }
        function tanh(x) { return Math.tanh(x); }

        function initializeMatrix(rows, cols, scale = 0.5) { // Added scale for weights
            const matrix = [];
            for (let i = 0; i < rows; i++) {
                matrix[i] = [];
                for (let j = 0; j < cols; j++) {
                    matrix[i][j] = (Math.random() * 2 - 1) * scale;
                }
            }
            return matrix;
        }

        function initializeVector(size, scale = 0.1) { // Added scale for biases
            const vector = [];
            for (let i = 0; i < size; i++) {
                vector[i] = (Math.random() * 2 - 1) * scale;
            }
            return vector;
        }

        function multiplyMatrixVector(matrix, vector) {
            const result = [];
            const numRows = matrix.length;
            if (numRows === 0) return result;
            const numCols = matrix[0].length;

            if (numCols !== vector.length) {
                console.error("Matrix-vector dimension mismatch:", matrix, vector);
                // Return a zero vector of expected output size if possible, or handle error
                const expectedOutputSize = numRows;
                for(let i=0; i<expectedOutputSize; i++) result.push(0);
                return result;

            }

            for (let i = 0; i < numRows; i++) {
                let sum = 0;
                for (let j = 0; j < numCols; j++) {
                    sum += matrix[i][j] * vector[j];
                }
                result.push(sum);
            }
            return result;
        }

        function addVectors(vecA, vecB) { // Element-wise addition
            if (vecA.length !== vecB.length) {
                console.error("Vector addition dimension mismatch:", vecA, vecB);
                return vecA; // Or handle error appropriately
            }
            return vecA.map((val, i) => val + vecB[i]);
        }
        // --- End Math Helper Functions ---


        // --- MassPoint Class (Soft Body with Verlet Integration) ---
        class MassPoint {
            constructor(x, y, mass = 0.5, radius = 5, color = 'rgba(0,150,255,0.8)') {
                this.pos = new Vec2(x, y);
                this.prevPos = new Vec2(x, y);
                this.force = new Vec2();
                this.mass = mass;
                this.invMass = this.mass !== 0 ? 1 / this.mass : 0;
                this.radius = radius;
                this.color = color;
                this.isFixed = false;
                this.nodeType = NodeType.NEUTRAL;
                this.isEater = false;
                this.isPredator = false;
                this.emitsDye = false;
                this.dyeColor = [0,0,0]; // Default dye color for emitters if not neurally controlled
                // neuronData structure for an ACTIVE BRAIN:
                // {
                //   isBrain: true,
                //   hiddenLayerSize: number,
                //   weightsIH: matrix, // Input to Hidden
                //   biasesH: vector,   // Hidden biases
                //   weightsHO: matrix, // Hidden to Output
                //   biasesO: vector,   // Output biases
                //   inputVectorSize: number,
                //   outputVectorSize: number
                // }
                // For PASSIVE neurons (not the brain, or brain not yet fully formed):
                // { isBrain: false, hiddenLayerSize: number (potential for future use/mutation) }
                this.neuronData = null;
                // this.neuralEffectiveStrength = null; // DEPRECATED
            }
            applyForce(f) { this.force = this.force.add(f); }

            update(dt) {
                if (this.isFixed || this.invMass === 0 || this.nodeType === NodeType.FIXED_ROOT) {
                    this.force = new Vec2();
                    return;
                }

                const acceleration = this.force.mul(this.invMass);

                const tempX = this.pos.x;
                const tempY = this.pos.y;

                this.pos.x = 2 * this.pos.x - this.prevPos.x + acceleration.x * dt * dt;
                this.pos.y = 2 * this.pos.y - this.prevPos.y + acceleration.y * dt * dt;

                this.prevPos.x = tempX;
                this.prevPos.y = tempY;

                this.force = new Vec2();
            }

            draw(ctx) {
                // Draw interaction radii first (underneath the point)
                if (this.isEater) {
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius * EATING_RADIUS_MULTIPLIER, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 165, 0, 0.05)';
                    ctx.fill();
                }
                if (this.isPredator) {
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius * PREDATION_RADIUS_MULTIPLIER, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 50, 50, 0.05)';
                    ctx.fill();
                }


                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
                let mainColor = this.isFixed ? 'rgba(255,0,0,0.9)' : this.color;
                if (this.nodeType === NodeType.NEURON) {
                    mainColor = (this.neuronData && this.neuronData.isBrain) ? 'rgba(255, 215, 0, 0.95)' : 'rgba(200, 100, 255, 0.9)'; // Gold for brain
                } else if (this.isPredator) {
                    mainColor = 'rgba(255, 50, 50, 0.9)';
                } else if (this.nodeType === NodeType.EMITTER_SWIMMER && this.isEater) {
                     mainColor = 'rgba(200,255,0,0.9)';
                } else if (this.nodeType === NodeType.EMITTER_SWIMMER) {
                    mainColor = 'rgba(0,255,100,0.9)';
                } else if (this.isEater) {
                    mainColor = 'rgba(255,165,0,0.9)';
                } else if (this.nodeType === NodeType.FIXED_ROOT) {
                    mainColor = 'rgba(100, 70, 30, 0.9)';
                }
                ctx.fillStyle = mainColor;
                ctx.fill();

                ctx.save();
                ctx.shadowColor = mainColor;
                ctx.shadowBlur = 7;
                ctx.fill();
                ctx.restore();


                if (this.nodeType === NodeType.NEURON) {
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius * ( (this.neuronData && this.neuronData.isBrain) ? 0.6 : 0.5), 0, Math.PI * 2);
                    ctx.fillStyle = (this.neuronData && this.neuronData.isBrain) ? 'rgba(255, 255, 255, 1)' : 'rgba(250, 200, 255, 0.9)';
                    ctx.fill();
                }
            }
        }
        // --- End MassPoint Class ---


        // --- SoftBody Class ---
        class SoftBody {
            constructor(id, initialX, initialY, parentBody = null) {
                this.id = id;
                this.massPoints = [];
                this.springs = [];
                this.isUnstable = false;
                this.creatureEnergy = MAX_CREATURE_ENERGY * OFFSPRING_INITIAL_ENERGY_SHARE;
                this.ticksSinceBirth = 0;
                this.canReproduce = false;
                this.shapeType = parentBody ? parentBody.shapeType : Math.floor(Math.random() * 3);

                // These are general body parameters, some might be overridden or influenced by neural outputs
                this.motorImpulseInterval = 30 + Math.floor(Math.random() * 90); // For non-neurally controlled random impulses
                this.motorImpulseMagnitudeCap = 0.5 + Math.random() * 2.0;
                // this.emitterStrength = 0.2 + Math.random() * 1.0; // DEPRECATED - neural control
                // this.emitterDirection = new Vec2(Math.random()*2-1, Math.random()*2-1).normalize(); // DEPRECATED

                this.numOffspring = parentBody ? parentBody.numOffspring : (1 + Math.floor(Math.random() * 3));
                this.offspringSpawnRadius = parentBody ? parentBody.offspringSpawnRadius : (50 + Math.random() * 50);
                this.pointAddChance = parentBody ? parentBody.pointAddChance : (ADD_POINT_MUTATION_CHANCE); // Use constant
                this.springConnectionRadius = parentBody ? parentBody.springConnectionRadius : (40 + Math.random() * 40);

                if (parentBody) {
                    this.stiffness = parentBody.stiffness * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER));
                    this.springDamping = parentBody.springDamping * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER));
                    this.motorImpulseInterval = Math.max(10, Math.floor(parentBody.motorImpulseInterval * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER))));
                    this.motorImpulseMagnitudeCap = parentBody.motorImpulseMagnitudeCap * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER));

                    let offspringNumChange = 0;
                    if (Math.random() < Math.max(0, Math.min(1, MUTATION_CHANCE_BOOL * GLOBAL_MUTATION_RATE_MODIFIER))) {
                        offspringNumChange = (Math.random() < 0.5 ? -1 : 1);
                    }
                    this.numOffspring = Math.max(1, Math.min(5, Math.floor(parentBody.numOffspring + offspringNumChange)));
                    this.offspringSpawnRadius = Math.max(20, parentBody.offspringSpawnRadius * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER * 0.5)));
                    this.pointAddChance = Math.max(0, Math.min(0.5, parentBody.pointAddChance * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER * 2))));
                    this.springConnectionRadius = Math.max(10, parentBody.springConnectionRadius * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER)));

                } else { // Initial generation
                    this.stiffness = 500 + Math.random() * 2500;
                    this.springDamping = 5 + Math.random() * 20;
                }
                // Clamp inherited/randomized values
                this.stiffness = Math.max(100, Math.min(this.stiffness, 10000));
                this.springDamping = Math.max(0.1, Math.min(this.springDamping, 50));
                this.motorImpulseMagnitudeCap = Math.max(0, Math.min(this.motorImpulseMagnitudeCap, 5.0));
                this.motorImpulseInterval = Math.max(10, Math.min(this.motorImpulseInterval, 300));
                this.numOffspring = Math.max(1, Math.min(this.numOffspring, 5));
                this.offspringSpawnRadius = Math.max(20, Math.min(this.offspringSpawnRadius, 150));
                this.pointAddChance = Math.max(0, Math.min(0.5, this.pointAddChance));
                this.springConnectionRadius = Math.max(10, Math.min(this.springConnectionRadius, 100));

                this.fluidEntrainment = BODY_FLUID_ENTRAINMENT_FACTOR;
                this.fluidCurrentStrength = FLUID_CURRENT_STRENGTH_ON_BODY;
                this.bodyPushStrength = SOFT_BODY_PUSH_STRENGTH;

                this.createShape(initialX, initialY, parentBody); // Creates massPoints
                this.initializeBrain(); // Sets up the neural network for the active brain node
            }

            initializeBrain() {
                let brainNode = null;
                let brainNodeIndex = -1;

                for (let i = 0; i < this.massPoints.length; i++) {
                    if (this.massPoints[i].nodeType === NodeType.NEURON) {
                        if (!brainNode) { // First neuron found becomes the brain
                            brainNode = this.massPoints[i];
                            brainNodeIndex = i;
                            if (!brainNode.neuronData) brainNode.neuronData = {}; // Ensure neuronData object exists
                            brainNode.neuronData.isBrain = true;
                        } else {
                            if (this.massPoints[i].neuronData) this.massPoints[i].neuronData.isBrain = false;
                        }
                    }
                }

                if (brainNode) {
                    const nd = brainNode.neuronData;
                    nd.inputVectorSize = NEURAL_INPUT_SIZE; // Fixed for now
                    const numEmitterSwimmers = this.massPoints.filter(mp => mp.nodeType === NodeType.EMITTER_SWIMMER).length;
                    nd.outputVectorSize = numEmitterSwimmers * NEURAL_OUTPUTS_PER_EMITTER_SWIMMER;

                    // Inherit or initialize hiddenLayerSize
                    if (typeof nd.hiddenLayerSize !== 'number' || nd.hiddenLayerSize <= 0) {
                         nd.hiddenLayerSize = Math.floor(DEFAULT_HIDDEN_LAYER_SIZE_MIN + Math.random() * (DEFAULT_HIDDEN_LAYER_SIZE_MAX - DEFAULT_HIDDEN_LAYER_SIZE_MIN + 1));
                    }
                    // Ensure hiddenLayerSize is an integer and within reasonable bounds
                    nd.hiddenLayerSize = Math.max(1, Math.min(Math.round(nd.hiddenLayerSize), DEFAULT_HIDDEN_LAYER_SIZE_MAX * 2));


                    // Initialize weights and biases only if outputVectorSize is > 0 and they don't exist or dimensions mismatch
                    // For Phase 1, we re-initialize weights if the body structure (num emitters) changes significantly enough to alter outputVectorSize,
                    // or if it's a brand new brain.
                    let needsWeightReinit = false;
                    if (!nd.weightsIH || !nd.biasesH || !nd.weightsHO || !nd.biasesO) {
                        needsWeightReinit = true;
                    } else {
                        // Check if dimensions match current configuration
                        if (nd.weightsIH.length !== nd.hiddenLayerSize || (nd.weightsIH[0] && nd.weightsIH[0].length !== nd.inputVectorSize)) needsWeightReinit = true;
                        if (nd.biasesH.length !== nd.hiddenLayerSize) needsWeightReinit = true;
                        if (nd.weightsHO.length !== nd.outputVectorSize || (nd.weightsHO[0] && nd.weightsHO[0].length !== nd.hiddenLayerSize)) needsWeightReinit = true;
                        if (nd.biasesO.length !== nd.outputVectorSize) needsWeightReinit = true;
                    }


                    if (needsWeightReinit && nd.outputVectorSize > 0 && nd.hiddenLayerSize > 0 && nd.inputVectorSize > 0) {
                        nd.weightsIH = initializeMatrix(nd.hiddenLayerSize, nd.inputVectorSize);
                        nd.biasesH = initializeVector(nd.hiddenLayerSize);
                        nd.weightsHO = initializeMatrix(nd.outputVectorSize, nd.hiddenLayerSize);
                        nd.biasesO = initializeVector(nd.outputVectorSize);
                        // console.log(`Body ${this.id} Brain Initialized: Hidden ${nd.hiddenLayerSize}, In ${nd.inputVectorSize}, Out ${nd.outputVectorSize}`);
                    } else if (nd.outputVectorSize === 0 || nd.hiddenLayerSize === 0 || nd.inputVectorSize === 0) {
                        // Brain cannot function if any dimension is zero, clear weights
                        nd.weightsIH = []; nd.biasesH = []; nd.weightsHO = []; nd.biasesO = [];
                         // console.log(`Body ${this.id} Brain Inoperable: Hidden ${nd.hiddenLayerSize}, In ${nd.inputVectorSize}, Out ${nd.outputVectorSize}`);
                    }
                }
            }


            createShape(startX, startY, parentBody = null) {
                this.massPoints = []; // Clear before populating
                this.springs = [];   // Clear before populating

                const baseRadius = 3 + Math.random() * 3;
                const eaterChance = 0.25;
                const predatorChance = 0.15;
                const dyeEmitterChance = 0.2;
                const nodeTypeChoices = [NodeType.NEUTRAL, NodeType.FLOATING, NodeType.FIXED_ROOT, NodeType.EMITTER_SWIMMER, NodeType.NEURON];
                const dyeColorChoices = [DYE_COLORS.RED, DYE_COLORS.GREEN, DYE_COLORS.BLUE];

                if (parentBody) {
                    const parentBrainNode = parentBody.massPoints.find(p => p.neuronData && p.neuronData.isBrain);

                    parentBody.massPoints.forEach(parentPoint => {
                        let mass = parentPoint.mass * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER));
                        mass = Math.max(0.1, Math.min(mass, 1.0));
                        let nodeType = parentPoint.nodeType;
                        if (Math.random() < (MUTATION_CHANCE_NODE_TYPE * GLOBAL_MUTATION_RATE_MODIFIER)) {
                            nodeType = nodeTypeChoices[Math.floor(Math.random() * nodeTypeChoices.length)];
                        }

                        const offspringPoint = new MassPoint(
                            parentPoint.pos.x + (Math.random() - 0.5) * 5, // Slight offset
                            parentPoint.pos.y + (Math.random() - 0.5) * 5,
                            mass,
                            parentPoint.radius * (1 + (Math.random() - 0.5) * 0.2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER))
                        );
                        offspringPoint.nodeType = nodeType;
                        offspringPoint.isEater = Math.random() < (MUTATION_CHANCE_BOOL * GLOBAL_MUTATION_RATE_MODIFIER) ? !parentPoint.isEater : parentPoint.isEater;
                        offspringPoint.isPredator = Math.random() < (MUTATION_CHANCE_BOOL * GLOBAL_MUTATION_RATE_MODIFIER) ? !parentPoint.isPredator : parentPoint.isPredator;
                        offspringPoint.emitsDye = Math.random() < (MUTATION_CHANCE_BOOL * GLOBAL_MUTATION_RATE_MODIFIER) ? !parentPoint.emitsDye : parentPoint.emitsDye;
                        offspringPoint.dyeColor = Math.random() < (MUTATION_CHANCE_BOOL * GLOBAL_MUTATION_RATE_MODIFIER) ? dyeColorChoices[Math.floor(Math.random() * dyeColorChoices.length)] : [...parentPoint.dyeColor];

                        if (nodeType === NodeType.NEURON) {
                            offspringPoint.neuronData = { isBrain: false }; // Default, brain status determined later
                            if (parentPoint.neuronData) { // Inherit hiddenLayerSize potential
                                offspringPoint.neuronData.hiddenLayerSize = parentPoint.neuronData.hiddenLayerSize ||
                                    Math.floor(DEFAULT_HIDDEN_LAYER_SIZE_MIN + Math.random() * (DEFAULT_HIDDEN_LAYER_SIZE_MAX - DEFAULT_HIDDEN_LAYER_SIZE_MIN + 1));
                                if (parentPoint === parentBrainNode) { // If this was the parent's brain node
                                     offspringPoint.neuronData.hiddenLayerSize = offspringPoint.neuronData.hiddenLayerSize * (1 + (Math.random() - 0.5) * 0.2 * GLOBAL_MUTATION_RATE_MODIFIER);
                                     offspringPoint.neuronData.hiddenLayerSize = Math.max(DEFAULT_HIDDEN_LAYER_SIZE_MIN, Math.min(Math.round(offspringPoint.neuronData.hiddenLayerSize), DEFAULT_HIDDEN_LAYER_SIZE_MAX * 2));
                                }
                            } else {
                                offspringPoint.neuronData.hiddenLayerSize = Math.floor(DEFAULT_HIDDEN_LAYER_SIZE_MIN + Math.random() * (DEFAULT_HIDDEN_LAYER_SIZE_MAX - DEFAULT_HIDDEN_LAYER_SIZE_MIN + 1));
                            }
                        }
                        if(offspringPoint.nodeType === NodeType.FIXED_ROOT) offspringPoint.isFixed = true;
                        this.massPoints.push(offspringPoint);

                        if (Math.random() < this.pointAddChance) { // Use the body's pointAddChance
                            const lastPointPos = this.massPoints[this.massPoints.length-1].pos.clone();
                            const newMass = 0.1 + Math.random() * 0.9;
                            const newNodeType = nodeTypeChoices[Math.floor(Math.random() * nodeTypeChoices.length)];
                            const newPoint = new MassPoint(
                                lastPointPos.x + (Math.random() - 0.5) * NEW_POINT_OFFSET_RADIUS * 2,
                                lastPointPos.y + (Math.random() - 0.5) * NEW_POINT_OFFSET_RADIUS * 2,
                                newMass, baseRadius * (0.8 + Math.random() * 0.4)
                            );
                            newPoint.nodeType = newNodeType;
                            newPoint.isEater = Math.random() < eaterChance;
                            newPoint.isPredator = Math.random() < predatorChance;
                            newPoint.emitsDye = Math.random() < dyeEmitterChance;
                            newPoint.dyeColor = dyeColorChoices[Math.floor(Math.random() * dyeColorChoices.length)];
                            if (newNodeType === NodeType.NEURON) {
                                newPoint.neuronData = { isBrain: false, hiddenLayerSize: Math.floor(DEFAULT_HIDDEN_LAYER_SIZE_MIN + Math.random() * (DEFAULT_HIDDEN_LAYER_SIZE_MAX - DEFAULT_HIDDEN_LAYER_SIZE_MIN + 1)) };
                            }
                            if(newPoint.nodeType === NodeType.FIXED_ROOT) newPoint.isFixed = true;
                            this.massPoints.push(newPoint);
                        }
                    });
                    if (this.massPoints.length === 0) { // Fallback if parent had no points (shouldn't happen)
                        this.massPoints.push(new MassPoint(startX, startY, 0.5, baseRadius));
                        if (Math.random() < NEURON_CHANCE) { this.massPoints[0].nodeType = NodeType.NEURON; this.massPoints[0].neuronData = {isBrain: false, hiddenLayerSize: Math.floor(DEFAULT_HIDDEN_LAYER_SIZE_MIN + Math.random() * (DEFAULT_HIDDEN_LAYER_SIZE_MAX - DEFAULT_HIDDEN_LAYER_SIZE_MIN + 1)) }; }
                    }
                } else { // Initial generation logic (copied from before, with neuronData init)
                    const basePointDist = 20 + Math.random() * 10;
                    if (this.shapeType === 0) { /* ... Grid ... */ }
                    else if (this.shapeType === 1) { /* ... Line ... */ }
                    else { /* ... Star ... */ }
                    // Simplified initial generation - you can paste your original logic here
                    const numPoints = Math.floor(3 + Math.random() * 4);
                    for(let i=0; i<numPoints; i++){
                        const p = new MassPoint(startX + (Math.random()-0.5)*numPoints*5, startY + (Math.random()-0.5)*numPoints*5, 0.3+Math.random()*0.4, baseRadius);
                        p.isEater = Math.random() < eaterChance; p.isPredator = Math.random() < predatorChance; p.emitsDye = Math.random() < dyeEmitterChance; p.dyeColor = dyeColorChoices[Math.floor(Math.random() * dyeColorChoices.length)];
                        if (Math.random() < NEURON_CHANCE && numPoints > 1) p.nodeType = NodeType.NEURON;
                        else if(Math.random() < 0.3) p.nodeType = NodeType.EMITTER_SWIMMER;

                        if (p.nodeType === NodeType.NEURON) p.neuronData = { isBrain: false, hiddenLayerSize: Math.floor(DEFAULT_HIDDEN_LAYER_SIZE_MIN + Math.random() * (DEFAULT_HIDDEN_LAYER_SIZE_MAX - DEFAULT_HIDDEN_LAYER_SIZE_MIN + 1)) };
                        if (p.nodeType === NodeType.FIXED_ROOT) p.isFixed = true;
                        this.massPoints.push(p);
                    }
                }

                // Common spring creation logic (for any shape created)
                if (this.massPoints.length > 1) {
                    for (let i = 0; i < this.massPoints.length; i++) {
                        for (let j = i + 1; j < this.massPoints.length; j++) {
                            const p1 = this.massPoints[i];
                            const p2 = this.massPoints[j];
                            const dist = p1.pos.sub(p2.pos).mag();
                            if (dist < this.springConnectionRadius && dist > 0.1) { // Use body's springConnectionRadius
                                this.springs.push(new Spring(p1, p2, this.stiffness, this.springDamping, dist));
                            }
                        }
                    }
                    // Ensure connectivity if only a few points and no springs formed by radius rule
                    if (this.springs.length === 0 && this.massPoints.length > 1 && this.massPoints.length <= 3) {
                        for(let i=0; i < this.massPoints.length-1; i++){
                           this.springs.push(new Spring(this.massPoints[i], this.massPoints[i+1], this.stiffness, this.springDamping));
                        }
                        if(this.massPoints.length === 3) this.springs.push(new Spring(this.massPoints[0], this.massPoints[2], this.stiffness, this.springDamping));
                    }
                }
                 // Old simple neuron linking (sensor/effector) is now removed. The brain handles outputs.
            }


            getAveragePosition() { /* ... (same as your provided code) ... */ }
            getAverageVelocity() { /* ... (same as your provided code) ... */ }


            updateSelf(dt, fluidFieldRef) {
                if (this.isUnstable) return;

                const brainNode = this.massPoints.find(p => p.neuronData && p.neuronData.isBrain);

                if (brainNode && brainNode.neuronData && brainNode.neuronData.weightsIH && brainNode.neuronData.hiddenLayerSize > 0 && brainNode.neuronData.outputVectorSize > 0) {
                    const nd = brainNode.neuronData;
                    const inputVector = [];

                    // 1. Dye at brain node's position
                    const brainGx = Math.floor(brainNode.pos.x / fluidFieldRef.scaleX);
                    const brainGy = Math.floor(brainNode.pos.y / fluidFieldRef.scaleY);
                    const brainFluidIdx = fluidFieldRef.IX(brainGx, brainGy);
                    inputVector.push( (fluidFieldRef.densityR[brainFluidIdx] || 0) / 255.0 );
                    inputVector.push( (fluidFieldRef.densityG[brainFluidIdx] || 0) / 255.0 );
                    inputVector.push( (fluidFieldRef.densityB[brainFluidIdx] || 0) / 255.0 );

                    // 2. Normalized Creature Energy
                    inputVector.push(this.creatureEnergy / MAX_CREATURE_ENERGY);

                    // 3. Relative CoM Position to Brain Node
                    const comPos = this.getAveragePosition();
                    const relComX = (comPos.x - brainNode.pos.x) / WORLD_WIDTH; // Normalize
                    const relComY = (comPos.y - brainNode.pos.y) / WORLD_HEIGHT; // Normalize
                    inputVector.push(tanh(relComX)); // Use tanh to keep it bounded
                    inputVector.push(tanh(relComY));

                    // 4. Relative CoM Velocity to Brain Node's Velocity
                    const comVel = this.getAverageVelocity(); // This is displacement per frame
                    const brainVelX = brainNode.pos.x - brainNode.prevPos.x;
                    const brainVelY = brainNode.pos.y - brainNode.prevPos.y;
                    const relComVelX = (comVel.x - brainVelX) / (MAX_PIXELS_PER_FRAME_DISPLACEMENT * 0.1); // Normalize
                    const relComVelY = (comVel.y - brainVelY) / (MAX_PIXELS_PER_FRAME_DISPLACEMENT * 0.1); // Normalize
                    inputVector.push(tanh(relComVelX));
                    inputVector.push(tanh(relComVelY));

                    // --- Forward Propagation ---
                    // Hidden Layer
                    let hiddenInputs = multiplyMatrixVector(nd.weightsIH, inputVector);
                    let hiddenWithBiases = addVectors(hiddenInputs, nd.biasesH);
                    let hiddenActivations = hiddenWithBiases.map(v => tanh(v));

                    // Output Layer
                    let outputInputs = multiplyMatrixVector(nd.weightsHO, hiddenActivations);
                    let rawOutputs = addVectors(outputInputs, nd.biasesO);

                    // --- Apply Outputs ---
                    let outputIdx = 0;
                    this.massPoints.forEach(point => {
                        if (point.nodeType === NodeType.EMITTER_SWIMMER) {
                            if (outputIdx + NEURAL_OUTPUTS_PER_EMITTER_SWIMMER <= rawOutputs.length) {
                                // Force X & Y (output uses tanh, range [-1, 1])
                                const forceX = tanh(rawOutputs[outputIdx++]) * MAX_NEURAL_FORCE_COMPONENT * point.mass; // Scale by mass
                                const forceY = tanh(rawOutputs[outputIdx++]) * MAX_NEURAL_FORCE_COMPONENT * point.mass;
                                point.applyForce(new Vec2(forceX / dt, forceY / dt)); // Apply as impulse

                                // Target Dye R, G, B (output uses sigmoid, range [0, 1])
                                const targetR = sigmoid(rawOutputs[outputIdx++]) * 255;
                                const targetG = sigmoid(rawOutputs[outputIdx++]) * 255;
                                const targetB = sigmoid(rawOutputs[outputIdx++]) * 255;
                                // Emission Strength (output uses sigmoid, range [0, 1])
                                const emissionPull = sigmoid(rawOutputs[outputIdx++]) * MAX_NEURAL_EMISSION_PULL_STRENGTH;

                                if (emissionPull > 0.01) { // Only emit if strength is significant
                                     const emitterFluidGx = Math.floor(point.pos.x / fluidFieldRef.scaleX);
                                     const emitterFluidGy = Math.floor(point.pos.y / fluidFieldRef.scaleY);
                                     // Use a fraction of DYE_PULL_RATE based on neural output
                                     const effectiveEmissionStrength = DYE_PULL_RATE * emissionPull * 50; // *50 to roughly match original addDensity magnitude
                                     fluidFieldRef.addDensity(emitterFluidGx, emitterFluidGy, targetR, targetG, targetB, effectiveEmissionStrength);
                                }
                                point.dyeColor = [Math.floor(targetR), Math.floor(targetG), Math.floor(targetB)]; // Store for info panel
                            }
                        }
                    });
                } else { // No brain or inoperable brain - fallback to simpler behaviors
                    if (this.motorImpulseMagnitudeCap > 0.0001 && (this.ticksSinceBirth % this.motorImpulseInterval === 0)) {
                        for (let point of this.massPoints) {
                            if (!point.isFixed && point.nodeType !== NodeType.FIXED_ROOT) {
                                const randomAngle = Math.random() * Math.PI * 2;
                                const impulseDir = new Vec2(Math.cos(randomAngle), Math.sin(randomAngle));
                                const impulseMag = Math.random() * this.motorImpulseMagnitudeCap;
                                const impulseForce = impulseDir.mul(impulseMag / dt); // Convert to force for applyForce
                                point.applyForce(impulseForce);
                            }
                        }
                    }
                     // Simpler dye emission for non-brained or brain-fallback creatures with EMITTER_SWIMMER nodes
                    this.massPoints.forEach(point => {
                        if (point.nodeType === NodeType.EMITTER_SWIMMER && point.emitsDye && fluidFieldRef) { // Check point.emitsDye flag
                            const emitterFluidGx = Math.floor(point.pos.x / fluidFieldRef.scaleX);
                            const emitterFluidGy = Math.floor(point.pos.y / fluidFieldRef.scaleY);
                            fluidFieldRef.addDensity(emitterFluidGx, emitterFluidGy, point.dyeColor[0], point.dyeColor[1], point.dyeColor[2], 50); // Default strength
                        }
                    });
                }


                // Calculate and apply energy cost
                let currentFrameEnergyCost = 0;
                for (const point of this.massPoints) {
                    currentFrameEnergyCost += BASE_NODE_EXISTENCE_COST;
                    if (point.nodeType === NodeType.EMITTER_SWIMMER) { // Cost if it's an emitter/swimmer, whether brain controlled or not
                        currentFrameEnergyCost += EMITTER_NODE_ENERGY_COST;
                    }
                    if (point.nodeType === NodeType.NEURON) { // Neuron cost, higher if it's an active brain
                        currentFrameEnergyCost += NEURON_NODE_ENERGY_COST * ( (point.neuronData && point.neuronData.isBrain && point.neuronData.hiddenLayerSize) ? point.neuronData.hiddenLayerSize * 0.1 : 1.0);
                    }
                    if (point.isEater) { currentFrameEnergyCost += EATER_NODE_ENERGY_COST; }
                    if (point.isPredator) { currentFrameEnergyCost += PREDATOR_NODE_ENERGY_COST; }
                }
                this.creatureEnergy -= currentFrameEnergyCost * dt;

                this.ticksSinceBirth++;
                if (this.ticksSinceBirth > REPRODUCTION_COOLDOWN_TICKS) {
                    this.canReproduce = true;
                }

                if (this.creatureEnergy <= 0) {
                    this.isUnstable = true; return;
                }

                // Fluid interaction for FLOATING nodes (not directly brain controlled force-wise)
                if (fluidFieldRef) {
                    for (let point of this.massPoints) {
                        if (point.isFixed || point.nodeType === NodeType.FIXED_ROOT) continue;
                        if (point.nodeType === NodeType.FLOATING) {
                            const fluidGridX = Math.floor(point.pos.x / fluidFieldRef.scaleX);
                            const fluidGridY = Math.floor(point.pos.y / fluidFieldRef.scaleY);
                            const idx = fluidFieldRef.IX(fluidGridX, fluidGridY);
                            const rawFluidVx = fluidFieldRef.Vx[idx];
                            const rawFluidVy = fluidFieldRef.Vy[idx];
                            let fluidDisplacementPx = new Vec2(rawFluidVx * fluidFieldRef.scaleX * dt, rawFluidVy * fluidFieldRef.scaleY * dt);
                            let effectiveFluidDisplacementPx = fluidDisplacementPx.mul(this.fluidCurrentStrength);
                            let currentPointDisplacementPx = point.pos.sub(point.prevPos);
                            let blendedDisplacementPx = currentPointDisplacementPx.mul(1.0 - this.fluidEntrainment)
                                                             .add(effectiveFluidDisplacementPx.mul(this.fluidEntrainment));
                            point.prevPos = point.pos.clone().sub(blendedDisplacementPx);
                        }
                    }
                }


                for (let spring of this.springs) spring.applyForce();
                // Inter-body repulsion & Predation (from your provided code)
                for (let i_p1 = 0; i_p1 < this.massPoints.length; i_p1++) { /* ... */ }

                for (let point of this.massPoints) point.update(dt);

                // Instability Checks (from your provided code)
                // ...

                if (!this.isUnstable) { // Eating logic (from your provided code)
                    for (let point of this.massPoints) { /* ... */ }
                }

                if (!this.isUnstable) { // Boundary conditions (from your provided code)
                    for (let point of this.massPoints) { /* ... */ }
                }
            } // End updateSelf


            reproduce() { /* ... (Should mostly work, ensure neuronData inheritance is handled for hiddenLayerSize) ... */ }
            getBoundingBox() { /* ... (same as your provided code) ... */ }
            // getAveragePosition() and getAverageVelocity() are above or in your provided code

            drawSelf(ctx) {
                if (this.isUnstable) return;
                for (let spring of this.springs) spring.draw(ctx);
                for (let point of this.massPoints) point.draw(ctx);
            }
        }
        // --- End SoftBody Class ---

        // The rest of your simulation code (FluidField, Particle, event listeners, main loop, etc.)
        // would follow here. I've focused on SoftBody and MassPoint for the neural changes.
    </script>
</body>
</html>