<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Soft Body Evolution - NN Step 2: Neuron Init</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            font-family: sans-serif;
            color: #eee;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #pageContainer {
            display: flex;
            flex-direction: row;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }

        #simulationAndInfoWrapper {
            display: flex;
            flex-direction: row;
            justify-content: flex-start;
            align-items: stretch;
            gap: 10px;
            flex-grow: 1;
            padding: 10px;
            box-sizing: border-box;
            height: 100%;
            position: relative;
        }
        #infoPanel {
            position: fixed;
            top: 15px;
            left: -330px;
            width: 300px;
            max-height: calc(100vh - 30px);
            background-color: rgba(30,30,30,0.95);
            border: 1px solid #555;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            z-index: 1000;
            color: #eee;
            font-size: 0.8em;
            display: block;
            opacity: 0;
            visibility: hidden;
            transition: left 0.3s ease-in-out, opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
            overflow-y: auto;
            box-sizing: border-box;
        }
        #infoPanel.open {
            left: 15px;
            opacity: 1;
            visibility: visible;
        }
        #canvasContainer {
            flex-grow: 1;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            background-color: #000;
            border: 1px solid #444;
            border-radius: 8px;
        }
        canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            cursor: default;
        }
        canvas.emitter-edit-mode {
            cursor: crosshair;
        }

        .ui-button-top-right {
            position: fixed;
            padding: 8px 12px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 1002;
        }
        .ui-button-top-right:hover {
            background-color: #0056b3;
        }

        #toggleControlsButton {
            top: 15px;
            right: 15px;
        }
        #screensaverButton {
            top: 15px;
            right: 100px;
        }


        #controls {
            position: fixed;
            top: 0;
            right: -360px;
            width: 330px;
            height: 100vh;
            background-color: rgba(40,40,40,0.95);
            padding: 15px;
            border-left: 1px solid #555;
            box-shadow: -5px 0 15px rgba(0,0,0,0.3);
            overflow-y: auto;
            z-index: 1001;
            transition: right 0.3s ease-in-out;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-sizing: border-box;
        }
        #controls.open {
            right: 0;
        }
        #controls div.control-group {
            padding: 10px;
            border: 1px solid #555;
            border-radius: 6px;
            background-color: rgba(50,50,50,0.8);
            min-width: auto;
            max-width: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        #controls label.slider-label, #controls label.checkbox-label, #controls label.input-label { display: block; margin-bottom: 2px; font-size: 0.85em; font-weight: bold; color: #ddd; text-align: left; }
        #controls label.checkbox-label { margin-top: 8px; display: flex; align-items: center; }
        #controls input[type="checkbox"] { margin-left: 5px; }
        #controls input[type="number"] { width: 100%; padding: 5px; margin-top: 2px; margin-bottom: 5px; box-sizing: border-box; background-color: #333; color: #eee; border: 1px solid #555; border-radius: 3px;}
        #controls span.slider-value { display: block; font-size: 0.8em; text-align: right; color: #00aeff; margin-bottom: 3px; min-height: 1em; }
        #controls input[type="range"] { width: 100%; margin-top: 0; box-sizing: border-box; }
        #controls input[type="range"]:disabled + span.slider-value, #controls input[type="range"]:disabled ~ label.slider-label, #controls input[type="range"]:disabled { color: #777; opacity: 0.6; }
        #controls button { padding: 8px 12px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 8px; width: 100%; box-sizing: border-box; }
        #controls button:hover { background-color: #0056b3; }
        .control-group h4 { margin-top: 0; margin-bottom: 10px; text-align: center; color: #00aeff; width: 100%; font-size: 1em; }
        .indicator-label { font-size: 0.85em; color: #ddd; margin-top: 8px; }
        .indicator-light { display: inline-block; width: 12px; height: 12px; border-radius: 50%; background-color: #4CAF50; margin-left: 5px; vertical-align: middle; border: 1px solid #222; transition: background-color 0.3s; }
        .indicator-light.unstable { background-color: #F44336; }
        #populationCount { margin-top: 10px; font-size: 0.9em; color: #ccc; text-align: center; width: 100%; }
        .viewport-instructions { font-size: 0.8em; color: #bbb; text-align: center; margin-top: 5px; }
        #infoPanel h5 { margin-top: 0; margin-bottom: 8px; color: #00aeff; border-bottom: 1px solid #444; padding-bottom: 5px; }
        #infoPanel p { margin: 3px 0; line-height: 1.4; }
        #infoPanel strong { color: #bbb; }
        #infoPanel .info-section { margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px dashed #333; }
        #infoPanel .info-section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }

        #allPointsInfoContainer .point-info-entry {
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
            margin-bottom: 8px;
        }
        #allPointsInfoContainer .point-info-entry:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
         #allPointsInfoContainer .point-info-entry h6 {
            margin: 5px 0 3px 0;
            color: #7fdbff; /* A lighter blue for sub-headings */
            font-size: 0.9em;
        }


        #closeInfoPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #555;
            color: white;
            border: none;
            padding: 3px 7px;
            cursor: pointer;
            border-radius: 3px;
        }

        /* Screensaver Mode Styles */
        body.screensaver-active #controls,
        body.screensaver-active #infoPanel,
        body.screensaver-active #toggleControlsButton,
        body.screensaver-active #screensaverButton.in-screensaver { /* Hide button when in screensaver via CSS */
            display: none !important;
        }

        body.css-screensaver-active #pageContainer {
             position: fixed !important;
             top: 0 !important;
             left: 0 !important;
             width: 100vw !important;
             height: 100vh !important;
             padding: 0 !important;
             margin: 0 !important;
             z-index: 2000 !important;
             display: flex !important;
             flex-direction: column !important;
        }
         body.css-screensaver-active #simulationAndInfoWrapper {
            flex-grow: 1 !important;
            width: 100% !important;
            height: 100% !important;
            padding: 0 !important;
            gap: 0 !important;
            display: flex !important;
        }
        body.css-screensaver-active #canvasContainer {
            flex-grow: 1 !important;
            width: 100% !important;
            height: 100% !important;
            border-radius: 0 !important;
            border: none !important;
            background-color: #000 !important; /* Make background black */
        }
    </style>
</head>
<body>
    <div id="pageContainer">
        <div id="simulationAndInfoWrapper">
            <div id="infoPanel"> <button id="closeInfoPanel">X</button>
                <div class="info-section">
                    <h5>Soft Body Info</h5>
                    <p><strong>ID:</strong> <span id="infoBodyId">-</span></p>
                    <p><strong>Stiffness:</strong> <span id="infoBodyStiffness">-</span></p>
                    <p><strong>Damping:</strong> <span id="infoBodyDamping">-</span></p>
                    <p><strong>Motor Impulse Interval:</strong> <span id="infoBodyMotorInterval">-</span></p>
                    <p><strong>Motor Impulse Cap:</strong> <span id="infoBodyMotorCap">-</span></p>
                    <p><strong>Num Offspring:</strong> <span id="infoBodyNumOffspring">-</span></p>
                    <p><strong>Offspring Spawn Radius:</strong> <span id="infoBodyOffspringRadius">-</span></p>
                    <p><strong>Point Add Chance:</strong> <span id="infoBodyPointAddChance">-</span></p>
                    <p><strong>Spring Connection Radius:</strong> <span id="infoBodySpringConnectionRadius">-</span></p>
                    <p><strong>Energy:</strong> <span id="infoBodyEnergy">-</span></p>
                    <p><strong>Ticks Since Birth:</strong> <span id="infoBodyTicksBirth">-</span></p>
                    <p><strong>Can Reproduce:</strong> <span id="infoBodyCanReproduce">-</span></p>
                </div>

                <div id="allPointsInfoContainer" class="info-section">
                    </div>
            </div>
            <div id="canvasContainer">
                <canvas id="simulationCanvas"></canvas>
            </div>
        </div>

        <button id="toggleControlsButton" class="ui-button-top-right">Controls</button>
        <button id="screensaverButton" class="ui-button-top-right">Enter Screensaver</button>

        <div id="controls">
            <div class="control-group">
                <h4>Viewport & Sim</h4>
                <div class="viewport-instructions">WASD/Right-Drag to Pan, Scroll to Zoom</div>
                <label for="worldWidthInput" class="input-label">World Width:</label>
                <input type="number" id="worldWidthInput" value="8000" step="100">
                <label for="worldHeightInput" class="input-label">World Height:</label>
                <input type="number" id="worldHeightInput" value="6000" step="100">
                <button id="resizeWorldButton">Resize World & Reset Sim</button>

                <label for="worldWrapToggle" class="checkbox-label">Wrap Edges:
                    <input type="checkbox" id="worldWrapToggle">
                </label>
                <label for="maxTimestep" class="slider-label">Max Timestep (ms):</label>
                <span id="maxTimestepValue" class="slider-value">10</span>
                <input type="range" id="maxTimestep" min="1" max="50" value="10" step="1">
                <label for="zoomSensitivitySlider" class="slider-label">Zoom Sensitivity:</label>
                <span id="zoomSensitivityValueSpan" class="slider-value">0.0200</span>
                <input type="range" id="zoomSensitivitySlider" min="0.005" max="0.03" value="0.02" step="0.0005">
                <button id="pauseResumeButton">Pause</button>
            </div>
            <div class="control-group">
                <h4>Soft Body (Global)</h4>
                <label for="creaturePopulationFloorSlider" class="slider-label">Creature Pop. Floor:</label>
                <span id="creaturePopulationFloorValueSpan" class="slider-value">10</span>
                <input type="range" id="creaturePopulationFloorSlider" min="1" max="1000" value="10" step="10">

                <label for="creaturePopulationCeilingSlider" class="slider-label">Creature Pop. Ceiling:</label>
                <span id="creaturePopulationCeilingValueSpan" class="slider-value">1000</span>
                <input type="range" id="creaturePopulationCeilingSlider" min="10" max="2000" value="1000" step="10">

                <label for="globalMutationRate" class="slider-label">Global Mutation Rate:</label>
                <span id="globalMutationRateValue" class="slider-value">0.25</span>
                <input type="range" id="globalMutationRate" min="0.1" max="3.0" value="0.25" step="0.05">

                <label for="bodyFluidEntrainment" class="slider-label">Fluid Entrainment (Floaters):</label>
                <span id="bodyFluidEntrainmentValue" class="slider-value">0.47</span>
                <input type="range" id="bodyFluidEntrainment" min="0.0" max="0.7" value="0.465" step="0.005">

                <label for="fluidCurrentStrength" class="slider-label">Fluid Current Str (Floaters):</label>
                <span id="fluidCurrentStrengthValue" class="slider-value">19.7</span>
                <input type="range" id="fluidCurrentStrength" min="0.0" max="30.0" value="19.7" step="0.1">

                <label for="bodyPushStrength" class="slider-label">Body Push Strength (Manual Drag):</label>
                <span id="bodyPushStrengthValue" class="slider-value">0.10</span>
                <input type="range" id="bodyPushStrength" min="0.0" max="2.0" value="0.10" step="0.05">

                <label for="reproductionCooldown" class="slider-label">Repro. Cooldown (frames):</label>
                <span id="reproductionCooldownValue" class="slider-value">1000</span>
                <input type="range" id="reproductionCooldown" min="100" max="5000" value="1000" step="50">

                <label for="bodyRepulsionStrength" class="slider-label">Body Repulsion Str:</label>
                <span id="bodyRepulsionStrengthValue" class="slider-value">100.0</span>
                <input type="range" id="bodyRepulsionStrength" min="0.0" max="200.0" value="100.0" step="0.5">

                <label for="bodyRepulsionRadiusFactor" class="slider-label">Body Repulsion Radius Factor:</label>
                <span id="bodyRepulsionRadiusFactorValue" class="slider-value">5.0</span>
                <input type="range" id="bodyRepulsionRadiusFactor" min="0.0" max="10.0" value="5.0" step="0.1">

                <div class="indicator-label">Any Unstable: <span id="instabilityLight" class="indicator-light"></span></div>
                <div id="populationCount">Population: 0</div>
                <button id="resetButton">Reset Population</button>
            </div>
            <div class="control-group">
                <h4>Energy Costs / Frame</h4>
                <label for="baseNodeCost" class="slider-label">Base Node Cost:</label>
                <span id="baseNodeCostValue" class="slider-value">0.3</span>
                <input type="range" id="baseNodeCost" min="0.0" max="50.0" value="0.3" step="0.1">

                <label for="emitterNodeCost" class="slider-label">Emitter Node Cost:</label>
                <span id="emitterNodeCostValue" class="slider-value">1.0000</span>
                <input type="range" id="emitterNodeCost" min="0.0" max="50.0" value="1.0" step="0.1">

                <label for="eaterNodeCost" class="slider-label">Eater Node Cost:</label>
                <span id="eaterNodeCostValue" class="slider-value">0.3</span>
                <input type="range" id="eaterNodeCost" min="0.0" max="50.0" value="0.3" step="0.1">

                <label for="predatorNodeCost" class="slider-label">Predator Node Cost:</label>
                <span id="predatorNodeCostValue" class="slider-value">0.8</span>
                <input type="range" id="predatorNodeCost" min="0.0" max="100.0" value="0.8" step="0.1">

                <label for="neuronNodeCost" class="slider-label">Neuron Node Cost:</label>
                <span id="neuronNodeCostValue" class="slider-value">0.0100</span>
                <input type="range" id="neuronNodeCost" min="0.0" max="0.5" value="0.01" step="0.001">
            </div>
            <div class="control-group">
                <h4>Fluid</h4>
                <label for="fluidGridSize" class="slider-label">Fluid Grid Resolution:</label>
                <span id="fluidGridSizeValue" class="slider-value">128</span>
                <input type="range" id="fluidGridSize" min="32" max="256" value="128" step="16">

                <label for="fluidDiffusion" class="slider-label">Diffusion:</label>
                <span id="fluidDiffusionValue" class="slider-value">4.7e-4</span>
                <input type="range" id="fluidDiffusion" min="0" max="0.001" value="0.00047" step="0.00001">

                <label for="fluidViscosity" class="slider-label">Viscosity:</label>
                <span id="fluidViscosityValue" class="slider-value">6.8e-5</span>
                <input type="range" id="fluidViscosity" min="0" max="0.00015" value="0.000068" step="0.000001">

                <label for="fluidFade" class="slider-label">Fade Rate:</label>
                <span id="fluidFadeValue" class="slider-value">0.002</span>
                <input type="range" id="fluidFade" min="0.0" max="1.0" value="0.002" step="0.001">

                <label for="maxFluidVelocityComponentSlider" class="slider-label">Max Fluid Vel. Component:</label>
                <span id="maxFluidVelocityComponentValueSpan" class="slider-value">0.5</span>
                <input type="range" id="maxFluidVelocityComponentSlider" min="0.1" max="10.0" value="0.5" step="0.1">

                <button id="clearFluidButton">Clear Fluid</button>
            </div>
            <div class="control-group">
                <h4>Particles</h4>
                <label for="particlePopulationFloorSlider" class="slider-label">Particle Pop. Floor:</label>
                <span id="particlePopulationFloorValueSpan" class="slider-value">5000</span>
                <input type="range" id="particlePopulationFloorSlider" min="0" max="10000" value="5000" step="50">

                <label for="particlePopulationCeilingSlider" class="slider-label">Particle Pop. Ceiling:</label>
                <span id="particlePopulationCeilingValueSpan" class="slider-value">20000</span>
                <input type="range" id="particlePopulationCeilingSlider" min="0" max="40000" value="20000" step="50">

                <label for="particlesPerSecondSlider" class="slider-label">Particles / Sec (if between floor/ceil):</label>
                <span id="particlesPerSecondValueSpan" class="slider-value">500</span>
                <input type="range" id="particlesPerSecondSlider" min="0" max="1000" value="500" step="1">

                <label for="particleFluidInfluence" class.slider-label="slider-label">Fluid Influence:</label>
                <span id="particleFluidInfluenceValue" class="slider-value">2.00</span>
                <input type="range" id="particleFluidInfluence" min="0.0" max="3.0" value="2.0" step="0.01">

                <label for="particleLifeDecay" id="particleLifeDecayLabel" class="slider-label">Life Decay Rate:</label>
                <span id="particleLifeDecayValue" class="slider-value">0.0010</span>
                <input type="range" id="particleLifeDecay" min="0.0001" max="0.02" value="0.001" step="0.0001">

                <label for="infiniteParticleLifeToggle" class="checkbox-label">Infinite Life:
                    <input type="checkbox" id="infiniteParticleLifeToggle">
                </label>

                <button id="resetParticlesButton">Reset Particles</button>
            </div>
            <div class="control-group">
                <h4>Env. Emitters</h4>
                <label for="emitterEditModeToggle" class="checkbox-label">Edit Emitters:
                    <input type="checkbox" id="emitterEditModeToggle">
                </label>
                <label for="emitterStrength" class="slider-label">Emitter Strength:</label>
                <span id="emitterStrengthValue" class="slider-value">3.0</span>
                <input type="range" id="emitterStrength" min="0.0" max="10.0" value="3.0" step="0.1">
                <button id="clearEmittersButton">Clear Emitters</button>
            </div>
            <div class="control-group">
                <h4>Configuration</h4>
                <button id="exportConfigButton">Export Config</button>
                <input type="file" id="importConfigFile" accept=".json" style="display: none;">
                <button id="importConfigButton">Import Config</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        let offscreenFluidCanvas, offscreenFluidCtx; // For smoother fluid rendering

        // --- Viewport and World Dimensions ---
        let WORLD_WIDTH = 8000;
        let WORLD_HEIGHT = 6000;
        const VIEW_PAN_SPEED = 80;

        canvas.width = WORLD_WIDTH;
        canvas.height = WORLD_HEIGHT;

        let viewOffsetX = 0;
        let viewOffsetY = 0;
        let viewZoom = 1.0;
        let ZOOM_SENSITIVITY;
        const MAX_ZOOM = 8.0;
        let MIN_ZOOM = 0.1;

        // Spatial Grid for optimization
        const GRID_CELL_SIZE = 100;
        let GRID_COLS = Math.ceil(WORLD_WIDTH / GRID_CELL_SIZE);
        let GRID_ROWS = Math.ceil(WORLD_HEIGHT / GRID_CELL_SIZE);
        let spatialGrid = [];

        // Critical Simulation Constants
        const MUTATION_CHANCE_REASSIGN_NEURON_LINK = 0.02;
        const NEURON_CHANCE = 0.1;
        const ADD_POINT_MUTATION_CHANCE = 0.03;
        const NEW_POINT_OFFSET_RADIUS = 15;
        const MAX_PIXELS_PER_FRAME_DISPLACEMENT = 100;
        const MAX_SPRING_STRETCH_FACTOR = 4.0;
        const MAX_SPAN_PER_POINT_FACTOR = GRID_CELL_SIZE * 2;
        const DYE_PULL_RATE = 0.05;
        const PARTICLE_LIFE_DECAY_RANDOM_FACTOR = 0.002;
        const EATING_RADIUS_MULTIPLIER = 3.5;
        const PREDATION_RADIUS_MULTIPLIER = 2.5;
        const ENERGY_PER_PARTICLE = 25;
        const ENERGY_SAPPED_PER_PREDATION = 5;
        const MAX_CREATURE_ENERGY = 100;
        const OFFSPRING_INITIAL_ENERGY_SHARE = 0.25;
        const REPRODUCTION_ADDITIONAL_COST_FACTOR = 0.1;
        const OFFSPRING_PLACEMENT_ATTEMPTS = 10;
        const MUTATION_RATE_PERCENT = 0.1;
        const MUTATION_CHANCE_BOOL = 0.05;
        const MUTATION_CHANCE_NODE_TYPE = 0.1;
        const EMITTER_MOUSE_DRAG_SCALE = 0.1;
        const FLUID_MOUSE_DRAG_VELOCITY_SCALE = 0.1;

        // Neural Network Specific Constants (Added in Step 1)
        const NEURAL_INPUT_SIZE = 8;
        const NEURAL_OUTPUTS_PER_EMITTER_SWIMMER = 6;
        const DEFAULT_HIDDEN_LAYER_SIZE_MIN = 10;
        const DEFAULT_HIDDEN_LAYER_SIZE_MAX = 24;
        const MAX_NEURAL_FORCE_COMPONENT = 1.0;
        const MAX_NEURAL_EMISSION_PULL_STRENGTH = 1.0;

        function initializeSpatialGrid() {
            GRID_COLS = Math.max(1, Math.ceil(WORLD_WIDTH / GRID_CELL_SIZE));
            GRID_ROWS = Math.max(1, Math.ceil(WORLD_HEIGHT / GRID_CELL_SIZE));
            spatialGrid = new Array(GRID_COLS * GRID_ROWS);
            for (let i = 0; i < spatialGrid.length; i++) {
                spatialGrid[i] = [];
            }
        }


        function populateSpatialGrid() {
            for (let i = 0; i < spatialGrid.length; i++) {
                spatialGrid[i] = [];
            }
            softBodyPopulation.forEach(body => {
                if (body.isUnstable) return;
                body.massPoints.forEach(point => {
                    if (isNaN(point.pos.x) || isNaN(point.pos.y) || !isFinite(point.pos.x) || !isFinite(point.pos.y)) {
                        return;
                    }
                    const gx = Math.max(0, Math.min(GRID_COLS - 1, Math.floor(point.pos.x / GRID_CELL_SIZE)));
                    const gy = Math.max(0, Math.min(GRID_ROWS - 1, Math.floor(point.pos.y / GRID_CELL_SIZE)));

                    const gridIndex = gx + gy * GRID_COLS;
                    if(spatialGrid[gridIndex] && Number.isFinite(gridIndex) && gridIndex < spatialGrid.length) {
                        spatialGrid[gridIndex].push({ type: 'softbody_point', pointRef: point, bodyRef: body });
                    }
                });
            });
            particles.forEach(particle => {
                if (particle.life <= 0) return;
                 if (isNaN(particle.pos.x) || isNaN(particle.pos.y) || !isFinite(particle.pos.x) || !isFinite(particle.pos.y)) {
                    return;
                }
                const gx = Math.max(0, Math.min(GRID_COLS - 1, Math.floor(particle.pos.x / GRID_CELL_SIZE)));
                const gy = Math.max(0, Math.min(GRID_ROWS - 1, Math.floor(particle.pos.y / GRID_CELL_SIZE)));
                const gridIndex = gx + gy * GRID_COLS;
                 if(spatialGrid[gridIndex] && Number.isFinite(gridIndex) && gridIndex < spatialGrid.length) {
                    spatialGrid[gridIndex].push({ type: 'particle', particleRef: particle });
                }
            });
        }


        // --- Controls ---
        const worldWidthInput = document.getElementById('worldWidthInput');
        const worldHeightInput = document.getElementById('worldHeightInput');
        const resizeWorldButton = document.getElementById('resizeWorldButton');

        const worldWrapToggle = document.getElementById('worldWrapToggle');
        const maxTimestepSlider = document.getElementById('maxTimestep');
        const maxTimestepValueSpan = document.getElementById('maxTimestepValue');
        const zoomSensitivitySlider = document.getElementById('zoomSensitivitySlider');
        const zoomSensitivityValueSpan = document.getElementById('zoomSensitivityValueSpan');
        const pauseResumeButton = document.getElementById('pauseResumeButton');
        const toggleControlsButton = document.getElementById('toggleControlsButton');
        const screensaverButton = document.getElementById('screensaverButton');
        const controlsPanel = document.getElementById('controls');

        const creaturePopulationFloorSlider = document.getElementById('creaturePopulationFloorSlider');
        const creaturePopulationFloorValueSpan = document.getElementById('creaturePopulationFloorValueSpan');
        const creaturePopulationCeilingSlider = document.getElementById('creaturePopulationCeilingSlider');
        const creaturePopulationCeilingValueSpan = document.getElementById('creaturePopulationCeilingValueSpan');

        const bodyFluidEntrainmentSlider = document.getElementById('bodyFluidEntrainment');
        const fluidCurrentStrengthSlider = document.getElementById('fluidCurrentStrength');
        const bodyPushStrengthSlider = document.getElementById('bodyPushStrength');
        const reproductionCooldownSlider = document.getElementById('reproductionCooldown');
        const bodyRepulsionStrengthSlider = document.getElementById('bodyRepulsionStrength');
        const bodyRepulsionRadiusFactorSlider = document.getElementById('bodyRepulsionRadiusFactor');
        const globalMutationRateSlider = document.getElementById('globalMutationRate');
        const baseNodeCostSlider = document.getElementById('baseNodeCost');
        const emitterNodeCostSlider = document.getElementById('emitterNodeCost');
        const eaterNodeCostSlider = document.getElementById('eaterNodeCost');
        const predatorNodeCostSlider = document.getElementById('predatorNodeCost');
        const neuronNodeCostSlider = document.getElementById('neuronNodeCost');
        const instabilityLight = document.getElementById('instabilityLight');
        const populationCountDisplay = document.getElementById('populationCount');
        const resetButton = document.getElementById('resetButton');
        const bodyFluidEntrainmentValueSpan = document.getElementById('bodyFluidEntrainmentValue');
        const fluidCurrentStrengthValueSpan = document.getElementById('fluidCurrentStrengthValue');
        const bodyPushStrengthValueSpan = document.getElementById('bodyPushStrengthValue');
        const reproductionCooldownValueSpan = document.getElementById('reproductionCooldownValue');
        const bodyRepulsionStrengthValueSpan = document.getElementById('bodyRepulsionStrengthValue');
        const bodyRepulsionRadiusFactorValueSpan = document.getElementById('bodyRepulsionRadiusFactorValue');
        const globalMutationRateValueSpan = document.getElementById('globalMutationRateValue');
        const baseNodeCostValueSpan = document.getElementById('baseNodeCostValue');
        const emitterNodeCostValueSpan = document.getElementById('emitterNodeCostValue');
        const eaterNodeCostValueSpan = document.getElementById('eaterNodeCostValue');
        const predatorNodeCostValueSpan = document.getElementById('predatorNodeCostValue');
        const neuronNodeCostValueSpan = document.getElementById('neuronNodeCostValue');


        const fluidGridSizeSlider = document.getElementById('fluidGridSize');
        const fluidGridSizeValueSpan = document.getElementById('fluidGridSizeValue');
        const fluidDiffusionSlider = document.getElementById('fluidDiffusion');
        const fluidViscositySlider = document.getElementById('fluidViscosity');
        const fluidFadeSlider = document.getElementById('fluidFade');
        const clearFluidButton = document.getElementById('clearFluidButton');
        const fluidDiffusionValueSpan = document.getElementById('fluidDiffusionValue');
        const fluidViscosityValueSpan = document.getElementById('fluidViscosityValue');
        const fluidFadeValueSpan = document.getElementById('fluidFadeValue');
        const maxFluidVelocityComponentSlider = document.getElementById('maxFluidVelocityComponentSlider');
        const maxFluidVelocityComponentValueSpan = document.getElementById('maxFluidVelocityComponentValueSpan');


        const particlePopulationFloorSlider = document.getElementById('particlePopulationFloorSlider');
        const particlePopulationFloorValueSpan = document.getElementById('particlePopulationFloorValueSpan');
        const particlePopulationCeilingSlider = document.getElementById('particlePopulationCeilingSlider');
        const particlePopulationCeilingValueSpan = document.getElementById('particlePopulationCeilingValueSpan');
        const particlesPerSecondSlider = document.getElementById('particlesPerSecondSlider');
        const particlesPerSecondValueSpan = document.getElementById('particlesPerSecondValueSpan');
        const particleFluidInfluenceSlider = document.getElementById('particleFluidInfluence');
        const particleFluidInfluenceValueSpan = document.getElementById('particleFluidInfluenceValue');
        const particleLifeDecaySlider = document.getElementById('particleLifeDecay');
        const particleLifeDecayValueSpan = document.getElementById('particleLifeDecayValue');
        const infiniteParticleLifeToggle = document.getElementById('infiniteParticleLifeToggle');
        const particleLifeDecayLabel = document.getElementById('particleLifeDecayLabel');
        const resetParticlesButton = document.getElementById('resetParticlesButton');

        const exportConfigButton = document.getElementById('exportConfigButton');
        const importConfigFile = document.getElementById('importConfigFile');
        const importConfigButton = document.getElementById('importConfigButton');

        const emitterEditModeToggle = document.getElementById('emitterEditModeToggle');
        const emitterStrengthSlider = document.getElementById('emitterStrength');
        const emitterStrengthValueSpan = document.getElementById('emitterStrengthValue');
        const clearEmittersButton = document.getElementById('clearEmittersButton');

        const infoPanel = document.getElementById('infoPanel');
        const closeInfoPanelButton = document.getElementById('closeInfoPanel');
        // const neuronInfoSection = document.getElementById('neuronInfoSection'); // Removed as info merged
        const allPointsInfoContainer = document.getElementById('allPointsInfoContainer');


        // --- Global Variables (initialized with defaults, then overridden by JSON if loaded) ---
        let CREATURE_POPULATION_FLOOR = 10;
        let CREATURE_POPULATION_CEILING = 1000;
        let PARTICLE_POPULATION_FLOOR = 5000;
        let PARTICLE_POPULATION_CEILING = 20000;
        let canCreaturesReproduceGlobally = true;

        let BODY_FLUID_ENTRAINMENT_FACTOR = 0.465;
        let FLUID_CURRENT_STRENGTH_ON_BODY = 19.7;
        let SOFT_BODY_PUSH_STRENGTH = 0.10;
        let REPRODUCTION_COOLDOWN_TICKS = 1000;
        let BODY_REPULSION_STRENGTH = 100.0;
        let BODY_REPULSION_RADIUS_FACTOR = 5.0;
        let GLOBAL_MUTATION_RATE_MODIFIER = 0.25;
        let MAX_DELTA_TIME_MS = 10;
        // ZOOM_SENSITIVITY defined above where it's first used, will be set by JSON
        let IS_SIMULATION_PAUSED = false;
        let IS_EMITTER_EDIT_MODE = false;
        let EMITTER_STRENGTH = 3.0;

        let BASE_NODE_EXISTENCE_COST = 0.3;
        let EMITTER_NODE_ENERGY_COST = 1.0;
        let EATER_NODE_ENERGY_COST = 0.3;
        let PREDATOR_NODE_ENERGY_COST = 0.8;
        let NEURON_NODE_ENERGY_COST = 0.01;


        let FLUID_GRID_SIZE_CONTROL = 128;
        let FLUID_DIFFUSION = 0.00047;
        let FLUID_VISCOSITY = 0.000068;
        let FLUID_FADE_RATE = 0.002;
        let MAX_FLUID_VELOCITY_COMPONENT = 0.5;
        let IS_WORLD_WRAPPING = false;
        let PARTICLES_PER_SECOND = 500;
        let PARTICLE_FLUID_INFLUENCE = 2.0;
        let PARTICLE_BASE_LIFE_DECAY = 0.001;
        let IS_PARTICLE_LIFE_INFINITE = false;
        let particleEmissionDebt = 0;

        let INITIAL_POPULATION_SIZE;

        let velocityEmitters = [];
        let currentEmitterPreview = null;
        let emitterDragStartCell = null;
        let selectedInspectBody = null;
        let selectedInspectPoint = null;
        let selectedInspectPointIndex = -1;
        isRightDragging = false;
        lastPanMouseX = 0;
        lastPanMouseY = 0;


        const NodeType = {
            NEUTRAL: 0,
            FLOATING: 1,
            FIXED_ROOT: 2,
            EMITTER_SWIMMER: 3,
            NEURON: 4
        };
        const DyeChannel = {
            RED: 0,
            GREEN: 1,
            BLUE: 2,
            AVERAGE: 3
        };
        const DYE_COLORS = {
            RED: [200, 50, 50],
            GREEN: [50, 200, 50],
            BLUE: [50, 50, 200]
        };

        // --- Math Helper Functions (Added in Step 1) ---
        function sigmoid(x) { return 1 / (1 + Math.exp(-x)); }
        // Using Math.tanh directly where needed.

        function initializeMatrix(rows, cols, scale = 0.5) {
            const matrix = [];
            for (let i = 0; i < rows; i++) {
                matrix[i] = [];
                for (let j = 0; j < cols; j++) {
                    matrix[i][j] = (Math.random() * 2 - 1) * scale; // Small random weights
                }
            }
            return matrix;
        }

        function initializeVector(size, scale = 0.1) {
            const vector = [];
            for (let i = 0; i < size; i++) {
                vector[i] = (Math.random() * 2 - 1) * scale; // Small random biases
            }
            return vector;
        }

        function multiplyMatrixVector(matrix, vector) {
            const result = [];
            const numRows = matrix.length;
            if (numRows === 0) return result;
            const numCols = matrix[0].length;

            if (numCols !== vector.length) {
                console.error("Matrix-vector dimension mismatch:", matrix, vector, `Matrix cols: ${numCols}, Vector length: ${vector.length}`);
                const expectedOutputSize = numRows;
                for(let i=0; i<expectedOutputSize; i++) result.push(0);
                return result;
            }

            for (let i = 0; i < numRows; i++) {
                let sum = 0;
                for (let j = 0; j < numCols; j++) {
                    sum += matrix[i][j] * vector[j];
                }
                result.push(sum);
            }
            return result;
        }
        function addVectors(vecA, vecB) {
            if (vecA.length !== vecB.length) {
                console.error("Vector addition dimension mismatch:", vecA, vecB);
                return vecA;
            }
            return vecA.map((val, i) => val + vecB[i]);
        }
        // --- End Math Helper Functions ---

        // --- Vector2D Class ---
        class Vec2 {
            constructor(x = 0, y = 0) { this.x = x; this.y = y; }
            add(other) { return new Vec2(this.x + other.x, this.y + other.y); }
            sub(other) { return new Vec2(this.x - other.x, this.y - other.y); }
            mul(scalar) { return new Vec2(this.x * scalar, this.y * scalar); }
            div(scalar) { return scalar !== 0 ? new Vec2(this.x / scalar, this.y / scalar) : new Vec2(); }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            magSq() { return this.x * this.x + this.y * this.y; }
            normalize() { const m = this.mag(); return m > 0 ? this.div(m) : new Vec2(); }
            static dot(v1, v2) { return v1.x * v2.x + v1.y * v2.y; }
            clone() { return new Vec2(this.x, this.y); }
        }

        // --- MassPoint Class (Soft Body with Verlet Integration) ---
        class MassPoint {
            constructor(x, y, mass = 0.5, radius = 5, color = 'rgba(0,150,255,0.8)') {
                this.pos = new Vec2(x, y);
                this.prevPos = new Vec2(x, y);
                this.force = new Vec2();
                this.mass = mass;
                this.invMass = this.mass !== 0 ? 1 / this.mass : 0;
                this.radius = radius;
                this.color = color;
                this.isFixed = false;
                this.nodeType = NodeType.NEUTRAL;
                this.isEater = false;
                this.isPredator = false;
                this.emitsDye = false;
                this.dyeColor = [0,0,0];
                this.neuronData = null; // Initialize to null
            }
            applyForce(f) { this.force = this.force.add(f); }

            update(dt) {
                if (this.isFixed || this.invMass === 0 || this.nodeType === NodeType.FIXED_ROOT) {
                    this.force = new Vec2();
                    return;
                }

                const acceleration = this.force.mul(this.invMass);

                const tempX = this.pos.x;
                const tempY = this.pos.y;

                this.pos.x = 2 * this.pos.x - this.prevPos.x + acceleration.x * dt * dt;
                this.pos.y = 2 * this.pos.y - this.prevPos.y + acceleration.y * dt * dt;

                this.prevPos.x = tempX;
                this.prevPos.y = tempY;

                this.force = new Vec2();
            }

            draw(ctx) {
                // Draw interaction radii first (underneath the point)
                if (this.isEater) {
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius * EATING_RADIUS_MULTIPLIER, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 165, 0, 0.05)';
                    ctx.fill();
                }
                if (this.isPredator) {
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius * PREDATION_RADIUS_MULTIPLIER, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 50, 50, 0.05)';
                    ctx.fill();
                }


                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
                let mainColor = this.isFixed ? 'rgba(255,0,0,0.9)' : this.color;
                if (this.nodeType === NodeType.NEURON) {
                    mainColor = (this.neuronData && this.neuronData.isBrain) ? 'rgba(255, 215, 0, 0.95)' : 'rgba(200, 100, 255, 0.9)'; // Gold for brain
                } else if (this.isPredator) {
                    mainColor = 'rgba(255, 50, 50, 0.9)';
                } else if (this.nodeType === NodeType.EMITTER_SWIMMER && this.isEater) {
                     mainColor = 'rgba(200,255,0,0.9)';
                } else if (this.nodeType === NodeType.EMITTER_SWIMMER) {
                    mainColor = 'rgba(0,255,100,0.9)';
                } else if (this.isEater) {
                    mainColor = 'rgba(255,165,0,0.9)';
                } else if (this.nodeType === NodeType.FIXED_ROOT) {
                    mainColor = 'rgba(100, 70, 30, 0.9)';
                }
                ctx.fillStyle = mainColor;
                ctx.fill();

                ctx.save();
                ctx.shadowColor = mainColor;
                ctx.shadowBlur = 7;
                ctx.fill();
                ctx.restore();


                if (this.nodeType === NodeType.NEURON) {
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius * ( (this.neuronData && this.neuronData.isBrain) ? 0.65 : 0.5), 0, Math.PI * 2);
                    ctx.fillStyle = (this.neuronData && this.neuronData.isBrain) ? 'rgba(255, 255, 255, 1)' : 'rgba(250, 200, 255, 0.9)';
                    ctx.fill();
                }
            }
        }
        // --- End MassPoint Class ---


        // --- Spring Class (Soft Body) ---
        class Spring {
            constructor(p1, p2, stiffness, dampingFactor, restLength = null) {
                this.p1 = p1; this.p2 = p2;
                this.stiffness = stiffness;
                this.dampingFactor = dampingFactor;
                this.restLength = restLength === null ? p1.pos.sub(p2.pos).mag() : restLength;
            }
            applyForce() {
                const diffPos = this.p1.pos.sub(this.p2.pos);
                const currentLength = diffPos.mag();
                if (currentLength === 0) return;
                const displacement = currentLength - this.restLength;
                const direction = diffPos.normalize();

                const springForceMagnitude = -this.stiffness * displacement;
                const springForce = direction.mul(springForceMagnitude);

                const p1_vel_implicit = this.p1.pos.sub(this.p1.prevPos);
                const p2_vel_implicit = this.p2.pos.sub(this.p2.prevPos);
                const relVel_implicit = p1_vel_implicit.sub(p2_vel_implicit);

                const velAlongSpring = Vec2.dot(relVel_implicit, direction);
                const dampingForceMagnitude = -this.dampingFactor * velAlongSpring;
                const dampingForce = direction.mul(dampingForceMagnitude);

                const totalForce = springForce.add(dampingForce);
                this.p1.applyForce(totalForce);
                this.p2.applyForce(totalForce.mul(-1));
            }
            draw(ctx) {
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.beginPath();
                ctx.moveTo(this.p1.pos.x, this.p1.pos.y);
                ctx.lineTo(this.p2.pos.x, this.p2.pos.y);
                ctx.strokeStyle = 'rgba(150,150,150,0.6)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // --- SoftBody Class ---
        class SoftBody {
            constructor(id, initialX, initialY, parentBody = null) {
                this.id = id;
                this.massPoints = [];
                this.springs = [];
                this.isUnstable = false;
                this.creatureEnergy = MAX_CREATURE_ENERGY * OFFSPRING_INITIAL_ENERGY_SHARE;
                this.ticksSinceBirth = 0;
                this.canReproduce = false;
                this.shapeType = parentBody ? parentBody.shapeType : Math.floor(Math.random() * 3);

                this.motorImpulseInterval = 30 + Math.floor(Math.random() * 90);
                this.motorImpulseMagnitudeCap = 0.5 + Math.random() * 2.0;
                // Emitter strength/direction are now neurally controlled if a brain exists

                this.numOffspring = parentBody ? parentBody.numOffspring : (1 + Math.floor(Math.random() * 3));
                this.offspringSpawnRadius = parentBody ? parentBody.offspringSpawnRadius : (50 + Math.random() * 50);
                this.pointAddChance = parentBody ? parentBody.pointAddChance : (ADD_POINT_MUTATION_CHANCE);
                this.springConnectionRadius = parentBody ? parentBody.springConnectionRadius : (40 + Math.random() * 40);


                if (parentBody) {
                    this.stiffness = parentBody.stiffness * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER));
                    this.springDamping = parentBody.springDamping * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER));
                    this.motorImpulseInterval = Math.max(10, Math.floor(parentBody.motorImpulseInterval * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER))));
                    this.motorImpulseMagnitudeCap = parentBody.motorImpulseMagnitudeCap * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER));
                    // Emitter strength/direction inherited via neuronData if parent had a brain, or re-initialized

                    let offspringNumChange = 0;
                    if (Math.random() < Math.max(0, Math.min(1, MUTATION_CHANCE_BOOL * GLOBAL_MUTATION_RATE_MODIFIER))) {
                        offspringNumChange = (Math.random() < 0.5 ? -1 : 1);
                    }
                    this.numOffspring = Math.max(1, Math.min(5, Math.floor(parentBody.numOffspring + offspringNumChange)));

                    this.offspringSpawnRadius = Math.max(20, parentBody.offspringSpawnRadius * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER * 0.5)));
                    this.pointAddChance = Math.max(0, Math.min(0.5, parentBody.pointAddChance * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER * 2))));
                    this.springConnectionRadius = Math.max(10, parentBody.springConnectionRadius * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER)));

                } else { // Initial generation
                    this.stiffness = 500 + Math.random() * 2500;
                    this.springDamping = 5 + Math.random() * 20;
                }
                // Clamp inherited/randomized values
                this.stiffness = Math.max(100, Math.min(this.stiffness, 10000));
                this.springDamping = Math.max(0.1, Math.min(this.springDamping, 50));
                this.motorImpulseMagnitudeCap = Math.max(0, Math.min(this.motorImpulseMagnitudeCap, 5.0));
                this.motorImpulseInterval = Math.max(10, Math.min(this.motorImpulseInterval, 300));
                this.numOffspring = Math.max(1, Math.min(this.numOffspring, 5));
                this.offspringSpawnRadius = Math.max(20, Math.min(this.offspringSpawnRadius, 150));
                this.pointAddChance = Math.max(0, Math.min(0.5, this.pointAddChance));
                this.springConnectionRadius = Math.max(10, Math.min(this.springConnectionRadius, 100));

                this.fluidEntrainment = BODY_FLUID_ENTRAINMENT_FACTOR;
                this.fluidCurrentStrength = FLUID_CURRENT_STRENGTH_ON_BODY;
                this.bodyPushStrength = SOFT_BODY_PUSH_STRENGTH;

                this.createShape(initialX, initialY, parentBody); // Creates massPoints
                this.initializeBrain(); // Sets up the neural network for the active brain node
            }

            initializeBrain() {
                let brainNode = null;
                let brainNodeIndex = -1;

                for (let i = 0; i < this.massPoints.length; i++) {
                    if (this.massPoints[i].nodeType === NodeType.NEURON) {
                        if (!brainNode) {
                            brainNode = this.massPoints[i];
                            brainNodeIndex = i;
                            if (!brainNode.neuronData) brainNode.neuronData = {};
                            brainNode.neuronData.isBrain = true;
                        } else {
                            if (this.massPoints[i].neuronData) this.massPoints[i].neuronData.isBrain = false;
                            else this.massPoints[i].neuronData = { isBrain: false };
                        }
                    }
                }

                if (brainNode) {
                    const nd = brainNode.neuronData;
                    nd.inputVectorSize = NEURAL_INPUT_SIZE;
                    const numEmitterSwimmers = this.massPoints.filter(mp => mp.nodeType === NodeType.EMITTER_SWIMMER).length;
                    nd.outputVectorSize = numEmitterSwimmers * NEURAL_OUTPUTS_PER_EMITTER_SWIMMER;

                    if (typeof nd.hiddenLayerSize !== 'number' || nd.hiddenLayerSize <= 0) {
                         nd.hiddenLayerSize = Math.floor(DEFAULT_HIDDEN_LAYER_SIZE_MIN + Math.random() * (DEFAULT_HIDDEN_LAYER_SIZE_MAX - DEFAULT_HIDDEN_LAYER_SIZE_MIN + 1));
                    }
                    nd.hiddenLayerSize = Math.max(1, Math.min(Math.round(nd.hiddenLayerSize), DEFAULT_HIDDEN_LAYER_SIZE_MAX * 2));


                    let needsWeightReinit = false;
                    if (!nd.weightsIH || !nd.biasesH || !nd.weightsHO || !nd.biasesO) {
                        needsWeightReinit = true;
                    } else {
                        if (nd.weightsIH.length !== nd.hiddenLayerSize || (nd.weightsIH[0] && nd.weightsIH[0].length !== nd.inputVectorSize)) needsWeightReinit = true;
                        if (nd.biasesH.length !== nd.hiddenLayerSize) needsWeightReinit = true;
                        if (nd.weightsHO.length !== nd.outputVectorSize || (nd.weightsHO[0] && nd.weightsHO[0].length !== nd.hiddenLayerSize)) needsWeightReinit = true;
                        if (nd.biasesO.length !== nd.outputVectorSize) needsWeightReinit = true;
                    }


                    if (needsWeightReinit && nd.outputVectorSize > 0 && nd.hiddenLayerSize > 0 && nd.inputVectorSize > 0) {
                        nd.weightsIH = initializeMatrix(nd.hiddenLayerSize, nd.inputVectorSize);
                        nd.biasesH = initializeVector(nd.hiddenLayerSize);
                        nd.weightsHO = initializeMatrix(nd.outputVectorSize, nd.hiddenLayerSize);
                        nd.biasesO = initializeVector(nd.outputVectorSize);
                    } else if (nd.outputVectorSize === 0 || nd.hiddenLayerSize === 0 || nd.inputVectorSize === 0) {
                        nd.weightsIH = []; nd.biasesH = []; nd.weightsHO = []; nd.biasesO = [];
                    }
                }
            }


            createShape(startX, startY, parentBody = null) {
                this.massPoints = [];
                this.springs = [];

                const baseRadius = 3 + Math.random() * 3;
                const eaterChance = 0.25;
                const predatorChance = 0.15;
                const dyeEmitterChance = 0.2;
                const nodeTypeChoices = [NodeType.NEUTRAL, NodeType.FLOATING, NodeType.FIXED_ROOT, NodeType.EMITTER_SWIMMER, NodeType.NEURON];
                const dyeColorChoices = [DYE_COLORS.RED, DYE_COLORS.GREEN, DYE_COLORS.BLUE];

                if (parentBody) {
                    const parentBrainNode = parentBody.massPoints.find(p => p.neuronData && p.neuronData.isBrain);
                    let parentBrainHiddenSize = parentBrainNode ? parentBrainNode.neuronData.hiddenLayerSize : null;

                    parentBody.massPoints.forEach(parentPoint => {
                        let mass = parentPoint.mass * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER));
                        mass = Math.max(0.1, Math.min(mass, 1.0));
                        let nodeType = parentPoint.nodeType;
                        if (Math.random() < (MUTATION_CHANCE_NODE_TYPE * GLOBAL_MUTATION_RATE_MODIFIER)) {
                            nodeType = nodeTypeChoices[Math.floor(Math.random() * nodeTypeChoices.length)];
                        }

                        const offspringPoint = new MassPoint(
                            parentPoint.pos.x + (Math.random() - 0.5) * 5,
                            parentPoint.pos.y + (Math.random() - 0.5) * 5,
                            mass,
                            parentPoint.radius * (1 + (Math.random() - 0.5) * 0.2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER))
                        );
                        offspringPoint.nodeType = nodeType;
                        offspringPoint.isEater = Math.random() < (MUTATION_CHANCE_BOOL * GLOBAL_MUTATION_RATE_MODIFIER) ? !parentPoint.isEater : parentPoint.isEater;
                        offspringPoint.isPredator = Math.random() < (MUTATION_CHANCE_BOOL * GLOBAL_MUTATION_RATE_MODIFIER) ? !parentPoint.isPredator : parentPoint.isPredator;
                        offspringPoint.emitsDye = Math.random() < (MUTATION_CHANCE_BOOL * GLOBAL_MUTATION_RATE_MODIFIER) ? !parentPoint.emitsDye : parentPoint.emitsDye;
                        offspringPoint.dyeColor = Math.random() < (MUTATION_CHANCE_BOOL * GLOBAL_MUTATION_RATE_MODIFIER) ? dyeColorChoices[Math.floor(Math.random() * dyeColorChoices.length)] : [...parentPoint.dyeColor];

                        if (nodeType === NodeType.NEURON) {
                            let inheritedHiddenSize = DEFAULT_HIDDEN_LAYER_SIZE_MIN + Math.random() * (DEFAULT_HIDDEN_LAYER_SIZE_MAX - DEFAULT_HIDDEN_LAYER_SIZE_MIN);
                            if (parentPoint.neuronData && parentPoint.neuronData.hiddenLayerSize) { // If parent point was a neuron
                                inheritedHiddenSize = parentPoint.neuronData.hiddenLayerSize;
                                if (parentPoint === parentBrainNode) { // And it was the brain
                                     inheritedHiddenSize = inheritedHiddenSize * (1 + (Math.random() - 0.5) * 0.2 * GLOBAL_MUTATION_RATE_MODIFIER); // Mutate
                                }
                            }
                            offspringPoint.neuronData = {
                                isBrain: false, // Will be set by initializeBrain
                                hiddenLayerSize: Math.max(DEFAULT_HIDDEN_LAYER_SIZE_MIN, Math.min(Math.round(inheritedHiddenSize), DEFAULT_HIDDEN_LAYER_SIZE_MAX * 2))
                            };
                        }
                        if(offspringPoint.nodeType === NodeType.FIXED_ROOT) offspringPoint.isFixed = true;
                        this.massPoints.push(offspringPoint);

                        if (Math.random() < this.pointAddChance) {
                            const lastPointPos = this.massPoints[this.massPoints.length-1].pos.clone();
                            const newMass = 0.1 + Math.random() * 0.9;
                            const newNodeType = nodeTypeChoices[Math.floor(Math.random() * nodeTypeChoices.length)];
                            const newPoint = new MassPoint(
                                lastPointPos.x + (Math.random() - 0.5) * NEW_POINT_OFFSET_RADIUS * 2,
                                lastPointPos.y + (Math.random() - 0.5) * NEW_POINT_OFFSET_RADIUS * 2,
                                newMass, baseRadius * (0.8 + Math.random() * 0.4)
                            );
                            newPoint.nodeType = newNodeType;
                            newPoint.isEater = Math.random() < eaterChance;
                            newPoint.isPredator = Math.random() < predatorChance;
                            newPoint.emitsDye = Math.random() < dyeEmitterChance;
                            newPoint.dyeColor = dyeColorChoices[Math.floor(Math.random() * dyeColorChoices.length)];
                            if (newNodeType === NodeType.NEURON) {
                                newPoint.neuronData = { isBrain: false, hiddenLayerSize: Math.floor(DEFAULT_HIDDEN_LAYER_SIZE_MIN + Math.random() * (DEFAULT_HIDDEN_LAYER_SIZE_MAX - DEFAULT_HIDDEN_LAYER_SIZE_MIN + 1)) };
                            }
                            if(newPoint.nodeType === NodeType.FIXED_ROOT) newPoint.isFixed = true;
                            this.massPoints.push(newPoint);
                        }
                    });
                     if (this.massPoints.length === 0) { // Fallback if parent had no points
                        this.massPoints.push(new MassPoint(startX, startY, 0.5, baseRadius));
                         if (Math.random() < NEURON_CHANCE) { this.massPoints[0].nodeType = NodeType.NEURON; this.massPoints[0].neuronData = {isBrain: false, hiddenLayerSize: Math.floor(DEFAULT_HIDDEN_LAYER_SIZE_MIN + Math.random() * (DEFAULT_HIDDEN_LAYER_SIZE_MAX - DEFAULT_HIDDEN_LAYER_SIZE_MIN + 1)) }; }
                    }

                } else { // Initial generation logic
                    const basePointDist = 20 + Math.random() * 10;
                    // Simplified initial generation for brevity - actual logic from previous version should be here
                    const numPoints = Math.floor(3 + Math.random() * 4);
                    for(let i=0; i<numPoints; i++){
                        const p = new MassPoint(startX + (Math.random()-0.5)*numPoints*5, startY + (Math.random()-0.5)*numPoints*5, 0.3+Math.random()*0.4, baseRadius);
                        p.isEater = Math.random() < eaterChance; p.isPredator = Math.random() < predatorChance; p.emitsDye = Math.random() < dyeEmitterChance; p.dyeColor = dyeColorChoices[Math.floor(Math.random() * dyeColorChoices.length)];
                        if (Math.random() < NEURON_CHANCE && numPoints > 1) {
                            p.nodeType = NodeType.NEURON;
                            p.neuronData = { isBrain: false, hiddenLayerSize: Math.floor(DEFAULT_HIDDEN_LAYER_SIZE_MIN + Math.random() * (DEFAULT_HIDDEN_LAYER_SIZE_MAX - DEFAULT_HIDDEN_LAYER_SIZE_MIN + 1)) };
                        } else if(Math.random() < 0.3) {
                            p.nodeType = NodeType.EMITTER_SWIMMER;
                        }
                        if (p.nodeType === NodeType.FIXED_ROOT) p.isFixed = true;
                        this.massPoints.push(p);
                    }
                }

                // Common spring creation logic
                if (this.massPoints.length > 1) {
                    for (let i = 0; i < this.massPoints.length; i++) {
                        for (let j = i + 1; j < this.massPoints.length; j++) {
                            const p1 = this.massPoints[i];
                            const p2 = this.massPoints[j];
                            const dist = p1.pos.sub(p2.pos).mag();
                            if (dist < this.springConnectionRadius && dist > 0.1) {
                                this.springs.push(new Spring(p1, p2, this.stiffness, this.springDamping, dist));
                            }
                        }
                    }
                    if (this.springs.length === 0 && this.massPoints.length > 1 && this.massPoints.length <= 3) {
                        for(let i=0; i < this.massPoints.length-1; i++){
                           this.springs.push(new Spring(this.massPoints[i], this.massPoints[i+1], this.stiffness, this.springDamping));
                        }
                        if(this.massPoints.length === 3) this.springs.push(new Spring(this.massPoints[0], this.massPoints[2], this.stiffness, this.springDamping));
                    }
                }
            }

            getAveragePosition() { /* ... (same as your provided code) ... */ }
            getAverageVelocity() { /* ... (same as your provided code) ... */ }


            updateSelf(dt, fluidFieldRef) {
                if (this.isUnstable) return;

                // Clear old simple neuron processing (sensorPointIndex, effectorPointIndex, neuralEffectiveStrength)
                // The new brain logic will replace this.

                const brainNode = this.massPoints.find(p => p.neuronData && p.neuronData.isBrain);

                if (brainNode && brainNode.neuronData && brainNode.neuronData.weightsIH && brainNode.neuronData.hiddenLayerSize > 0 && brainNode.neuronData.outputVectorSize > 0) {
                    // Neural Network Control will be implemented in Step 4 & 5
                } else { // Fallback for non-brained creatures or inoperable brains
                    if (this.motorImpulseMagnitudeCap > 0.0001 && (this.ticksSinceBirth % this.motorImpulseInterval === 0)) {
                        for (let point of this.massPoints) {
                            if (!point.isFixed && point.nodeType !== NodeType.FIXED_ROOT) {
                                const randomAngle = Math.random() * Math.PI * 2;
                                const impulseDir = new Vec2(Math.cos(randomAngle), Math.sin(randomAngle));
                                const impulseMag = Math.random() * this.motorImpulseMagnitudeCap;
                                const impulseForce = impulseDir.mul(impulseMag / dt);
                                point.applyForce(impulseForce);
                            }
                        }
                    }
                    this.massPoints.forEach(point => {
                        if (point.nodeType === NodeType.EMITTER_SWIMMER && point.emitsDye && fluidFieldRef) {
                            const emitterFluidGx = Math.floor(point.pos.x / fluidFieldRef.scaleX);
                            const emitterFluidGy = Math.floor(point.pos.y / fluidFieldRef.scaleY);
                            fluidFieldRef.addDensity(emitterFluidGx, emitterFluidGy, point.dyeColor[0], point.dyeColor[1], point.dyeColor[2], 50);
                        }
                    });
                }


                // Calculate and apply energy cost
                let currentFrameEnergyCost = 0;
                for (const point of this.massPoints) {
                    currentFrameEnergyCost += BASE_NODE_EXISTENCE_COST;
                    if (point.nodeType === NodeType.EMITTER_SWIMMER) {
                        currentFrameEnergyCost += EMITTER_NODE_ENERGY_COST;
                    }
                    if (point.nodeType === NodeType.NEURON) {
                        currentFrameEnergyCost += NEURON_NODE_ENERGY_COST * ( (point.neuronData && point.neuronData.isBrain && point.neuronData.hiddenLayerSize) ? point.neuronData.hiddenLayerSize * 0.1 : 1.0);
                    }
                    if (point.isEater) { currentFrameEnergyCost += EATER_NODE_ENERGY_COST; }
                    if (point.isPredator) { currentFrameEnergyCost += PREDATOR_NODE_ENERGY_COST; }
                }
                this.creatureEnergy -= currentFrameEnergyCost * dt;

                this.ticksSinceBirth++;
                if (this.ticksSinceBirth > REPRODUCTION_COOLDOWN_TICKS) {
                    this.canReproduce = true;
                }

                if (this.creatureEnergy <= 0) {
                    this.isUnstable = true; return;
                }

                // Fluid interaction for FLOATING nodes (not directly brain controlled force-wise)
                if (fluidFieldRef) {
                    for (let point of this.massPoints) {
                        if (point.isFixed || point.nodeType === NodeType.FIXED_ROOT) continue;
                        if (point.nodeType === NodeType.FLOATING) {
                            const fluidGridX = Math.floor(point.pos.x / fluidFieldRef.scaleX);
                            const fluidGridY = Math.floor(point.pos.y / fluidFieldRef.scaleY);
                            const idx = fluidFieldRef.IX(fluidGridX, fluidGridY);
                            const rawFluidVx = fluidFieldRef.Vx[idx];
                            const rawFluidVy = fluidFieldRef.Vy[idx];
                            let fluidDisplacementPx = new Vec2(rawFluidVx * fluidFieldRef.scaleX * dt, rawFluidVy * fluidFieldRef.scaleY * dt);
                            let effectiveFluidDisplacementPx = fluidDisplacementPx.mul(this.fluidCurrentStrength);
                            let currentPointDisplacementPx = point.pos.sub(point.prevPos);
                            let blendedDisplacementPx = currentPointDisplacementPx.mul(1.0 - this.fluidEntrainment)
                                                             .add(effectiveFluidDisplacementPx.mul(this.fluidEntrainment));
                            point.prevPos = point.pos.clone().sub(blendedDisplacementPx);
                        }
                    }
                }


                for (let spring of this.springs) spring.applyForce();
                for (let i_p1 = 0; i_p1 < this.massPoints.length; i_p1++) { /* ... Inter-body repulsion (unchanged) ... */ }

                for (let point of this.massPoints) point.update(dt);

                // Instability Checks
                const MAX_PIXELS_PER_FRAME_DISPLACEMENT_SQ = (MAX_PIXELS_PER_FRAME_DISPLACEMENT)**2;
                const localMaxSpringStretchFactor = MAX_SPRING_STRETCH_FACTOR;
                const localMaxSpanPerPointFactor = MAX_SPAN_PER_POINT_FACTOR;

                for (let point of this.massPoints) {
                    const displacementSq = (point.pos.x - point.prevPos.x)**2 + (point.pos.y - point.prevPos.y)**2;
                    if (displacementSq > MAX_PIXELS_PER_FRAME_DISPLACEMENT_SQ ||
                        isNaN(point.pos.x) || isNaN(point.pos.y) ||
                        !isFinite(point.pos.x) || !isFinite(point.pos.y)) {
                        this.isUnstable = true;
                        console.warn(`Soft body ID ${this.id} point instability (displacement/NaN/Infinite)!`, point);
                        break;
                    }
                }
                if (this.isUnstable) return;

                for (const spring of this.springs) {
                    const currentLength = spring.p1.pos.sub(spring.p2.pos).mag();
                    if (currentLength > spring.restLength * localMaxSpringStretchFactor) {
                        this.isUnstable = true;
                        console.warn(`Soft body ID ${this.id} spring instability (over-stretched)! Spring rest: ${spring.restLength.toFixed(1)}, current: ${currentLength.toFixed(1)}`);
                        break;
                    }
                }
                if (this.isUnstable) return;

                if (this.massPoints.length > 2) {
                    const bbox = this.getBoundingBox();
                    if (bbox.width > this.massPoints.length * localMaxSpanPerPointFactor ||
                        bbox.height > this.massPoints.length * localMaxSpanPerPointFactor) {
                        this.isUnstable = true;
                        console.warn(`Soft body ID ${this.id} span instability! Width: ${bbox.width.toFixed(1)}, Height: ${bbox.height.toFixed(1)}, Points: ${this.massPoints.length}`);
                    }
                }
                if (this.isUnstable) return;


                if (!this.isUnstable) {
                    for (let point of this.massPoints) { /* ... Eating logic (unchanged) ... */ }
                }


                if (!this.isUnstable) {
                    for (let point of this.massPoints) { /* ... Boundary conditions (unchanged) ... */ }
                }
            } // End updateSelf


            reproduce() { /* ... (Should mostly work, ensure neuronData inheritance is handled for hiddenLayerSize) ... */ }
            getBoundingBox() { /* ... (same as your provided code) ... */ }
            // getAveragePosition() and getAverageVelocity() are above or in your provided code

            drawSelf(ctx) {
                if (this.isUnstable) return;
                for (let spring of this.springs) spring.draw(ctx);
                for (let point of this.massPoints) point.draw(ctx);
            }
        }
        // --- End SoftBody Class ---

        // --- FluidField Class (Simplified) ---
        class FluidField {
            constructor(size, diffusion, viscosity, dt, scaleX, scaleY) { // Added scaleX, scaleY
                this.size = Math.round(size); // Ensure integer
                this.dt = dt;
                this.diffusion = diffusion;
                this.viscosity = viscosity;
                this.scaleX = scaleX; // Store separate scales
                this.scaleY = scaleY;
                this.useWrapping = false;
                this.maxVelComponent = MAX_FLUID_VELOCITY_COMPONENT; // New

                this.densityR = new Float32Array(this.size * this.size).fill(0);
                this.densityG = new Float32Array(this.size * this.size).fill(0);
                this.densityB = new Float32Array(this.size * this.size).fill(0);
                this.densityR0 = new Float32Array(this.size * this.size).fill(0);
                this.densityG0 = new Float32Array(this.size * this.size).fill(0);
                this.densityB0 = new Float32Array(this.size * this.size).fill(0);

                this.Vx = new Float32Array(this.size * this.size).fill(0);
                this.Vy = new Float32Array(this.size * this.size).fill(0);
                this.Vx0 = new Float32Array(this.size * this.size).fill(0);
                this.Vy0 = new Float32Array(this.size * this.size).fill(0);

                this.iterations = 4;
            }

            IX(x, y) {
                if (this.useWrapping) {
                    x = (Math.floor(x) % this.size + this.size) % this.size;
                    y = (Math.floor(y) % this.size + this.size) % this.size;
                } else {
                    x = Math.max(0, Math.min(x, this.size - 1));
                    y = Math.max(0, Math.min(y, this.size - 1));
                }
                return Math.floor(x) + Math.floor(y) * this.size;
            }

            addDensity(x, y, emitterR, emitterG, emitterB, emissionStrength) {
                const idx = this.IX(x, y);
                const normalizedEmissionEffect = (emissionStrength / 50.0) * DYE_PULL_RATE; // Use 50 as a reference emission strength

                let currentR = this.densityR[idx];
                let targetDiffR = emitterR - currentR;
                this.densityR[idx] += targetDiffR * normalizedEmissionEffect;
                this.densityR[idx] = Math.max(0, Math.min(255, this.densityR[idx]));

                let currentG = this.densityG[idx];
                let targetDiffG = emitterG - currentG;
                this.densityG[idx] += targetDiffG * normalizedEmissionEffect;
                this.densityG[idx] = Math.max(0, Math.min(255, this.densityG[idx]));

                let currentB = this.densityB[idx];
                let targetDiffB = emitterB - currentB;
                this.densityB[idx] += targetDiffB * normalizedEmissionEffect;
                this.densityB[idx] = Math.max(0, Math.min(255, this.densityB[idx]));
            }


            addVelocity(x, y, amountX, amountY) {
                const idx = this.IX(x, y);
                let newVx = this.Vx[idx] + amountX;
                let newVy = this.Vy[idx] + amountY;

                // Cap individual components
                this.Vx[idx] = Math.max(-this.maxVelComponent, Math.min(newVx, this.maxVelComponent));
                this.Vy[idx] = Math.max(-this.maxVelComponent, Math.min(newVy, this.maxVelComponent));
            }

            clampVelocityComponents(arr) {
                for(let i=0; i < arr.length; i++) {
                    arr[i] = Math.max(-this.maxVelComponent, Math.min(arr[i], this.maxVelComponent));
                }
            }


            lin_solve(b, x, x0, a, c) {
                const cRecip = 1.0 / c;
                for (let k = 0; k < this.iterations; k++) {
                    for (let j = 1; j < this.size - 1; j++) {
                        for (let i = 1; i < this.size - 1; i++) {
                             const idx = this.IX(i,j);
                            x[idx] =
                                (x0[idx] +
                                a * ( x[this.IX(i+1,j)] + x[this.IX(i-1,j)] +
                                      x[this.IX(i,j+1)] + x[this.IX(i,j-1)]
                                    )) * cRecip;
                        }
                    }
                    this.set_bnd(b, x);
                }
            }

            diffuse(b, x_out, x_in, diff_rate, dt) {
                const a = dt * diff_rate * (this.size - 2) * (this.size - 2);
                this.lin_solve(b, x_out, x_in, a, 1 + 4 * a);
            }

            project(velocX_in_out, velocY_in_out, p_temp, div_temp) {
                for (let j = 1; j < this.size - 1; j++) {
                    for (let i = 1; i < this.size - 1; i++) {
                        const idx = this.IX(i,j);
                        div_temp[idx] = -0.5 * (
                            velocX_in_out[this.IX(i+1,j)] - velocX_in_out[this.IX(i-1,j)] +
                            velocY_in_out[this.IX(i,j+1)] - velocY_in_out[this.IX(i,j-1)]
                        ) / this.size; // Using this.size here assumes square cells for divergence calculation
                        p_temp[idx] = 0;
                    }
                }
                this.set_bnd(0, div_temp);
                this.set_bnd(0, p_temp);
                this.lin_solve(0, p_temp, div_temp, 1, 4);

                for (let j = 1; j < this.size - 1; j++) {
                    for (let i = 1; i < this.size - 1; i++) {
                        const idx = this.IX(i,j);
                        velocX_in_out[idx] -= 0.5 * (p_temp[this.IX(i+1,j)] - p_temp[this.IX(i-1,j)]) * this.size;
                        velocY_in_out[idx] -= 0.5 * (p_temp[this.IX(i,j+1)] - p_temp[this.IX(i,j-1)]) * this.size;
                    }
                }
                this.set_bnd(1, velocX_in_out);
                this.set_bnd(2, velocY_in_out);
            }

            advect(b, d_out, d_in, velocX_source, velocY_source, dt) {
                let i0, i1, j0, j1;
                const dtx = dt * (this.size - 2);
                const dty = dt * (this.size - 2);
                let s0, s1, t0, t1;
                let tmp1, tmp2, x, y;

                const N = this.size;

                for (let j_cell = 1; j_cell < N - 1; j_cell++) {
                    for (let i_cell = 1; i_cell < N - 1; i_cell++) {
                        const current_idx = this.IX(i_cell, j_cell);

                        tmp1 = dtx * velocX_source[current_idx];
                        tmp2 = dty * velocY_source[current_idx];
                        x = i_cell - tmp1;
                        y = j_cell - tmp2;

                        if (this.useWrapping) {
                            x = (x % N + N) % N;
                            y = (y % N + N) % N;
                            i0 = Math.floor(x);
                            j0 = Math.floor(y);
                            i1 = (i0 + 1) % N;
                            j1 = (j0 + 1) % N;
                        } else {
                            if (x < 0.5) x = 0.5;
                            if (x > N - 1.5) x = N - 1.5;
                            i0 = Math.floor(x);
                            i1 = i0 + 1.0;

                            if (y < 0.5) y = 0.5;
                            if (y > N - 1.5) y = N - 1.5;
                            j0 = Math.floor(y);
                            j1 = j0 + 1.0;
                        }

                        s1 = x - i0;
                        if (this.useWrapping && i1 === 0 && i0 === N - 1) s0 = 1.0 - s1 + 1; else s0 = 1.0 - s1;

                        t1 = y - j0;
                        if (this.useWrapping && j1 === 0 && j0 === N - 1) t0 = 1.0 - t1 + 1; else t0 = 1.0 - t1;

                        d_out[current_idx] = s0 * (t0 * d_in[this.IX(i0,j0)] + t1 * d_in[this.IX(i0,j1)]) +
                                             s1 * (t0 * d_in[this.IX(i1,j0)] + t1 * d_in[this.IX(i1,j1)]);
                    }
                }
                this.set_bnd(b, d_out);
            }

            set_bnd(b, x_arr) {
                if (this.useWrapping) {
                    for (let i = 1; i < this.size - 1; i++) {
                        x_arr[this.IX(i, 0)] = x_arr[this.IX(i, this.size - 2)];
                        x_arr[this.IX(i, this.size - 1)] = x_arr[this.IX(i, 1)];
                    }
                    for (let j = 1; j < this.size - 1; j++) {
                        x_arr[this.IX(0, j)] = x_arr[this.IX(this.size - 2, j)];
                        x_arr[this.IX(this.size - 1, j)] = x_arr[this.IX(1, j)];
                    }
                    x_arr[this.IX(0, 0)] = x_arr[this.IX(this.size - 2, this.size - 2)];
                    x_arr[this.IX(0, this.size - 1)] = x_arr[this.IX(this.size - 2, 1)];
                    x_arr[this.IX(this.size - 1, 0)] = x_arr[this.IX(1, this.size - 2)];
                    x_arr[this.IX(this.size - 1, this.size - 1)] = x_arr[this.IX(1, 1)];

                } else {
                    for (let i = 1; i < this.size - 1; i++) {
                        x_arr[this.IX(i, 0)] = b === 2 ? -x_arr[this.IX(i, 1)] : x_arr[this.IX(i, 1)];
                        x_arr[this.IX(i, this.size - 1)] = b === 2 ? -x_arr[this.IX(i, this.size - 2)] : x_arr[this.IX(i, this.size - 2)];
                    }
                    for (let j = 1; j < this.size - 1; j++) {
                        x_arr[this.IX(0, j)] = b === 1 ? -x_arr[this.IX(1, j)] : x_arr[this.IX(1, j)];
                        x_arr[this.IX(this.size - 1, j)] = b === 1 ? -x_arr[this.IX(this.size - 2, j)] : x_arr[this.IX(this.size - 2, j)];
                    }
                    x_arr[this.IX(0, 0)] = 0.5 * (x_arr[this.IX(1, 0)] + x_arr[this.IX(0, 1)]);
                    x_arr[this.IX(0, this.size - 1)] = 0.5 * (x_arr[this.IX(1, this.size - 1)] + x_arr[this.IX(0, this.size - 2)]);
                    x_arr[this.IX(this.size - 1, 0)] = 0.5 * (x_arr[this.IX(this.size - 2, 0)] + x_arr[this.IX(this.size - 1, 1)]);
                    x_arr[this.IX(this.size - 1, this.size - 1)] = 0.5 * (x_arr[this.IX(this.size - 2, this.size - 1)] + x_arr[this.IX(this.size - 1, this.size - 2)]);
                }
            }

            step() {
                this.diffuse(1, this.Vx0, this.Vx, this.viscosity, this.dt);
                this.diffuse(2, this.Vy0, this.Vy, this.viscosity, this.dt);
                this.clampVelocityComponents(this.Vx0); // Clamp after diffusion
                this.clampVelocityComponents(this.Vy0);

                this.project(this.Vx0, this.Vy0, this.Vx, this.Vy); // Vx, Vy are temp here

                this.advect(1, this.Vx, this.Vx0, this.Vx0, this.Vy0, this.dt);
                this.advect(2, this.Vy, this.Vy0, this.Vx0, this.Vy0, this.dt);
                this.clampVelocityComponents(this.Vx); // Clamp after advection
                this.clampVelocityComponents(this.Vy);

                this.project(this.Vx, this.Vy, this.Vx0, this.Vy0); // Vx0, Vy0 are temp here

                this.diffuse(0, this.densityR0, this.densityR, this.diffusion, this.dt);
                this.diffuse(0, this.densityG0, this.densityG, this.diffusion, this.dt);
                this.diffuse(0, this.densityB0, this.densityB, this.diffusion, this.dt);
                this.advect(0, this.densityR, this.densityR0, this.Vx, this.Vy, this.dt);
                this.advect(0, this.densityG, this.densityG0, this.Vx, this.Vy, this.dt);
                this.advect(0, this.densityB, this.densityB0, this.Vx, this.Vy, this.dt);

                for (let i = 0; i < this.densityR.length; i++) {
                    this.densityR[i] = Math.max(0, this.densityR[i] - FLUID_FADE_RATE * 255 * this.dt);
                    this.densityG[i] = Math.max(0, this.densityG[i] - FLUID_FADE_RATE * 255 * this.dt);
                    this.densityB[i] = Math.max(0, this.densityB[i] - FLUID_FADE_RATE * 255 * this.dt);
                }
            }

            draw(ctxToDrawOn, targetWidth, targetHeight) {
                const roundedSize = Math.round(this.size);
                 if (roundedSize <= 0 || !Number.isFinite(roundedSize)) {
                    console.error("Invalid fluid field size for drawing (this.size):", this.size);
                    return;
                }

                if (!offscreenFluidCanvas || offscreenFluidCanvas.width !== roundedSize) {
                    offscreenFluidCanvas = document.createElement('canvas');
                    offscreenFluidCanvas.width = roundedSize;
                    offscreenFluidCanvas.height = roundedSize;
                    offscreenFluidCtx = offscreenFluidCanvas.getContext('2d');
                }

                const imgData = offscreenFluidCtx.createImageData(roundedSize, roundedSize);
                const data = imgData.data;
                for (let i = 0; i < roundedSize * roundedSize; i++) {
                    data[i * 4 + 0] = Math.min(255, Math.max(0, Math.floor(this.densityR[i])));
                    data[i * 4 + 1] = Math.min(255, Math.max(0, Math.floor(this.densityG[i])));
                    data[i * 4 + 2] = Math.min(255, Math.max(0, Math.floor(this.densityB[i])));
                    data[i * 4 + 3] = (this.densityR[i] > 1 || this.densityG[i] > 1 || this.densityB[i] > 1) ? 255 : 0;
                }
                offscreenFluidCtx.putImageData(imgData, 0, 0);

                ctxToDrawOn.imageSmoothingEnabled = true;
                ctxToDrawOn.drawImage(offscreenFluidCanvas, 0, 0, roundedSize, roundedSize, 0, 0, targetWidth, targetHeight);
            }
            clear() {
                this.densityR.fill(0); this.densityG.fill(0); this.densityB.fill(0);
                this.densityR0.fill(0); this.densityG0.fill(0); this.densityB0.fill(0);
                this.Vx.fill(0); this.Vy.fill(0);
                this.Vx0.fill(0); this.Vy0.fill(0);
            }
        }


        // --- Particle Class (for fluid visualization) ---
        class Particle {
            constructor(x, y, fluidFieldRef) {
                this.pos = new Vec2(x, y);
                this.vel = new Vec2(Math.random() * 0.2 - 0.1, Math.random() * 0.2 - 0.1);
                this.fluidField = fluidFieldRef;
                this.life = 1.0;
                this.lifeDecay = PARTICLE_BASE_LIFE_DECAY + Math.random() * PARTICLE_LIFE_DECAY_RANDOM_FACTOR;
                this.size = Math.random() * 1.5 + 0.5;
                this.isEaten = false;
            }

            update(dt) {
                if (this.isEaten) {
                     // Particle is fading out after being eaten
                     this.life -= 0.2 * dt * 60; // Faster fade for eaten particles
                     if (this.life <= 0) {
                         // To be removed in updatePhysics
                     }
                    return;
                }

                if (!this.fluidField) return;
                const fluidGridX = Math.floor(this.pos.x / this.fluidField.scaleX); // Use scaleX
                const fluidGridY = Math.floor(this.pos.y / this.fluidField.scaleY); // Use scaleY
                const idx = this.fluidField.IX(fluidGridX, fluidGridY);

                const fluidVelX = this.fluidField.Vx[idx];
                const fluidVelY = this.fluidField.Vy[idx];

                this.vel.x = this.vel.x * (1.0 - PARTICLE_FLUID_INFLUENCE) + fluidVelX * PARTICLE_FLUID_INFLUENCE;
                this.vel.y = this.vel.y * (1.0 - PARTICLE_FLUID_INFLUENCE) + fluidVelY * PARTICLE_FLUID_INFLUENCE;
                this.vel.x += (Math.random() - 0.5) * 0.05;
                this.vel.y += (Math.random() - 0.5) * 0.05;

                this.pos = this.pos.add(this.vel.mul(dt * 100));

                if (IS_WORLD_WRAPPING) {
                    if (this.pos.x < 0) this.pos.x += WORLD_WIDTH;
                    if (this.pos.x > WORLD_WIDTH) this.pos.x -= WORLD_WIDTH;
                    if (this.pos.y < 0) this.pos.y += WORLD_HEIGHT;
                    if (this.pos.y > WORLD_HEIGHT) this.pos.y -= WORLD_HEIGHT;
                } else {
                    if (this.pos.x < 0 || this.pos.x > WORLD_WIDTH || this.pos.y < 0 || this.pos.y > WORLD_HEIGHT) {
                        if (!IS_PARTICLE_LIFE_INFINITE) this.life = 0;
                    }
                }

                if (!IS_PARTICLE_LIFE_INFINITE) {
                    this.life -= (PARTICLE_BASE_LIFE_DECAY + Math.random() * PARTICLE_LIFE_DECAY_RANDOM_FACTOR) * dt * 60;
                    if (this.life <=0) {
                       // To be removed in updatePhysics
                    }
                } else {
                    this.life = 1.0;
                }
            }

            draw(ctx) {
                const alpha = IS_PARTICLE_LIFE_INFINITE ? 0.7 : Math.max(0, this.life * 0.7);
                if (alpha <= 0.01 && !IS_PARTICLE_LIFE_INFINITE) return;
                ctx.fillStyle = `rgba(220, 220, 250, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }


        // --- Simulation Setup ---
        function initializePopulation() {
            softBodyPopulation = [];
            isAnySoftBodyUnstable = false;
            updateInstabilityIndicator();
            nextSoftBodyId = 0;

            for (let i = 0; i < CREATURE_POPULATION_FLOOR; i++) { // Use floor for initial pop
                const margin = 50;
                const randX = margin + Math.random() * (WORLD_WIDTH - margin * 2);
                const randY = margin + Math.random() * (WORLD_HEIGHT - margin * 2);
                softBodyPopulation.push(new SoftBody(nextSoftBodyId++, randX, randY));
            }
            lastTime = performance.now();
            updatePopulationCount();
        }


        function initFluidSimulation() {
            const scaleX = WORLD_WIDTH / FLUID_GRID_SIZE_CONTROL;
            const scaleY = WORLD_HEIGHT / FLUID_GRID_SIZE_CONTROL;
            fluidField = new FluidField(FLUID_GRID_SIZE_CONTROL, FLUID_DIFFUSION, FLUID_VISCOSITY, 1/60, scaleX, scaleY);
            fluidField.useWrapping = IS_WORLD_WRAPPING;
            fluidField.maxVelComponent = MAX_FLUID_VELOCITY_COMPONENT; // Pass the cap
            velocityEmitters = [];
            if (offscreenFluidCanvas) {
                offscreenFluidCanvas.width = Math.round(FLUID_GRID_SIZE_CONTROL); // Ensure integer
                offscreenFluidCanvas.height = Math.round(FLUID_GRID_SIZE_CONTROL); // Ensure integer
            }
        }

        function initParticles() {
            particles = [];
            particleEmissionDebt = 0;
        }

        function applyVelocityEmitters() {
            if (!fluidField || EMITTER_STRENGTH <= 0) return;
            for (const emitter of velocityEmitters) {
                fluidField.addVelocity(emitter.gridX, emitter.gridY,
                                       emitter.forceX * EMITTER_STRENGTH,
                                       emitter.forceY * EMITTER_STRENGTH);
            }
        }


        // --- Physics Update ---
        function updatePhysics(dt) {
            if (IS_SIMULATION_PAUSED) {
                requestAnimationFrame(gameLoop);
                return;
            }

            populateSpatialGrid();

            applyVelocityEmitters();

            // Particle Emission Logic with Floor and Ceiling
            if (particles.length < PARTICLE_POPULATION_FLOOR) {
                let particlesToSpawnToFloor = PARTICLE_POPULATION_FLOOR - particles.length;
                for (let i = 0; i < particlesToSpawnToFloor; i++) {
                    if (particles.length < PARTICLE_POPULATION_CEILING) { // Double check ceiling
                         particles.push(new Particle(Math.random() * WORLD_WIDTH, Math.random() * WORLD_HEIGHT, fluidField));
                    } else {
                        break;
                    }
                }
                particleEmissionDebt = 0; // Reset debt as we've just topped up
            } else if (particles.length < PARTICLE_POPULATION_CEILING && PARTICLES_PER_SECOND > 0 && fluidField) {
                particleEmissionDebt += PARTICLES_PER_SECOND * dt;
                while (particleEmissionDebt >= 1 && particles.length < PARTICLE_POPULATION_CEILING) {
                    particles.push(new Particle(Math.random() * WORLD_WIDTH, Math.random() * WORLD_HEIGHT, fluidField));
                    particleEmissionDebt -= 1;
                }
            } // If particles.length >= PARTICLE_POPULATION_CEILING, do nothing for rate-based emission


            if (selectedSoftBodyPoint && selectedSoftBodyPoint.point.isFixed && fluidField) {
                const activeBody = selectedSoftBodyPoint.body;
                const point = selectedSoftBodyPoint.point;
                const displacementX = point.pos.x - point.prevPos.x;
                const displacementY = point.pos.y - point.prevPos.y;
                const movementMagnitudeSq = displacementX*displacementX + displacementY*displacementY;
                const movementThresholdSq = 0.01 * 0.01;

                if (movementMagnitudeSq > movementThresholdSq) {
                    const fluidGridX = Math.floor(point.pos.x / fluidField.scaleX);
                    const fluidGridY = Math.floor(point.pos.y / fluidField.scaleY);

                    fluidField.addVelocity(fluidGridX, fluidGridY,
                                           displacementX * SOFT_BODY_PUSH_STRENGTH / fluidField.scaleX, // Scale to grid velocity
                                           displacementY * SOFT_BODY_PUSH_STRENGTH / fluidField.scaleY);
                    fluidField.addDensity(fluidGridX, fluidGridY, 60, 60, 80, 15);
                }
            }

            if (fluidField) {
                fluidField.dt = dt;
                fluidField.step();
            }

            canCreaturesReproduceGlobally = softBodyPopulation.length < CREATURE_POPULATION_CEILING;

            let currentAnyUnstable = false;
            let newOffspring = [];

            for (let i = softBodyPopulation.length - 1; i >= 0; i--) {
                const body = softBodyPopulation[i];
                if (!body.isUnstable) {
                    body.updateSelf(dt, fluidField);
                    if (body.isUnstable) {
                        currentAnyUnstable = true;
                    } else if (body.creatureEnergy >= MAX_CREATURE_ENERGY && body.canReproduce && canCreaturesReproduceGlobally) {
                        newOffspring.push(...body.reproduce());
                    }
                }
            }
            softBodyPopulation.push(...newOffspring);

            // Update and remove dead particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(dt);
                if (particles[i].life <= 0 && !particles[i].isEaten) {
                    particles.splice(i, 1);
                } else if (particles[i].isEaten && particles[i].life <=0) {
                    particles.splice(i,1);
                }
            }

            if(currentAnyUnstable && !isAnySoftBodyUnstable) {
                isAnySoftBodyUnstable = true;
            } else if (!currentAnyUnstable && isAnySoftBodyUnstable && !softBodyPopulation.some(b => b.isUnstable)) {
                isAnySoftBodyUnstable = false;
            }
            updateInstabilityIndicator();

            let removedCount = 0;
            for (let i = softBodyPopulation.length - 1; i >= 0; i--) {
                if (softBodyPopulation[i].isUnstable) {
                    softBodyPopulation.splice(i, 1);
                    removedCount++;
                }
            }

            // Creature population floor maintenance
            const neededToMaintainFloor = CREATURE_POPULATION_FLOOR - softBodyPopulation.length;
            if (neededToMaintainFloor > 0) {
                 for (let i = 0; i < neededToMaintainFloor; i++) {
                     if (softBodyPopulation.length < CREATURE_POPULATION_CEILING) { // Also respect ceiling when topping up
                         const margin = 50;
                         const randX = margin + Math.random() * (WORLD_WIDTH - margin * 2);
                         const randY = margin + Math.random() * (WORLD_HEIGHT - margin * 2);
                         softBodyPopulation.push(new SoftBody(nextSoftBodyId++, randX, randY));
                     } else {
                         break; // Stop if ceiling is reached during floor maintenance
                     }
                 }
            }
            updatePopulationCount();


            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- Drawing ---
        function draw() {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

            ctx.save();

            ctx.scale(viewZoom, viewZoom);
            ctx.translate(-viewOffsetX, -viewOffsetY);

            if (fluidField) {
                fluidField.draw(ctx, WORLD_WIDTH, WORLD_HEIGHT);
            }

            for (let particle of particles) {
                particle.draw(ctx);
            }
            for (let body of softBodyPopulation) {
                body.drawSelf(ctx);
            }

            if (IS_EMITTER_EDIT_MODE && currentEmitterPreview && fluidField) {
                ctx.beginPath();
                ctx.moveTo(currentEmitterPreview.startX, currentEmitterPreview.startY);
                ctx.lineTo(currentEmitterPreview.endX, currentEmitterPreview.endY);
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
                ctx.lineWidth = 2 / viewZoom;
                ctx.stroke();
                const angle = Math.atan2(currentEmitterPreview.endY - currentEmitterPreview.startY, currentEmitterPreview.endX - currentEmitterPreview.startX);
                const arrowSize = 10 / viewZoom;
                ctx.lineTo(currentEmitterPreview.endX - arrowSize * Math.cos(angle - Math.PI / 6), currentEmitterPreview.endY - arrowSize * Math.sin(angle - Math.PI / 6));
                ctx.moveTo(currentEmitterPreview.endX, currentEmitterPreview.endY);
                ctx.lineTo(currentEmitterPreview.endX - arrowSize * Math.cos(angle + Math.PI / 6), currentEmitterPreview.endY - arrowSize * Math.sin(angle + Math.PI / 6));
                ctx.stroke();
            }

            if (fluidField && velocityEmitters.length > 0) {
                 for (const emitter of velocityEmitters) {
                    const startX = (emitter.gridX + 0.5) * fluidField.scaleX;
                    const startY = (emitter.gridY + 0.5) * fluidField.scaleY;

                    const forceMagnitude = Math.sqrt(emitter.forceX**2 + emitter.forceY**2);
                    const displayLength = 20 * EMITTER_STRENGTH;
                    const endX = startX + (emitter.forceX / (forceMagnitude || 1)) * displayLength ;
                    const endY = startY + (emitter.forceY / (forceMagnitude || 1)) * displayLength ;


                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = 'rgba(0, 200, 255, 0.5)';
                    ctx.lineWidth = (1 + Math.min(5, forceMagnitude * EMITTER_STRENGTH * 0.5)) / viewZoom;
                    ctx.stroke();

                    const angle = Math.atan2(endY - startY, endX - startX);
                    const arrowSize = 8 / viewZoom;
                    if (Math.abs(endX-startX) > 0.01 || Math.abs(endY-startY) > 0.01) {
                        ctx.lineTo(endX - arrowSize * Math.cos(angle - Math.PI / 6), endY - arrowSize * Math.sin(angle - Math.PI / 6));
                        ctx.moveTo(endX, endY);
                        ctx.lineTo(endX - arrowSize * Math.cos(angle + Math.PI / 6), endY - arrowSize * Math.sin(angle + Math.PI / 6));
                        ctx.stroke();
                    }
                }
            }

            if (selectedInspectBody && selectedInspectPoint) {
                updateInfoPanel();
            }


            ctx.restore();
        }

        // --- Game Loop ---
        let animationFrameId = null;
        function gameLoop(timestamp) {
            if (IS_SIMULATION_PAUSED) {
                animationFrameId = requestAnimationFrame(gameLoop);
                return;
            }

            deltaTime = (timestamp - lastTime) / 1000;
            if (isNaN(deltaTime) || deltaTime <= 0) deltaTime = 1/60;
            lastTime = timestamp;

            const currentMaxDeltaTime = MAX_DELTA_TIME_MS / 1000.0;
            deltaTime = Math.min(deltaTime, currentMaxDeltaTime);

            updatePhysics(deltaTime);
        }

        // --- Config Import/Export ---
        function handleExportConfig() {
            const config = {
                worldWidth: WORLD_WIDTH,
                worldHeight: WORLD_HEIGHT,
                zoomSensitivity: ZOOM_SENSITIVITY,
                creaturePopulationFloor: CREATURE_POPULATION_FLOOR,
                creaturePopulationCeiling: CREATURE_POPULATION_CEILING,
                particlePopulationFloor: PARTICLE_POPULATION_FLOOR,
                particlePopulationCeiling: PARTICLE_POPULATION_CEILING,
                maxFluidVelocityComponent: MAX_FLUID_VELOCITY_COMPONENT, // New
                bodyFluidEntrainment: BODY_FLUID_ENTRAINMENT_FACTOR,
                fluidCurrentStrength: FLUID_CURRENT_STRENGTH_ON_BODY,
                softBodyPushStrength: SOFT_BODY_PUSH_STRENGTH,
                baseNodeCost: BASE_NODE_EXISTENCE_COST,
                emitterNodeCost: EMITTER_NODE_ENERGY_COST,
                neuronNodeCost: NEURON_NODE_ENERGY_COST,
                eaterNodeCost: EATER_NODE_ENERGY_COST,
                predatorNodeCost: PREDATOR_NODE_ENERGY_COST,
                reproductionCooldown: REPRODUCTION_COOLDOWN_TICKS,
                bodyRepulsionStrength: BODY_REPULSION_STRENGTH,
                bodyRepulsionRadiusFactor: BODY_REPULSION_RADIUS_FACTOR,
                maxTimestepMs: MAX_DELTA_TIME_MS,
                globalMutationRate: GLOBAL_MUTATION_RATE_MODIFIER,
                fluidGridSize: FLUID_GRID_SIZE_CONTROL,
                fluidDiffusion: FLUID_DIFFUSION,
                fluidViscosity: FLUID_VISCOSITY,
                fluidFadeRate: FLUID_FADE_RATE,
                isWorldWrapping: IS_WORLD_WRAPPING,
                particlesPerSecond: PARTICLES_PER_SECOND,
                particleFluidInfluence: PARTICLE_FLUID_INFLUENCE,
                particleBaseLifeDecay: PARTICLE_BASE_LIFE_DECAY,
                isParticleLifeInfinite: IS_PARTICLE_LIFE_INFINITE,
                emitterStrength: EMITTER_STRENGTH,
                velocityEmitters: velocityEmitters,
                viewZoom: viewZoom,
                viewOffsetX: viewOffsetX,
                viewOffsetY: viewOffsetY
            };
            const jsonString = JSON.stringify(config, null, 2);
            const blob = new Blob([jsonString], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sim_config.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log("Config exported.");
        }

        function handleImportConfig(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedConfig = JSON.parse(e.target.result);
                    applyImportedConfig(importedConfig);
                    console.log("Config imported successfully.");
                } catch (error) {
                    console.error("Error parsing imported config:", error);
                    alert("Failed to import config. Make sure it's a valid JSON file.");
                }
            };
            reader.readAsText(file);
            importConfigFile.value = '';
        }

        function applyImportedConfig(config) {
            if (config.worldWidth !== undefined) WORLD_WIDTH = config.worldWidth;
            if (config.worldHeight !== undefined) WORLD_HEIGHT = config.worldHeight;
            canvas.width = WORLD_WIDTH;
            canvas.height = WORLD_HEIGHT;
            // MAX_DISPLACEMENT_SQ_THRESHOLD = (WORLD_WIDTH / 5) * (WORLD_WIDTH / 5); // Not used anymore
            initializeSpatialGrid(); // Re-initialize grid with new world dimensions

            if (config.zoomSensitivity !== undefined) ZOOM_SENSITIVITY = config.zoomSensitivity;
            if (config.creaturePopulationFloor !== undefined) CREATURE_POPULATION_FLOOR = config.creaturePopulationFloor;
            if (config.creaturePopulationCeiling !== undefined) CREATURE_POPULATION_CEILING = config.creaturePopulationCeiling;
            if (config.particlePopulationFloor !== undefined) PARTICLE_POPULATION_FLOOR = config.particlePopulationFloor;
            if (config.particlePopulationCeiling !== undefined) PARTICLE_POPULATION_CEILING = config.particlePopulationCeiling;
            if (config.maxFluidVelocityComponent !== undefined) MAX_FLUID_VELOCITY_COMPONENT = config.maxFluidVelocityComponent; // New

            if (config.bodyFluidEntrainment !== undefined) BODY_FLUID_ENTRAINMENT_FACTOR = config.bodyFluidEntrainment;
            if (config.fluidCurrentStrength !== undefined) FLUID_CURRENT_STRENGTH_ON_BODY = config.fluidCurrentStrength;
            if (config.softBodyPushStrength !== undefined) SOFT_BODY_PUSH_STRENGTH = config.softBodyPushStrength;
            if (config.reproductionCooldown !== undefined) REPRODUCTION_COOLDOWN_TICKS = config.reproductionCooldown;
            if (config.bodyRepulsionStrength !== undefined) BODY_REPULSION_STRENGTH = config.bodyRepulsionStrength;
            if (config.bodyRepulsionRadiusFactor !== undefined) BODY_REPULSION_RADIUS_FACTOR = config.bodyRepulsionRadiusFactor;
            if (config.maxTimestepMs !== undefined) MAX_DELTA_TIME_MS = config.maxTimestepMs;
            if (config.globalMutationRate !== undefined) GLOBAL_MUTATION_RATE_MODIFIER = config.globalMutationRate;

            if (config.baseNodeCost !== undefined) BASE_NODE_EXISTENCE_COST = config.baseNodeCost;
            if (config.emitterNodeCost !== undefined) EMITTER_NODE_ENERGY_COST = config.emitterNodeCost;
            if (config.neuronNodeCost !== undefined) NEURON_NODE_ENERGY_COST = config.neuronNodeCost;
            if (config.eaterNodeCost !== undefined) EATER_NODE_ENERGY_COST = config.eaterNodeCost;
            if (config.predatorNodeCost !== undefined) PREDATOR_NODE_ENERGY_COST = config.predatorNodeCost;
            if (config.emitterStrength !== undefined) EMITTER_STRENGTH = config.emitterStrength;
            if (config.velocityEmitters !== undefined) velocityEmitters = config.velocityEmitters;
            if (config.fluidGridSize !== undefined) FLUID_GRID_SIZE_CONTROL = config.fluidGridSize;
            if (config.viewZoom !== undefined) viewZoom = config.viewZoom;
            if (config.viewOffsetX !== undefined) viewOffsetX = config.viewOffsetX;
            if (config.viewOffsetY !== undefined) viewOffsetY = config.viewOffsetY;


            if (config.fluidDiffusion !== undefined) FLUID_DIFFUSION = config.fluidDiffusion;
            if (config.fluidViscosity !== undefined) FLUID_VISCOSITY = config.fluidViscosity;
            if (config.fluidFadeRate !== undefined) FLUID_FADE_RATE = config.fluidFadeRate;
            if (config.isWorldWrapping !== undefined) IS_WORLD_WRAPPING = config.isWorldWrapping;

            if (config.particlesPerSecond !== undefined) PARTICLES_PER_SECOND = config.particlesPerSecond;
            if (config.particleFluidInfluence !== undefined) PARTICLE_FLUID_INFLUENCE = config.particleFluidInfluence;
            if (config.particleBaseLifeDecay !== undefined) PARTICLE_BASE_LIFE_DECAY = config.particleBaseLifeDecay;
            if (config.isParticleLifeInfinite !== undefined) IS_PARTICLE_LIFE_INFINITE = config.isParticleLifeInfinite;

            creaturePopulationFloorSlider.value = CREATURE_POPULATION_FLOOR;
            creaturePopulationCeilingSlider.value = CREATURE_POPULATION_CEILING;
            particlePopulationFloorSlider.value = PARTICLE_POPULATION_FLOOR;
            particlePopulationCeilingSlider.value = PARTICLE_POPULATION_CEILING;

            bodyFluidEntrainmentSlider.value = BODY_FLUID_ENTRAINMENT_FACTOR;
            fluidCurrentStrengthSlider.value = FLUID_CURRENT_STRENGTH_ON_BODY;
            bodyPushStrengthSlider.value = SOFT_BODY_PUSH_STRENGTH;
            baseNodeCostSlider.value = BASE_NODE_EXISTENCE_COST;
            emitterNodeCostSlider.value = EMITTER_NODE_ENERGY_COST;
            neuronNodeCostSlider.value = NEURON_NODE_ENERGY_COST;
            eaterNodeCostSlider.value = EATER_NODE_ENERGY_COST;
            predatorNodeCostSlider.value = PREDATOR_NODE_ENERGY_COST;
            emitterStrengthSlider.value = EMITTER_STRENGTH;
            globalMutationRateSlider.value = GLOBAL_MUTATION_RATE_MODIFIER;
            fluidGridSizeSlider.value = FLUID_GRID_SIZE_CONTROL;
            zoomSensitivitySlider.value = ZOOM_SENSITIVITY;
            particlesPerSecondSlider.value = PARTICLES_PER_SECOND;
            maxFluidVelocityComponentSlider.value = MAX_FLUID_VELOCITY_COMPONENT; // New

            reproductionCooldownSlider.value = REPRODUCTION_COOLDOWN_TICKS;
            bodyRepulsionStrengthSlider.value = BODY_REPULSION_STRENGTH;
            bodyRepulsionRadiusFactorSlider.value = BODY_REPULSION_RADIUS_FACTOR;
            maxTimestepSlider.value = MAX_DELTA_TIME_MS;
            fluidDiffusionSlider.value = FLUID_DIFFUSION;
            fluidViscositySlider.value = FLUID_VISCOSITY;
            fluidFadeSlider.value = FLUID_FADE_RATE;
            worldWrapToggle.checked = IS_WORLD_WRAPPING;
            emitterEditModeToggle.checked = IS_EMITTER_EDIT_MODE;
            particleFluidInfluenceSlider.value = PARTICLE_FLUID_INFLUENCE;
            particleLifeDecaySlider.value = PARTICLE_BASE_LIFE_DECAY;
            infiniteParticleLifeToggle.checked = IS_PARTICLE_LIFE_INFINITE;

            initializeAllSliderDisplays();

            initFluidSimulation();
            initParticles();
            initializePopulation();

            console.log("Applied imported config. Reset population if needed for full effect on creatures.");
        }

        // Simple modal for alerts
        function showMessageModal(message) {
            let modal = document.getElementById('messageModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'messageModal';
                modal.style.position = 'fixed';
                modal.style.left = '50%';
                modal.style.top = '50%';
                modal.style.transform = 'translate(-50%, -50%)';
                modal.style.backgroundColor = 'rgba(50,50,50,0.9)';
                modal.style.color = 'white';
                modal.style.padding = '20px';
                modal.style.border = '1px solid #777';
                modal.style.borderRadius = '8px';
                modal.style.boxShadow = '0 0 15px rgba(0,0,0,0.5)';
                modal.style.zIndex = '2000'; // Ensure on top

                const messageP = document.createElement('p');
                messageP.id = 'modalMessageText';
                messageP.style.margin = '0 0 15px 0';

                const closeButton = document.createElement('button');
                closeButton.textContent = 'OK';
                closeButton.style.padding = '8px 15px';
                closeButton.style.backgroundColor = '#007bff';
                closeButton.style.color = 'white';
                closeButton.style.border = 'none';
                closeButton.style.borderRadius = '4px';
                closeButton.style.cursor = 'pointer';
                closeButton.onclick = () => modal.style.display = 'none';

                modal.appendChild(messageP);
                modal.appendChild(closeButton);
                document.body.appendChild(modal);
            }
            document.getElementById('modalMessageText').textContent = message;
            modal.style.display = 'block';
        }


        // --- Main Initialization Sequence ---
        async function main() {
            // Initialize ALL global config variables with hardcoded defaults first
            WORLD_WIDTH = parseInt(worldWidthInput.value) || 8000;
            WORLD_HEIGHT = parseInt(worldHeightInput.value) || 6000;
            ZOOM_SENSITIVITY = 0.02; // Default
            CREATURE_POPULATION_FLOOR = 10; // Default
            CREATURE_POPULATION_CEILING = 1000; // Default
            PARTICLE_POPULATION_FLOOR = 5000; // Default
            PARTICLE_POPULATION_CEILING = 20000; // Default
            MAX_FLUID_VELOCITY_COMPONENT = 0.5; // Default
            BODY_FLUID_ENTRAINMENT_FACTOR = 0.465;
            FLUID_CURRENT_STRENGTH_ON_BODY = 19.7;
            SOFT_BODY_PUSH_STRENGTH = 0.10;
            REPRODUCTION_COOLDOWN_TICKS = 1000;
            BODY_REPULSION_STRENGTH = 100.0;
            BODY_REPULSION_RADIUS_FACTOR = 5.0;
            GLOBAL_MUTATION_RATE_MODIFIER = 0.25;
            MAX_DELTA_TIME_MS = 10;
            BASE_NODE_EXISTENCE_COST = 0.3;
            EMITTER_NODE_ENERGY_COST = 1.0;
            EATER_NODE_ENERGY_COST = 0.3;
            PREDATOR_NODE_ENERGY_COST = 0.8;
            NEURON_NODE_ENERGY_COST = 0.01;
            FLUID_GRID_SIZE_CONTROL = 128;
            FLUID_DIFFUSION = 0.00047;
            FLUID_VISCOSITY = 0.000068;
            FLUID_FADE_RATE = 0.002;
            PARTICLES_PER_SECOND = 500;
            PARTICLE_FLUID_INFLUENCE = 2.0;
            PARTICLE_BASE_LIFE_DECAY = 0.001;
            EMITTER_STRENGTH = 3.0;
            IS_WORLD_WRAPPING = worldWrapToggle.checked;
            IS_PARTICLE_LIFE_INFINITE = infiniteParticleLifeToggle.checked;
            IS_EMITTER_EDIT_MODE = emitterEditModeToggle.checked;


            await loadAndApplySliderConfig(); // Attempt to override with JSON values

            INITIAL_POPULATION_SIZE = CREATURE_POPULATION_FLOOR;

            initializeSpatialGrid();
            initializeAllSliderDisplays();
            initFluidSimulation();
            initParticles();
            initializePopulation();
            updateInstabilityIndicator();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        main(); // Start the main sequence

    </script>
</body>
</html>
