<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Tiny Transformer Playground</title>

    <!-- ─── LIBRARIES ──────────────────────────────────────────────────────────── -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.21.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis@1.5.1/dist/tfjs-vis.umd.min.js"></script>

    <!-- ─── STYLES ────────────────────────────────────────────────────────────── -->
    <style>
        body {
            font-family: sans-serif;
            margin: 1.2rem;
            line-height: 1.4;
            max-width: 900px;
        }

        textarea, input[type=text] {
            width: 100%;
            box-sizing: border-box;
        }

        button {
            margin: .4rem .6rem .4rem 0;
            padding: .5rem 1rem;
        }

        #tokenViz {
            margin-top: 1rem;
            font-family: monospace;
        }

        .token {
            display: inline-block;
            padding: 4px 6px;
            margin: 1px;
            border-radius: 4px;
            color: #000;
        }

        #genOutput {
            margin-top: .8rem;
            white-space: pre-wrap;
            background: #f7f7f7;
            padding: .6rem;
            border-radius: 4px;
            min-height: 3rem;
        }

        #status {
            display: inline-block;
            min-width: 6rem;
        }
    </style>
</head>

<body>
<h2>Tiny Transformer Playground</h2>

<!-- ─── TRAINING CORPUS ──────────────────────────────────────────────────────── -->
<label><strong>Training corpus (plain text, ≤ 1 kB):</strong></label><br>
<textarea id="inputText" rows="4">
hello world! this is a tiny transformer demo.
have fun teaching it character-level next-token prediction!
</textarea><br>

<!-- ─── TRAINING CONTROLS ────────────────────────────────────────────────────── -->
<button id="initBtn">① Reset Model</button>
<button id="trainStepBtn" disabled>② Train 1 Step</button>
<button id="trainEpochBtn" disabled>③ Train N Steps</button>
<input id="numSteps" type="number" value="200" min="1" style="width:6rem">
<label for="numSteps">steps</label>
<span id="status"></span>

<div id="lossVis" style="margin-top:1rem;"></div>
<div id="tokenViz">(Start training to see attention weights)</div>

<!-- ─── GENERATION CONTROLS ──────────────────────────────────────────────────── -->
<hr>
<h3>Generate text</h3>
<label for="promptInput">Prompt:</label>
<input id="promptInput" type="text" value="hello ">
<label for="genLen">Length:</label>
<input id="genLen" type="number" min="1" value="100" style="width:6rem">
<button id="genBtn" disabled>Generate</button>

<div id="genOutput"></div>

<!-- ─── SCRIPT ──────────────────────────────────────────────────────────────── -->
<script>
    (async () => {
        /* ───────── CONSTANTS ───────── */
        /* ───────── CONSTANTS ───────── */
        const MAX_SEQ_LEN = 32;   // leave this as 32
        const D_MODEL = 64;   // ← was 32, now 64 so the network is wider
        const LEARNING_RATE = 5e-2; // a bit gentler than 1e-1
        const OPTIMIZER = tf.train.adam(LEARNING_RATE);
        const TEMPERATURE = 0.1;  // nicer default for generation

        /* ───────── TOKENISER ───────── */
        const CHARS = Array.from(new Set(
            Array(128).fill(0).map((_, i) => String.fromCharCode(i))
                .filter(c => c >= ' ' && c <= '~')
        ));
        const PAD = '_';
        if (!CHARS.includes(PAD)) CHARS.push(PAD);
        const stoi = Object.fromEntries(CHARS.map((c, i) => [c, i]));
        const itos = CHARS;
        const VOCAB_SIZE = CHARS.length;

        function textToTensor(text) {
            const ids = [...text].slice(0, MAX_SEQ_LEN).map(ch => stoi[ch] ?? stoi['?']);
            while (ids.length < MAX_SEQ_LEN) ids.unshift(stoi[PAD]);   // left-pad
            return tf.tensor1d(ids, 'int32');
        }

        /* ───────── MODEL ───────── */
        class TinyTransformer {
            constructor() {
                /* ── embeddings ───────────────────────────── */
                this.embed = tf.variable(tf.randomNormal([VOCAB_SIZE, D_MODEL]).mul(0.1));
                this.posEmbed = tf.variable(tf.randomNormal([MAX_SEQ_LEN, D_MODEL]).mul(0.1));

                /* ── 1-head self-attention output ─────────── */
                this.outW = tf.variable(tf.randomNormal([D_MODEL, VOCAB_SIZE]).mul(0.1));
                this.outB = tf.variable(tf.zeros([VOCAB_SIZE]));

                /* ── tiny 2-layer feed-forward block ──────── */
                this.ff1 = tf.variable(tf.randomNormal([D_MODEL, 4 * D_MODEL]).mul(0.1));
                this.ff2 = tf.variable(tf.randomNormal([4 * D_MODEL, D_MODEL]).mul(0.1));
            }

            forward(x) {
                return tf.tidy(() => {
                    const [batch, seqLen] = x.shape;

                    /* ── token + positional embeddings ─────── */
                    const tok = tf.gather(this.embed, x);                                  // [b,s,d]
                    const pos = this.posEmbed.slice([0, 0], [seqLen, D_MODEL])             // [s,d]
                        .expandDims(0)                              // [1,s,d]
                        .tile([batch, 1, 1]);                       // [b,s,d]
                    const emb = tok.add(pos);                                              // [b,s,d]

                    /* ── single-head causal self-attention ─── */
                    const q = emb.slice([0, seqLen - 1, 0], [batch, 1, D_MODEL]);          // [b,1,d]
                    const k = emb;                                                         // [b,s,d]
                    const scores = tf.matMul(q, k, false, true).div(Math.sqrt(D_MODEL));   // [b,1,s]
                    const attn = tf.softmax(scores, -1);                                 // [b,1,s]
                    const context = tf.matMul(attn, k).reshape([batch, D_MODEL]);          // [b,d]

                    /* ── tiny feed-forward layer ───────────── */
                    const hidden = tf.relu(tf.matMul(context, this.ff1));                // [b,4d]
                    const context2 = tf.matMul(hidden, this.ff2);                          // [b,d]

                    /* ── output projection ─────────────────── */
                    const logits = tf.add(tf.matMul(context2, this.outW), this.outB);      // [b,V]
                    return {logits, attn: attn.reshape([batch, seqLen])};
                });
            }

            async trainStep(input, targetId) {
                const lossValue = OPTIMIZER.minimize(() => {
                    const {logits} = this.forward(input.expandDims(0));
                    return tf.losses.softmaxCrossEntropy(
                        tf.oneHot(tf.tensor1d([targetId], 'int32'), VOCAB_SIZE), logits);
                }, true, [this.embed, this.outW, this.outB]);
                const out = await lossValue.data();
                lossValue.dispose();
                return out[0];
            }

            sampleNext(contextTensor, temperature = 1.0) {
                return tf.tidy(() => {
                    const {logits} = this.forward(contextTensor.expandDims(0));
                    const scaled = logits.div(temperature);
                    const probs = tf.softmax(scaled).flatten();
                    const nextId = tf.multinomial(probs, 1, null, true).arraySync()[0];
                    logits.dispose();
                    scaled.dispose();
                    probs.dispose();
                    return nextId;
                });
            }
        }

        /* ───────── DATA ───────── */
        function* makeCharDataset(text) {
            const clean = [...text].filter(ch => ch >= ' ' && ch <= '~');
            for (let i = 1; i < clean.length; ++i) {
                const window = clean.slice(Math.max(0, i - (MAX_SEQ_LEN - 1)), i);
                yield {inputTensor: textToTensor(window.join('')), targetId: stoi[clean[i]]};
            }
        }

        /* ───────── VISUALS ───────── */
        const lossDiv = document.getElementById('lossVis');
        const tokenDiv = document.getElementById('tokenViz');
        let lossValues = [];

        function renderChart() {
            tfvis.render.linechart(
                lossDiv,
                {values: [lossValues], series: ['loss']},
                {width: 500, height: 300, yLabel: 'Cross-entropy', xLabel: 'Step'}
            );
        }

        function renderAttention(tokens, attnWeights) {
            tokenDiv.innerHTML = '';
            const max = Math.max(...attnWeights);
            tokens.forEach((t, i) => {
                const w = max ? attnWeights[i] / max : 0;
                const span = document.createElement('span');
                span.textContent = t;
                span.className = 'token';
                span.style.backgroundColor = `rgba(255,165,0,${w})`;
                tokenDiv.appendChild(span);
            });
        }

        /* ───────── UI ELEMENTS ───────── */
        const initBtn = document.getElementById('initBtn');
        const stepBtn = document.getElementById('trainStepBtn');
        const epochBtn = document.getElementById('trainEpochBtn');
        const numStepsInput = document.getElementById('numSteps');
        const statusSpan = document.getElementById('status');
        const textArea = document.getElementById('inputText');
        const genBtn = document.getElementById('genBtn');
        const genLenInput = document.getElementById('genLen');
        const promptInput = document.getElementById('promptInput');
        const genOutputDiv = document.getElementById('genOutput');

        /* ───────── STATE ───────── */
        let model, dataset, dataIter;

        /* ───────── FUNCTIONS ───────── */
        function reset() {
            model = new TinyTransformer();
            dataset = Array.from(makeCharDataset(textArea.value));
            dataIter = 0;
            lossValues = [];
            lossDiv.innerHTML = '';
            tokenDiv.textContent = '(Start training to see attention weights)';
            genOutputDiv.textContent = '';
            statusSpan.textContent = '';
            stepBtn.disabled = epochBtn.disabled = genBtn.disabled = false;
        }

        async function trainOne() {
            if (dataIter >= dataset.length) dataIter = 0;
            const sample = dataset[dataIter++];
            const loss = await model.trainStep(sample.inputTensor, sample.targetId);

            const {attn} = model.forward(sample.inputTensor.expandDims(0));
            const attnArr = attn.dataSync();
            const tokens = sample.inputTensor.arraySync().map(i => itos[i]);
            renderAttention(tokens, attnArr);
            attn.dispose();                            // ← no manual dispose of input tensor
            return loss;
        }

        function generateText(prompt, length) {
            let context = [...prompt].map(ch => stoi[ch] ?? stoi['?']);
            let output = prompt;
            for (let i = 0; i < length; ++i) {
                const ctxIds = context.slice(-MAX_SEQ_LEN);
                while (ctxIds.length < MAX_SEQ_LEN) ctxIds.unshift(stoi[PAD]);
                const ctxTensor = tf.tensor1d(ctxIds, 'int32');
                const nextId = model.sampleNext(ctxTensor, TEMPERATURE);
                ctxTensor.dispose();
                const nextChar = itos[nextId] || '?';
                output += nextChar;
                context.push(nextId);
            }
            return output;
        }

        /* ───────── BUTTON HANDLERS ───────── */
        initBtn.onclick = reset;

        stepBtn.onclick = async () => {
            const loss = await trainOne();
            lossValues.push({x: lossValues.length, y: loss});
            renderChart();
        };

        epochBtn.onclick = async () => {
            const N = parseInt(numStepsInput.value);
            stepBtn.disabled = epochBtn.disabled = true;
            statusSpan.textContent = '(0 / ' + N + ')';

            for (let i = 0; i < N; ++i) {
                const loss = await trainOne();
                lossValues.push({x: lossValues.length, y: loss});
                if (i % 10 === 0) {
                    renderChart();
                    await tf.nextFrame();
                }
                if (i % 20 === 0) statusSpan.textContent = `(${i + 1} / ${N})`;
            }
            renderChart();
            statusSpan.textContent = '';
            stepBtn.disabled = epochBtn.disabled = false;
        };

        genBtn.onclick = () => {
            const prompt = promptInput.value || ' ';
            const len = parseInt(genLenInput.value);
            genOutputDiv.textContent = generateText(prompt, len);
        };

        /* ─── AUTO-INIT ─── */
        reset();
    })();
</script>
</body>
</html>
