<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Soft Body Population with Instability</title>
    <style>
        body {
            margin: 0;
            overflow-y: auto; 
            background-color: #111;
            display: flex;
            flex-direction: column;
            justify-content: flex-start; 
            align-items: center;    
            min-height: 100vh;
            font-family: sans-serif;
            color: #eee;
            padding: 10px 0; 
            box-sizing: border-box; 
        }
        canvas {
            border: 1px solid #444;
            background-color: #222; 
        }
        #controls {
            background-color: rgba(50,50,50,0.8);
            padding: 10px;
            border-radius: 8px;
            margin-bottom:10px; 
            display: flex;
            flex-wrap: wrap; 
            gap: 10px;
            max-width: 800px; 
            width: calc(100% - 20px); 
            box-sizing: border-box;
            justify-content: center; 
        }
        #controls div.control-group { 
            padding: 10px; 
            border: 1px solid #555;
            border-radius: 6px; 
            background-color: rgba(40,40,40,0.7); 
            flex-grow: 1; 
            min-width: 180px; 
            max-width: 240px; 
            box-sizing: border-box;
            display: flex;
            flex-direction: column; 
        }
        #controls label.slider-label, #controls label.checkbox-label { 
            display: block;
            margin-bottom: 2px; 
            font-size: 0.85em; 
            font-weight: bold;
            color: #ddd;
            text-align: left; 
        }
        #controls label.checkbox-label {
            margin-top: 8px;
            display: flex; 
            align-items: center;
        }
        #controls input[type="checkbox"] {
            margin-left: 5px;
        }
        #controls span.slider-value { 
            display: block; 
            font-size: 0.8em; 
            text-align: right; 
            color: #00aeff; 
            margin-bottom: 3px; 
            min-height: 1em; 
        }
        #controls input[type="range"] {
            width: 100%; 
            margin-top: 0; 
            box-sizing: border-box;
        }
        #controls input[type="range"]:disabled + span.slider-value, 
        #controls input[type="range"]:disabled ~ label.slider-label {
             color: #777; 
        }
        #controls button {
            padding: 8px 12px; 
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 8px; 
            width: 100%; 
            box-sizing: border-box;
        }
        #controls button:hover {
            background-color: #0056b3;
        }
        .control-group h4 {
            margin-top: 0;
            margin-bottom: 10px; 
            text-align: center;
            color: #00aeff; 
            width: 100%; 
            font-size: 1em; 
        }
        .indicator-label {
            font-size: 0.85em;
            color: #ddd;
            margin-top: 8px;
        }
        .indicator-light {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #4CAF50; /* Green by default */
            margin-left: 5px;
            vertical-align: middle;
            border: 1px solid #222;
            transition: background-color 0.3s;
        }
        .indicator-light.unstable {
            background-color: #F44336; /* Red when unstable */
        }
    </style>
</head>
<body>
    <div id="controls">
        <div class="control-group">
            <h4>Soft Body (Verlet)</h4>
            <label for="bodyFluidEntrainment" class="slider-label">Fluid Entrainment:</label>
            <span id="bodyFluidEntrainmentValue" class="slider-value">0.05</span>
            <input type="range" id="bodyFluidEntrainment" min="0.0" max="0.5" value="0.05" step="0.005"> 
            
            <label for="fluidCurrentStrength" class="slider-label">Fluid Current Strength:</label>
            <span id="fluidCurrentStrengthValue" class="slider-value">10.0</span>
            <input type="range" id="fluidCurrentStrength" min="0.0" max="25.0" value="10.0" step="0.1"> 
            
            <label for="bodyPushStrength" class="slider-label">Body Push (Drag):</label>
            <span id="bodyPushStrengthValue" class="slider-value">2.0</span>
            <input type="range" id="bodyPushStrength" min="0.0" max="10.0" value="2.0" step="0.1">
            
            <div class="indicator-label">Any Unstable: <span id="instabilityLight" class="indicator-light"></span></div>
            <button id="resetButton">Reset Population</button>
        </div>
        <div class="control-group">
            <h4>Fluid</h4>
            <label for="fluidDiffusion" class="slider-label">Diffusion:</label>
            <span id="fluidDiffusionValue" class="slider-value">1.0e-5</span>
            <input type="range" id="fluidDiffusion" min="0" max="0.001" value="0.00001" step="0.00001">

            <label for="fluidViscosity" class="slider-label">Viscosity:</label>
            <span id="fluidViscosityValue" class="slider-value">1.0e-6</span>
            <input type="range" id="fluidViscosity" min="0" max="0.0001" value="0.000001" step="0.000001">

            <label for="fluidFade" class="slider-label">Fade Rate:</label>
            <span id="fluidFadeValue" class="slider-value">0.01</span>
            <input type="range" id="fluidFade" min="0.001" max="0.1" value="0.01" step="0.001">
            <button id="clearFluidButton">Clear Fluid</button>
        </div>
         <div class="control-group">
            <h4>Particles</h4>
            <label for="numParticles" class="slider-label">Particles:</label>
            <span id="numParticlesValue" class="slider-value">500</span>
            <input type="range" id="numParticles" min="0" max="2000" value="500" step="10">

             <label for="particleFluidInfluence" class.slider-label="slider-label">Fluid Influence:</label>
             <span id="particleFluidInfluenceValue" class="slider-value">0.3</span>
             <input type="range" id="particleFluidInfluence" min="0.01" max="1.0" value="0.3" step="0.01">

             <label for="particleLifeDecay" id="particleLifeDecayLabel" class="slider-label">Life Decay Rate:</label>
             <span id="particleLifeDecayValue" class="slider-value">0.005</span>
             <input type="range" id="particleLifeDecay" min="0.0001" max="0.02" value="0.005" step="0.0001">
            
             <label for="infiniteParticleLifeToggle" class="checkbox-label">Infinite Life:
                <input type="checkbox" id="infiniteParticleLifeToggle">
            </label>

            <button id="resetParticlesButton">Reset Particles</button>
        </div>
    </div>
    <canvas id="simulationCanvas"></canvas>
    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');

        // --- Controls ---
        const bodyFluidEntrainmentSlider = document.getElementById('bodyFluidEntrainment'); 
        const fluidCurrentStrengthSlider = document.getElementById('fluidCurrentStrength'); 
        const bodyPushStrengthSlider = document.getElementById('bodyPushStrength'); 
        const instabilityLight = document.getElementById('instabilityLight'); 
        const resetButton = document.getElementById('resetButton');
        const bodyFluidEntrainmentValueSpan = document.getElementById('bodyFluidEntrainmentValue'); 
        const fluidCurrentStrengthValueSpan = document.getElementById('fluidCurrentStrengthValue'); 
        const bodyPushStrengthValueSpan = document.getElementById('bodyPushStrengthValue'); 

        const fluidDiffusionSlider = document.getElementById('fluidDiffusion');
        const fluidViscositySlider = document.getElementById('fluidViscosity');
        const fluidFadeSlider = document.getElementById('fluidFade');
        const clearFluidButton = document.getElementById('clearFluidButton');
        const fluidDiffusionValueSpan = document.getElementById('fluidDiffusionValue');
        const fluidViscosityValueSpan = document.getElementById('fluidViscosityValue');
        const fluidFadeValueSpan = document.getElementById('fluidFadeValue');
        
        const numParticlesSlider = document.getElementById('numParticles');
        const numParticlesValueSpan = document.getElementById('numParticlesValue');
        const particleFluidInfluenceSlider = document.getElementById('particleFluidInfluence');
        const particleFluidInfluenceValueSpan = document.getElementById('particleFluidInfluenceValue');
        const particleLifeDecaySlider = document.getElementById('particleLifeDecay'); 
        const particleLifeDecayValueSpan = document.getElementById('particleLifeDecayValue'); 
        const infiniteParticleLifeToggle = document.getElementById('infiniteParticleLifeToggle'); 
        const particleLifeDecayLabel = document.getElementById('particleLifeDecayLabel'); 
        const resetParticlesButton = document.getElementById('resetParticlesButton');

        // --- Global Variables & Constants ---
        let BODY_FLUID_ENTRAINMENT_FACTOR = parseFloat(bodyFluidEntrainmentSlider.value); 
        let FLUID_CURRENT_STRENGTH_ON_BODY = parseFloat(fluidCurrentStrengthSlider.value); 
        let SOFT_BODY_PUSH_STRENGTH = parseFloat(bodyPushStrengthSlider.value); 
        let FLUID_DIFFUSION = parseFloat(fluidDiffusionSlider.value);
        let FLUID_VISCOSITY = parseFloat(fluidViscositySlider.value);
        let FLUID_FADE_RATE = parseFloat(fluidFadeSlider.value);
        let NUM_PARTICLES = parseInt(numParticlesSlider.value);
        let PARTICLE_FLUID_INFLUENCE = parseFloat(particleFluidInfluenceSlider.value);
        let PARTICLE_BASE_LIFE_DECAY = parseFloat(particleLifeDecaySlider.value);
        let IS_PARTICLE_LIFE_INFINITE = infiniteParticleLifeToggle.checked; 
        const PARTICLE_LIFE_DECAY_RANDOM_FACTOR = 0.002; 

        const EATING_RADIUS_MULTIPLIER = 3.5; 
        const ENERGY_PER_PARTICLE = 2;
        const MAX_CREATURE_ENERGY = 100;
        // creatureEnergy will be per soft body instance

        let isAnySoftBodyUnstable = false; 
        const MAX_DISPLACEMENT_SQ_THRESHOLD = (canvas.width / 2) * (canvas.width / 2); 
        const TARGET_POPULATION_SIZE = 5;

        // Function to update slider value display
        function updateSliderDisplay(slider, span) {
            let value = parseFloat(slider.value);
            if (slider.id === 'fluidDiffusion' || slider.id === 'fluidViscosity') {
                span.textContent = value.toExponential(1);
            } else if (slider.id === 'particleFluidInfluence' || slider.id === 'fluidCurrentStrength' || slider.id === 'bodyPushStrength') {
                 span.textContent = value.toFixed(1); 
            } else if (slider.id === 'bodyFluidEntrainment') {
                span.textContent = value.toFixed(2); 
            } else if (slider.id === 'particleLifeDecay') {
                span.textContent = value.toFixed(4);
            }
            else {
                span.textContent = value;
            }
        }

        // --- Event Listeners ---
        bodyFluidEntrainmentSlider.oninput = function() { BODY_FLUID_ENTRAINMENT_FACTOR = parseFloat(this.value); updateSliderDisplay(this, bodyFluidEntrainmentValueSpan); }
        fluidCurrentStrengthSlider.oninput = function() { FLUID_CURRENT_STRENGTH_ON_BODY = parseFloat(this.value); updateSliderDisplay(this, fluidCurrentStrengthValueSpan); }
        bodyPushStrengthSlider.oninput = function() { SOFT_BODY_PUSH_STRENGTH = parseFloat(this.value); updateSliderDisplay(this, bodyPushStrengthValueSpan); }
        resetButton.onclick = function() { 
            initializePopulation(); 
            isAnySoftBodyUnstable = false; 
            updateInstabilityIndicator();
        } 

        fluidDiffusionSlider.oninput = function() { FLUID_DIFFUSION = parseFloat(this.value); updateSliderDisplay(this, fluidDiffusionValueSpan); if(fluidField) fluidField.diffusion = FLUID_DIFFUSION;}
        fluidViscositySlider.oninput = function() { FLUID_VISCOSITY = parseFloat(this.value); updateSliderDisplay(this, fluidViscosityValueSpan); if(fluidField) fluidField.viscosity = FLUID_VISCOSITY;}
        fluidFadeSlider.oninput = function() { FLUID_FADE_RATE = parseFloat(this.value); updateSliderDisplay(this, fluidFadeValueSpan);}
        clearFluidButton.onclick = function() { if(fluidField) fluidField.clear(); }
        
        numParticlesSlider.oninput = function() { NUM_PARTICLES = parseInt(this.value); updateSliderDisplay(this, numParticlesValueSpan); initParticles(); }
        particleFluidInfluenceSlider.oninput = function() { PARTICLE_FLUID_INFLUENCE = parseFloat(this.value); updateSliderDisplay(this, particleFluidInfluenceValueSpan); }
        particleLifeDecaySlider.oninput = function() { PARTICLE_BASE_LIFE_DECAY = parseFloat(this.value); updateSliderDisplay(this, particleLifeDecayValueSpan); }
        infiniteParticleLifeToggle.onchange = function() { 
            IS_PARTICLE_LIFE_INFINITE = this.checked;
            particleLifeDecaySlider.disabled = IS_PARTICLE_LIFE_INFINITE;
            particleLifeDecayLabel.style.color = IS_PARTICLE_LIFE_INFINITE ? '#777' : '#ddd';
            particleLifeDecayValueSpan.style.color = IS_PARTICLE_LIFE_INFINITE ? '#777' : '#00aeff';
            initParticles(); 
        }
        resetParticlesButton.onclick = function() { initParticles(); }

        function initializeAllSliderDisplays() {
            updateSliderDisplay(bodyFluidEntrainmentSlider, bodyFluidEntrainmentValueSpan); 
            updateSliderDisplay(fluidCurrentStrengthSlider, fluidCurrentStrengthValueSpan); 
            updateSliderDisplay(bodyPushStrengthSlider, bodyPushStrengthValueSpan); 
            updateSliderDisplay(fluidDiffusionSlider, fluidDiffusionValueSpan);
            updateSliderDisplay(fluidViscositySlider, fluidViscosityValueSpan);
            updateSliderDisplay(fluidFadeSlider, fluidFadeValueSpan);
            updateSliderDisplay(numParticlesSlider, numParticlesValueSpan);
            updateSliderDisplay(particleFluidInfluenceSlider, particleFluidInfluenceValueSpan);
            updateSliderDisplay(particleLifeDecaySlider, particleLifeDecayValueSpan);

            particleLifeDecaySlider.disabled = IS_PARTICLE_LIFE_INFINITE;
            particleLifeDecayLabel.style.color = IS_PARTICLE_LIFE_INFINITE ? '#777' : '#ddd';
            particleLifeDecayValueSpan.style.color = IS_PARTICLE_LIFE_INFINITE ? '#777' : '#00aeff';
        }
        
        function updateInstabilityIndicator() {
            if (isAnySoftBodyUnstable) {
                instabilityLight.classList.add('unstable');
            } else {
                instabilityLight.classList.remove('unstable');
            }
        }

        // --- Simulation Parameters ---
        canvas.width = 800;
        canvas.height = 600;
        const restitution = 0.4; 

        let softBodyPopulation = []; 
        let fluidField;
        let particles = [];

        let lastTime = 0;
        let deltaTime = 0;
        let nextSoftBodyId = 0;


        // --- Mouse Interaction ---
        let selectedSoftBodyPoint = null; 
        let mouse = { x: 0, y: 0, prevX: 0, prevY: 0, isDown: false, dx:0, dy:0 };

        function updateMouse(e) {
            const rect = canvas.getBoundingClientRect();
            mouse.prevX = mouse.x;
            mouse.prevY = mouse.y;
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
            mouse.dx = mouse.x - mouse.prevX;
            mouse.dy = mouse.y - mouse.prevY;
        }

        canvas.addEventListener('mousedown', (e) => {
            mouse.isDown = true;
            updateMouse(e);

            for (let body of softBodyPopulation) {
                for (let i = 0; i < body.massPoints.length; i++) {
                    const point = body.massPoints[i];
                    const dist = Math.sqrt((point.pos.x - mouse.x)**2 + (point.pos.y - mouse.y)**2);
                    if (dist < point.radius * 2.5) { 
                        selectedSoftBodyPoint = { body: body, point: point };
                        point.isFixed = true; 
                        point.prevPos.x = point.pos.x;
                        point.prevPos.y = point.pos.y;
                        return; 
                    }
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            updateMouse(e);
            if (mouse.isDown) {
                if (selectedSoftBodyPoint) {
                    const point = selectedSoftBodyPoint.point;
                    point.prevPos.x = point.pos.x; 
                    point.prevPos.y = point.pos.y;
                    point.pos.x = mouse.x; 
                    point.pos.y = mouse.y;

                } else if (fluidField) { 
                    const fluidGridX = Math.floor(mouse.x / fluidField.scale);
                    const fluidGridY = Math.floor(mouse.y / fluidField.scale);
                    const r1 = Math.random() * 100 + 155; 
                    const g1 = Math.random() * 50 + 25; 
                    const b1 = Math.random() * 100 + 100; 
                    fluidField.addDensity(fluidGridX, fluidGridY, r1, g1, b1, 150 + Math.random()*50); 
                    
                    const r2 = Math.random() * 50 + 25; 
                    const g2 = Math.random() * 100 + 155; 
                    const b2 = Math.random() * 100 + 155; 
                    fluidField.addDensity(fluidGridX, fluidGridY, r2, g2, b2, 150 + Math.random()*50); 
                    
                    fluidField.addVelocity(fluidGridX, fluidGridY, mouse.dx * 10, mouse.dy * 10); 
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            mouse.isDown = false;
            if (selectedSoftBodyPoint) {
                const point = selectedSoftBodyPoint.point;
                point.isFixed = false; 
                point.prevPos.x = point.pos.x - mouse.dx * 1.0; 
                point.prevPos.y = point.pos.y - mouse.dy * 1.0;
                selectedSoftBodyPoint = null;
            }
        });
         canvas.addEventListener('mouseleave', () => {
            if (selectedSoftBodyPoint) {
                const point = selectedSoftBodyPoint.point;
                point.isFixed = false;
                point.prevPos.x = point.pos.x - mouse.dx * 1.0;
                point.prevPos.y = point.pos.y - mouse.dy * 1.0;
                selectedSoftBodyPoint = null;
            }
            mouse.isDown = false; 
        });


        // --- Vector2D Class ---
        class Vec2 {
            constructor(x = 0, y = 0) { this.x = x; this.y = y; }
            add(other) { return new Vec2(this.x + other.x, this.y + other.y); }
            sub(other) { return new Vec2(this.x - other.x, this.y - other.y); }
            mul(scalar) { return new Vec2(this.x * scalar, this.y * scalar); }
            div(scalar) { return scalar !== 0 ? new Vec2(this.x / scalar, this.y / scalar) : new Vec2(); }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            magSq() { return this.x * this.x + this.y * this.y; } 
            normalize() { const m = this.mag(); return m > 0 ? this.div(m) : new Vec2(); }
            static dot(v1, v2) { return v1.x * v2.x + v1.y * v2.y; }
            clone() { return new Vec2(this.x, this.y); } 
        }

        // --- MassPoint Class (Soft Body with Verlet Integration) ---
        class MassPoint {
            constructor(x, y, mass = 0.5, radius = 5, color = 'rgba(0,150,255,0.8)') { 
                this.pos = new Vec2(x, y);
                this.prevPos = new Vec2(x, y); 
                this.force = new Vec2();
                this.mass = mass;
                this.invMass = mass !== 0 ? 1 / mass : 0;
                this.radius = radius;
                this.color = color;
                this.isFixed = false;
                this.isMotorNode = false; 
                this.isEaterNode = false; 
            }
            applyForce(f) { this.force = this.force.add(f); }
            
            update(dt) {
                if (this.isFixed || this.invMass === 0) { 
                    this.force = new Vec2(); 
                    return; 
                }

                const acceleration = this.force.mul(this.invMass);
                
                const tempX = this.pos.x;
                const tempY = this.pos.y;
                
                this.pos.x = 2 * this.pos.x - this.prevPos.x + acceleration.x * dt * dt;
                this.pos.y = 2 * this.pos.y - this.prevPos.y + acceleration.y * dt * dt;
                
                this.prevPos.x = tempX;
                this.prevPos.y = tempY;
                
                this.force = new Vec2(); 
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
                if (this.isMotorNode && this.isEaterNode) {
                     ctx.fillStyle = 'rgba(150,255,50,0.9)'; 
                } else if (this.isMotorNode) {
                    ctx.fillStyle = 'rgba(0,255,100,0.9)'; 
                } else if (this.isEaterNode) {
                    ctx.fillStyle = 'rgba(255,165,0,0.9)'; 
                }
                else {
                    ctx.fillStyle = this.isFixed ? 'rgba(255,0,0,0.9)' : this.color;
                }
                ctx.fill();
                ctx.closePath();
            }
        }

        // --- Spring Class (Soft Body) ---
        class Spring {
            constructor(p1, p2, stiffness, dampingFactor, restLength = null) {
                this.p1 = p1; this.p2 = p2;
                this.stiffness = stiffness; 
                this.dampingFactor = dampingFactor; 
                this.restLength = restLength === null ? p1.pos.sub(p2.pos).mag() : restLength;
            }
            applyForce() {
                const diffPos = this.p1.pos.sub(this.p2.pos); 
                const currentLength = diffPos.mag();
                if (currentLength === 0) return;
                const displacement = currentLength - this.restLength;
                const direction = diffPos.normalize();
                
                const springForceMagnitude = -this.stiffness * displacement;
                const springForce = direction.mul(springForceMagnitude);

                const p1_vel_implicit = this.p1.pos.sub(this.p1.prevPos);
                const p2_vel_implicit = this.p2.pos.sub(this.p2.prevPos);
                const relVel_implicit = p1_vel_implicit.sub(p2_vel_implicit);
                
                const velAlongSpring = Vec2.dot(relVel_implicit, direction);
                const dampingForceMagnitude = -this.dampingFactor * velAlongSpring; 
                const dampingForce = direction.mul(dampingForceMagnitude);

                const totalForce = springForce.add(dampingForce);
                this.p1.applyForce(totalForce);
                this.p2.applyForce(totalForce.mul(-1));
            }
            draw(ctx) {
                ctx.beginPath();
                ctx.moveTo(this.p1.pos.x, this.p1.pos.y);
                ctx.lineTo(this.p2.pos.x, this.p2.pos.y);
                ctx.strokeStyle = 'rgba(150,150,150,0.6)'; 
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.closePath();
            }
        }
        
        // --- SoftBody Class ---
        class SoftBody {
            constructor(id, initialX, initialY) {
                this.id = id;
                this.massPoints = [];
                this.springs = [];
                this.isUnstable = false;
                this.creatureEnergy = 0; 
                this.motorNode = null;
                this.eaterNode = null;

                this.stiffness = 500 + Math.random() * 2500; 
                this.springDamping = 5 + Math.random() * 20;  
                this.motorStrength = 0.1 + Math.random() * 0.9; 
                this.isMotorActive = Math.random() < 0.7;   

                this.fluidEntrainment = BODY_FLUID_ENTRAINMENT_FACTOR; 
                this.fluidCurrentStrength = FLUID_CURRENT_STRENGTH_ON_BODY;
                this.bodyPushStrength = SOFT_BODY_PUSH_STRENGTH; 

                this.createShape(initialX, initialY);
            }

            createShape(startX, startY) {
                this.massPoints = []; // Clear previous points if any
                this.springs = [];    // Clear previous springs

                const shapeType = Math.floor(Math.random() * 3); // 0: Grid, 1: Line, 2: Circle
                const basePointDist = 20 + Math.random() * 10; // Base distance for points
                const mass = 0.3 + Math.random() * 0.4; 
                const radius = 3 + Math.random() * 3;   

                if (shapeType === 0) { // Grid (Square)
                    const numPointsX = 3;
                    const numPointsY = 3;
                    let gridPoints = [];
                    for (let i = 0; i < numPointsY; i++) {
                        gridPoints[i] = [];
                        for (let j = 0; j < numPointsX; j++) {
                            const point = new MassPoint(startX + j * basePointDist, startY + i * basePointDist, mass, radius);
                            this.massPoints.push(point);
                            gridPoints[i][j] = point;
                        }
                    }
                    const motorGridX = Math.floor(numPointsX / 2);
                    const motorGridY = Math.floor(numPointsY / 2);
                    if (gridPoints[motorGridY] && gridPoints[motorGridY][motorGridX]) {
                        gridPoints[motorGridY][motorGridX].isMotorNode = true;
                        this.motorNode = gridPoints[motorGridY][motorGridX];
                    }
                    const eaterGridX = Math.floor(numPointsX / 2); 
                    const eaterGridY = 0; 
                    if (gridPoints[eaterGridY] && gridPoints[eaterGridY][eaterGridX]) {
                        gridPoints[eaterGridY][eaterGridX].isEaterNode = true;
                        this.eaterNode = gridPoints[eaterGridY][eaterGridX];
                    }
                    for (let i = 0; i < numPointsY; i++) for (let j = 0; j < numPointsX - 1; j++) this.springs.push(new Spring(gridPoints[i][j], gridPoints[i][j+1], this.stiffness, this.springDamping));
                    for (let j = 0; j < numPointsX; j++) for (let i = 0; i < numPointsY - 1; i++) this.springs.push(new Spring(gridPoints[i][j], gridPoints[i+1][j], this.stiffness, this.springDamping));
                    for (let i = 0; i < numPointsY - 1; i++) for (let j = 0; j < numPointsX - 1; j++) {
                        this.springs.push(new Spring(gridPoints[i][j], gridPoints[i+1][j+1], this.stiffness * 0.7, this.springDamping));
                        this.springs.push(new Spring(gridPoints[i+1][j], gridPoints[i][j+1], this.stiffness * 0.7, this.springDamping));
                    }
                } else if (shapeType === 1) { // Line
                    const numLinePoints = Math.floor(3 + Math.random() * 3); // 3 to 5 points
                    const isHorizontal = Math.random() < 0.5;
                    let linePoints = [];
                    for (let i = 0; i < numLinePoints; i++) {
                        const x = startX + (isHorizontal ? i * basePointDist : 0);
                        const y = startY + (isHorizontal ? 0 : i * basePointDist);
                        const point = new MassPoint(x, y, mass, radius);
                        this.massPoints.push(point);
                        linePoints.push(point);
                    }
                    for (let i = 0; i < numLinePoints - 1; i++) {
                        this.springs.push(new Spring(linePoints[i], linePoints[i+1], this.stiffness, this.springDamping));
                    }
                    if (numLinePoints > 2) { // Add a longer spring for stability
                         this.springs.push(new Spring(linePoints[0], linePoints[numLinePoints-1], this.stiffness * 0.5, this.springDamping));
                    }
                    if (linePoints.length > 0) {
                        this.motorNode = linePoints[Math.floor(linePoints.length / 2)]; // Middle point as motor
                        this.motorNode.isMotorNode = true;
                        this.eaterNode = linePoints[0]; // One end as eater
                        this.eaterNode.isEaterNode = true;
                    }
                } else { // Circle/Blob
                    const numOuterPoints = Math.floor(4 + Math.random() * 3); // 4 to 6 outer points
                    const centralPoint = new MassPoint(startX, startY, mass * 1.5, radius * 1.2); // Heavier center
                    this.massPoints.push(centralPoint);
                    this.motorNode = centralPoint;
                    this.motorNode.isMotorNode = true;
                    this.eaterNode = centralPoint; // Center can also be eater
                    this.eaterNode.isEaterNode = true;

                    const circleRadius = basePointDist * 1.5;
                    for (let i = 0; i < numOuterPoints; i++) {
                        const angle = (i / numOuterPoints) * Math.PI * 2;
                        const x = startX + Math.cos(angle) * circleRadius;
                        const y = startY + Math.sin(angle) * circleRadius;
                        const point = new MassPoint(x, y, mass, radius);
                        this.massPoints.push(point);
                        this.springs.push(new Spring(centralPoint, point, this.stiffness, this.springDamping));
                        // Connect to previous outer point
                        if (i > 0) {
                            this.springs.push(new Spring(this.massPoints[this.massPoints.length-2], point, this.stiffness * 0.8, this.springDamping));
                        }
                    }
                    // Connect last outer point to first outer point
                    if (numOuterPoints > 1) {
                         this.springs.push(new Spring(this.massPoints[1], this.massPoints[this.massPoints.length-1], this.stiffness * 0.8, this.springDamping));
                    }
                }
            }


            updateSelf(dt, fluidFieldRef) {
                if (this.isUnstable) return;

                if (fluidFieldRef && this.isMotorActive && this.motorNode && !this.motorNode.isFixed && this.motorStrength > 0.0001) {
                    const motorForceDirection = new Vec2(1, 0); 
                    const motorPushVx = motorForceDirection.x * this.motorStrength;
                    const motorPushVy = motorForceDirection.y * this.motorStrength;
                    const fluidGridX = Math.floor(this.motorNode.pos.x / fluidFieldRef.scale);
                    const fluidGridY = Math.floor(this.motorNode.pos.y / fluidFieldRef.scale);
                    fluidFieldRef.addVelocity(fluidGridX, fluidGridY, motorPushVx, motorPushVy);
                    fluidFieldRef.addDensity(fluidGridX, fluidGridY, 50, 150, 50, 10); 
                }

                if (fluidFieldRef) {
                    for (let point of this.massPoints) {
                        if (!point.isFixed) {
                            const fluidGridX = Math.floor(point.pos.x / fluidFieldRef.scale);
                            const fluidGridY = Math.floor(point.pos.y / fluidFieldRef.scale);
                            const idx = fluidFieldRef.IX(fluidGridX, fluidGridY);
                            const rawFluidVx = fluidFieldRef.Vx[idx]; 
                            const rawFluidVy = fluidFieldRef.Vy[idx]; 
                            let fluidDisplacementPx = new Vec2(rawFluidVx * fluidFieldRef.scale, rawFluidVy * fluidFieldRef.scale);
                            let effectiveFluidDisplacementPx = fluidDisplacementPx.mul(this.fluidCurrentStrength);
                            let currentPointDisplacementPx = point.pos.sub(point.prevPos);
                            let blendedDisplacementPx = currentPointDisplacementPx.mul(1.0 - this.fluidEntrainment)
                                                             .add(effectiveFluidDisplacementPx.mul(this.fluidEntrainment));
                            point.prevPos = point.pos.clone().sub(blendedDisplacementPx);
                        }
                    }
                }
                
                for (let spring of this.springs) spring.applyForce();
                for (let point of this.massPoints) point.update(dt); 
                
                for (let point of this.massPoints) {
                    const displacementSq = point.pos.sub(point.prevPos).magSq();
                    if (displacementSq > MAX_DISPLACEMENT_SQ_THRESHOLD || 
                        isNaN(point.pos.x) || isNaN(point.pos.y) ||
                        !isFinite(point.pos.x) || !isFinite(point.pos.y)) {
                        this.isUnstable = true;
                        console.warn(`Soft body ID ${this.id} instability detected!`, point);
                        break; 
                    }
                }

                if (!this.isUnstable && this.eaterNode && !this.eaterNode.isFixed) {
                    const eatingRadius = this.eaterNode.radius * EATING_RADIUS_MULTIPLIER;
                    const eatingRadiusSq = eatingRadius * eatingRadius;
                    for (let particle of particles) { 
                        if (particle.life > 0 && !particle.isEaten) {
                            const distSq = this.eaterNode.pos.sub(particle.pos).magSq();
                            if (distSq < eatingRadiusSq) {
                                particle.isEaten = true; 
                                particle.life = 0; 
                                this.creatureEnergy = Math.min(MAX_CREATURE_ENERGY, this.creatureEnergy + ENERGY_PER_PARTICLE);
                            }
                        }
                    }
                }

                if (!this.isUnstable) {
                    for (let point of this.massPoints) { 
                        if (point.isFixed) continue;
                        const implicitVelX = point.pos.x - point.prevPos.x; 
                        const implicitVelY = point.pos.y - point.prevPos.y;
                        if (point.pos.x - point.radius < 0) { point.pos.x = point.radius; point.prevPos.x = point.pos.x + implicitVelX * restitution; } 
                        else if (point.pos.x + point.radius > canvas.width) { point.pos.x = canvas.width - point.radius; point.prevPos.x = point.pos.x + implicitVelX * restitution; }
                        if (point.pos.y - point.radius < 0) { point.pos.y = point.radius; point.prevPos.y = point.pos.y + implicitVelY * restitution; } 
                        else if (point.pos.y + point.radius > canvas.height) { point.pos.y = canvas.height - point.radius; point.prevPos.y = point.pos.y + implicitVelY * restitution; }
                    }
                }
            }

            drawSelf(ctx) {
                if (this.isUnstable) return; 
                for (let spring of this.springs) spring.draw(ctx);
                for (let point of this.massPoints) point.draw(ctx);
            }
        }


        // --- FluidField Class (Simplified) ---
        class FluidField {
            constructor(size, diffusion, viscosity, dt, scale) {
                this.size = size; 
                this.dt = dt;
                this.diffusion = diffusion; 
                this.viscosity = viscosity; 
                this.scale = scale; 

                this.densityR = new Float32Array(size * size).fill(0);
                this.densityG = new Float32Array(size * size).fill(0);
                this.densityB = new Float32Array(size * size).fill(0);
                this.densityR0 = new Float32Array(size * size).fill(0);
                this.densityG0 = new Float32Array(size * size).fill(0);
                this.densityB0 = new Float32Array(size * size).fill(0);
                
                this.Vx = new Float32Array(size * size).fill(0); 
                this.Vy = new Float32Array(size * size).fill(0); 
                this.Vx0 = new Float32Array(size * size).fill(0); 
                this.Vy0 = new Float32Array(size * size).fill(0); 
                
                this.iterations = 4; 
            }

            IX(x, y) { 
                x = Math.max(0, Math.min(x, this.size - 1));
                y = Math.max(0, Math.min(y, this.size - 1));
                return Math.floor(x) + Math.floor(y) * this.size;
            }

            addDensity(x, y, r, g, b, amount) {
                const idx = this.IX(x,y);
                this.densityR[idx] = Math.min(255, this.densityR[idx] + r * (amount/255));
                this.densityG[idx] = Math.min(255, this.densityG[idx] + g * (amount/255));
                this.densityB[idx] = Math.min(255, this.densityB[idx] + b * (amount/255));
            }

            addVelocity(x, y, amountX, amountY) {
                const idx = this.IX(x, y);
                this.Vx[idx] += amountX;
                this.Vy[idx] += amountY;
            }
            
            lin_solve(b, x, x0, a, c) {
                const cRecip = 1.0 / c;
                for (let k = 0; k < this.iterations; k++) {
                    for (let j = 1; j < this.size - 1; j++) {
                        for (let i = 1; i < this.size - 1; i++) {
                            x[this.IX(i, j)] =
                                (x0[this.IX(i, j)] +
                                a * (x[this.IX(i + 1, j)] + x[this.IX(i - 1, j)] +
                                     x[this.IX(i, j + 1)] + x[this.IX(i, j - 1)])) *
                                cRecip;
                        }
                    }
                    this.set_bnd(b, x);
                }
            }

            diffuse(b, x_out, x_in, diff_rate, dt) { 
                const a = dt * diff_rate * (this.size - 2) * (this.size - 2);
                this.lin_solve(b, x_out, x_in, a, 1 + 4 * a);
            }
            
            project(velocX_in_out, velocY_in_out, p_temp, div_temp) { 
                for (let j = 1; j < this.size - 1; j++) {
                    for (let i = 1; i < this.size - 1; i++) {
                        div_temp[this.IX(i, j)] = -0.5 * (
                            velocX_in_out[this.IX(i + 1, j)] - velocX_in_out[this.IX(i - 1, j)] +
                            velocY_in_out[this.IX(i, j + 1)] - velocY_in_out[this.IX(i, j - 1)]
                        ) / this.size;
                        p_temp[this.IX(i, j)] = 0;
                    }
                }
                this.set_bnd(0, div_temp);
                this.set_bnd(0, p_temp);
                this.lin_solve(0, p_temp, div_temp, 1, 4); 

                for (let j = 1; j < this.size - 1; j++) {
                    for (let i = 1; i < this.size - 1; i++) {
                        velocX_in_out[this.IX(i, j)] -= 0.5 * (p_temp[this.IX(i + 1, j)] - p_temp[this.IX(i - 1, j)]) * this.size;
                        velocY_in_out[this.IX(i, j)] -= 0.5 * (p_temp[this.IX(i, j + 1)] - p_temp[this.IX(i, j - 1)]) * this.size;
                    }
                }
                this.set_bnd(1, velocX_in_out);
                this.set_bnd(2, velocY_in_out);
            }

            advect(b, d_out, d_in, velocX_source, velocY_source, dt) { 
                let i0, i1, j0, j1;
                const dtx = dt * (this.size - 2); 
                const dty = dt * (this.size - 2);
                let s0, s1, t0, t1;
                let tmp1, tmp2, x, y;

                for (let j = 1; j < this.size - 1; j++) {
                    for (let i = 1; i < this.size - 1; i++) {
                        tmp1 = dtx * velocX_source[this.IX(i, j)];
                        tmp2 = dty * velocY_source[this.IX(i, j)];
                        x = i - tmp1; 
                        y = j - tmp2;

                        if (x < 0.5) x = 0.5;
                        if (x > this.size - 1.5) x = this.size - 1.5; 
                        i0 = Math.floor(x);
                        i1 = i0 + 1.0;
                        
                        if (y < 0.5) y = 0.5;
                        if (y > this.size - 1.5) y = this.size - 1.5; 
                        j0 = Math.floor(y);
                        j1 = j0 + 1.0;

                        s1 = x - i0; s0 = 1.0 - s1;
                        t1 = y - j0; t0 = 1.0 - t1;

                        d_out[this.IX(i, j)] =
                            s0 * (t0 * d_in[this.IX(i0, j0)] + t1 * d_in[this.IX(i0, j1)]) +
                            s1 * (t0 * d_in[this.IX(i1, j0)] + t1 * d_in[this.IX(i1, j1)]);
                    }
                }
                this.set_bnd(b, d_out);
            }

            set_bnd(b, x) { 
                for (let i = 1; i < this.size - 1; i++) {
                    x[this.IX(i, 0)] = b === 2 ? -x[this.IX(i, 1)] : x[this.IX(i, 1)];
                    x[this.IX(i, this.size - 1)] = b === 2 ? -x[this.IX(i, this.size - 2)] : x[this.IX(i, this.size - 2)];
                }
                for (let j = 1; j < this.size - 1; j++) {
                    x[this.IX(0, j)] = b === 1 ? -x[this.IX(1, j)] : x[this.IX(1, j)];
                    x[this.IX(this.size - 1, j)] = b === 1 ? -x[this.IX(this.size - 2, j)] : x[this.IX(this.size - 2, j)];
                }
                x[this.IX(0, 0)] = 0.5 * (x[this.IX(1, 0)] + x[this.IX(0, 1)]);
                x[this.IX(0, this.size - 1)] = 0.5 * (x[this.IX(1, this.size - 1)] + x[this.IX(0, this.size - 2)]);
                x[this.IX(this.size - 1, 0)] = 0.5 * (x[this.IX(this.size - 2, 0)] + x[this.IX(this.size - 1, 1)]);
                x[this.IX(this.size - 1, this.size - 1)] = 0.5 * (x[this.IX(this.size - 2, this.size - 1)] + x[this.IX(this.size - 1, this.size - 2)]);
            }
            
            step() {
                this.diffuse(1, this.Vx0, this.Vx, this.viscosity, this.dt);
                this.diffuse(2, this.Vy0, this.Vy, this.viscosity, this.dt);
                this.project(this.Vx0, this.Vy0, this.Vx, this.Vy); 
                this.advect(1, this.Vx, this.Vx0, this.Vx0, this.Vy0, this.dt);
                this.advect(2, this.Vy, this.Vy0, this.Vx0, this.Vy0, this.dt);
                this.project(this.Vx, this.Vy, this.Vx0, this.Vy0);
                this.diffuse(0, this.densityR0, this.densityR, this.diffusion, this.dt);
                this.diffuse(0, this.densityG0, this.densityG, this.diffusion, this.dt);
                this.diffuse(0, this.densityB0, this.densityB, this.diffusion, this.dt);
                this.advect(0, this.densityR, this.densityR0, this.Vx, this.Vy, this.dt);
                this.advect(0, this.densityG, this.densityG0, this.Vx, this.Vy, this.dt);
                this.advect(0, this.densityB, this.densityB0, this.Vx, this.Vy, this.dt);

                for (let i = 0; i < this.densityR.length; i++) {
                    this.densityR[i] = Math.max(0, this.densityR[i] - FLUID_FADE_RATE * 255 * this.dt);
                    this.densityG[i] = Math.max(0, this.densityG[i] - FLUID_FADE_RATE * 255 * this.dt);
                    this.densityB[i] = Math.max(0, this.densityB[i] - FLUID_FADE_RATE * 255 * this.dt);
                }
            }

            draw(ctx) {
                for (let y = 0; y < this.size; y++) {
                    for (let x = 0; x < this.size; x++) {
                        const idx = this.IX(x, y);
                        const r = Math.min(255, Math.max(0, Math.floor(this.densityR[idx])));
                        const g = Math.min(255, Math.max(0, Math.floor(this.densityG[idx])));
                        const b = Math.min(255, Math.max(0, Math.floor(this.densityB[idx])));
                        if (r > 1 || g > 1 || b > 1) { 
                             ctx.fillStyle = `rgb(${r},${g},${b})`;
                             ctx.fillRect(x * this.scale, y * this.scale, this.scale, this.scale);
                        }
                    }
                }
            }
            clear() {
                this.densityR.fill(0); this.densityG.fill(0); this.densityB.fill(0);
                this.densityR0.fill(0); this.densityG0.fill(0); this.densityB0.fill(0);
                this.Vx.fill(0); this.Vy.fill(0);
                this.Vx0.fill(0); this.Vy0.fill(0);
            }
        }


        // --- Particle Class (for fluid visualization) ---
        class Particle {
            constructor(x, y, fluidFieldRef) {
                this.pos = new Vec2(x, y);
                this.vel = new Vec2(Math.random() * 0.2 - 0.1, Math.random() * 0.2 - 0.1); 
                this.fluidField = fluidFieldRef;
                this.life = 1.0; 
                this.lifeDecay = PARTICLE_BASE_LIFE_DECAY + Math.random() * PARTICLE_LIFE_DECAY_RANDOM_FACTOR;
                this.size = Math.random() * 1.5 + 0.5;
                this.isEaten = false; 
            }

            update(dt) {
                if (this.isEaten) { 
                    this.life -= 0.1 * dt * 60; 
                     if (this.life <= 0) this.respawn();
                    return;
                }

                if (!this.fluidField) return; 
                const fluidGridX = Math.floor(this.pos.x / this.fluidField.scale);
                const fluidGridY = Math.floor(this.pos.y / this.fluidField.scale);
                const idx = this.fluidField.IX(fluidGridX, fluidGridY);

                const fluidVelX = this.fluidField.Vx[idx];
                const fluidVelY = this.fluidField.Vy[idx];

                this.vel.x = this.vel.x * (1.0 - PARTICLE_FLUID_INFLUENCE) + fluidVelX * PARTICLE_FLUID_INFLUENCE;
                this.vel.y = this.vel.y * (1.0 - PARTICLE_FLUID_INFLUENCE) + fluidVelY * PARTICLE_FLUID_INFLUENCE;
                this.vel.x += (Math.random() - 0.5) * 0.05;
                this.vel.y += (Math.random() - 0.5) * 0.05;

                this.pos = this.pos.add(this.vel.mul(dt * 100)); 

                if (this.pos.x < 0) { this.pos.x = canvas.width; if (!IS_PARTICLE_LIFE_INFINITE) this.life = 0;} 
                if (this.pos.x > canvas.width) { this.pos.x = 0; if (!IS_PARTICLE_LIFE_INFINITE) this.life = 0;}
                if (this.pos.y < 0) { this.pos.y = canvas.height; if (!IS_PARTICLE_LIFE_INFINITE) this.life = 0;}
                if (this.pos.y > canvas.height) { this.pos.y = 0; if (!IS_PARTICLE_LIFE_INFINITE) this.life = 0;}
                
                if (!IS_PARTICLE_LIFE_INFINITE) {
                    this.life -= (PARTICLE_BASE_LIFE_DECAY + Math.random() * PARTICLE_LIFE_DECAY_RANDOM_FACTOR) * dt * 60; 
                    if (this.life <=0) { 
                       this.respawn();
                    }
                } else {
                    this.life = 1.0; 
                }
            }
            
            respawn() {
                this.pos.x = Math.random() * canvas.width;
                this.pos.y = Math.random() * canvas.height;
                this.vel = new Vec2(Math.random() * 0.2 - 0.1, Math.random() * 0.2 - 0.1);
                this.life = 1.0  + Math.random() * 0.5; 
                this.isEaten = false;
            }

            draw(ctx) {
                const alpha = IS_PARTICLE_LIFE_INFINITE ? 0.7 : Math.max(0, this.life * 0.7); 
                if (alpha <= 0.01 && !IS_PARTICLE_LIFE_INFINITE) return; 
                ctx.fillStyle = `rgba(220, 220, 250, ${alpha})`; 
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }


        // --- Simulation Setup ---
        function initializePopulation() {
            softBodyPopulation = [];
            isAnySoftBodyUnstable = false; 
            updateInstabilityIndicator();

            for (let i = 0; i < TARGET_POPULATION_SIZE; i++) {
                const margin = 50;
                const randX = margin + Math.random() * (canvas.width - margin * 2);
                const randY = margin + Math.random() * (canvas.height - margin * 2);
                softBodyPopulation.push(new SoftBody(nextSoftBodyId++, randX, randY));
            }
            lastTime = performance.now();
        }


        function initFluidSimulation() {
            const fluidGridSize = 64; 
            const fluidScale = canvas.width / fluidGridSize; 
            fluidField = new FluidField(fluidGridSize, FLUID_DIFFUSION, FLUID_VISCOSITY, 1/60, fluidScale); 
        }

        function initParticles() {
            particles = [];
            if (!fluidField) { 
                console.warn("Fluid field not initialized when trying to create particles. Initializing now.");
                initFluidSimulation();
            }
            for (let i = 0; i < NUM_PARTICLES; i++) {
                particles.push(new Particle(Math.random() * canvas.width, Math.random() * canvas.height, fluidField));
            }
        }


        // --- Physics Update ---
        function updatePhysics(dt) {
            if (fluidField) {
                fluidField.dt = dt; 
                fluidField.step();
            }

            for (let particle of particles) {
                particle.update(dt);
            }
            
            let currentAnyUnstable = false;
            for (let i = softBodyPopulation.length - 1; i >= 0; i--) {
                const body = softBodyPopulation[i];
                if (!body.isUnstable) {
                    body.updateSelf(dt, fluidField);
                    if (body.isUnstable) {
                        currentAnyUnstable = true;
                    }
                }
            }
            if(currentAnyUnstable && !isAnySoftBodyUnstable) { 
                isAnySoftBodyUnstable = true;
                updateInstabilityIndicator();
            }


            if (selectedSoftBodyPoint && selectedSoftBodyPoint.point.isFixed && fluidField) { 
                const activeBody = selectedSoftBodyPoint.body;
                for (let point of activeBody.massPoints) { 
                    const displacementX = point.pos.x - point.prevPos.x; 
                    const displacementY = point.pos.y - point.prevPos.y;
                    const movementMagnitudeSq = displacementX*displacementX + displacementY*displacementY;
                    const movementThresholdSq = 0.01 * 0.01; 

                    if (movementMagnitudeSq > movementThresholdSq) {
                        const fluidGridX = Math.floor(point.pos.x / fluidField.scale);
                        const fluidGridY = Math.floor(point.pos.y / fluidField.scale);
                        
                        fluidField.addVelocity(fluidGridX, fluidGridY, 
                                               displacementX * activeBody.bodyPushStrength, 
                                               displacementY * activeBody.bodyPushStrength);
                        fluidField.addDensity(fluidGridX, fluidGridY, 60, 60, 80, 15); 
                    }
                }
            }
            
            let removedCount = 0;
            for (let i = softBodyPopulation.length - 1; i >= 0; i--) {
                if (softBodyPopulation[i].isUnstable) {
                    softBodyPopulation.splice(i, 1);
                    removedCount++;
                }
            }
            for (let i = 0; i < removedCount; i++) {
                 const margin = 50;
                 const randX = margin + Math.random() * (canvas.width - margin * 2);
                 const randY = margin + Math.random() * (canvas.height - margin * 2);
                 softBodyPopulation.push(new SoftBody(nextSoftBodyId++, randX, randY));
            }
            if (removedCount > 0 && !softBodyPopulation.some(b => b.isUnstable)) {
                isAnySoftBodyUnstable = false;
                updateInstabilityIndicator();
            }


            draw(); 
            requestAnimationFrame(gameLoop);
        }

        // --- Drawing ---
        function draw() {
            ctx.fillStyle = '#222'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (fluidField) {
                fluidField.draw(ctx);
            }
            for (let particle of particles) {
                particle.draw(ctx);
            }
            for (let body of softBodyPopulation) {
                body.drawSelf(ctx);
            }
        }

        // --- Game Loop ---
        function gameLoop(timestamp) {
            deltaTime = (timestamp - lastTime) / 1000;
            if (isNaN(deltaTime) || deltaTime <= 0) deltaTime = 1/60; 
            lastTime = timestamp;
            const maxDeltaTime = 1/30; 
            deltaTime = Math.min(deltaTime, maxDeltaTime);

            updatePhysics(deltaTime); 
        }

        // Start the simulation
        initializeAllSliderDisplays(); 
        initializePopulation(); 
        initFluidSimulation(); 
        initParticles();
        updateInstabilityIndicator(); 
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
