<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Soft Body Evolution - Simplified Motors & Costs</title>
    <style>
        body {
            margin: 0;
            overflow-y: auto;
            background-color: #111;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            font-family: sans-serif;
            color: #eee;
            padding: 10px 0;
            box-sizing: border-box;
        }
        #pageContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }
        #simulationAndInfoWrapper {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: flex-start;
            gap: 15px;
            width: 100%;
            max-width: 1150px;
            margin-top: 10px;
        }
        canvas {
            border: 1px solid #444;
            background-color: #222;
            cursor: default;
        }
        canvas.emitter-edit-mode {
            cursor: crosshair;
        }
        #controls {
            background-color: rgba(50,50,50,0.8);
            padding: 10px;
            border-radius: 8px;
            margin-bottom:10px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            max-width: 800px;
            width: calc(100% - 20px);
            box-sizing: border-box;
            justify-content: center;
        }
        #controls div.control-group {
            padding: 10px;
            border: 1px solid #555;
            border-radius: 6px;
            background-color: rgba(40,40,40,0.7);
            flex-grow: 1;
            min-width: 150px;
            max-width: 210px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        #controls label.slider-label, #controls label.checkbox-label {
            display: block;
            margin-bottom: 2px;
            font-size: 0.85em;
            font-weight: bold;
            color: #ddd;
            text-align: left;
        }
        #controls label.checkbox-label {
            margin-top: 8px;
            display: flex;
            align-items: center;
        }
        #controls input[type="checkbox"] {
            margin-left: 5px;
        }
        #controls span.slider-value {
            display: block;
            font-size: 0.8em;
            text-align: right;
            color: #00aeff;
            margin-bottom: 3px;
            min-height: 1em;
        }
        #controls input[type="range"] {
            width: 100%;
            margin-top: 0;
            box-sizing: border-box;
        }
        #controls input[type="range"]:disabled + span.slider-value,
        #controls input[type="range"]:disabled ~ label.slider-label,
        #controls input[type="range"]:disabled {
             color: #777;
             opacity: 0.6;
        }
        #controls button {
            padding: 8px 12px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 8px;
            width: 100%;
            box-sizing: border-box;
        }
        #controls button:hover {
            background-color: #0056b3;
        }
        .control-group h4 {
            margin-top: 0;
            margin-bottom: 10px;
            text-align: center;
            color: #00aeff;
            width: 100%;
            font-size: 1em;
        }
        .indicator-label {
            font-size: 0.85em;
            color: #ddd;
            margin-top: 8px;
        }
        .indicator-light {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #4CAF50; /* Green by default */
            margin-left: 5px;
            vertical-align: middle;
            border: 1px solid #222;
            transition: background-color 0.3s;
        }
        .indicator-light.unstable {
            background-color: #F44336; /* Red when unstable */
        }
        #populationCount {
            margin-top: 10px;
            font-size: 0.9em;
            color: #ccc;
            text-align: center;
            width: 100%;
        }
        .viewport-instructions {
            font-size: 0.8em;
            color: #bbb;
            text-align: center;
            margin-top: 5px;
        }
        #infoPanel {
            width: 280px;
            max-height: 580px;
            background-color: rgba(30,30,30,0.95);
            border: 1px solid #555;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            z-index: 100;
            color: #eee;
            font-size: 0.8em;
            display: none;
            overflow-y: auto;
            box-sizing: border-box;
            position: relative;
        }
        #infoPanel h5 {
            margin-top: 0;
            margin-bottom: 8px;
            color: #00aeff;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }
        #infoPanel p {
            margin: 3px 0;
            line-height: 1.4;
        }
        #infoPanel strong {
            color: #bbb;
        }
        #infoPanel .info-section {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px dashed #333;
        }
        #infoPanel .info-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        #closeInfoPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #555;
            color: white;
            border: none;
            padding: 3px 7px;
            cursor: pointer;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="pageContainer">
        <div id="controls">
            <div class="control-group">
                <h4>Viewport & Sim</h4>
                <div class="viewport-instructions">Use WASD to Pan View</div>
                <label for="worldWrapToggle" class="checkbox-label">Wrap Edges:
                    <input type="checkbox" id="worldWrapToggle">
                </label>
                <label for="maxTimestep" class="slider-label">Max Timestep (ms):</label>
                <span id="maxTimestepValue" class="slider-value">33</span>
                <input type="range" id="maxTimestep" min="10" max="100" value="33" step="1">
                <button id="pauseResumeButton">Pause</button>
            </div>
            <div class="control-group">
                <h4>Soft Body (Global)</h4>
                <label for="bodyFluidEntrainment" class="slider-label">Fluid Entrainment (Floaters):</label>
                <span id="bodyFluidEntrainmentValue" class="slider-value">0.05</span>
                <input type="range" id="bodyFluidEntrainment" min="0.0" max="0.5" value="0.05" step="0.005">

                <label for="fluidCurrentStrength" class="slider-label">Fluid Current Str (Floaters):</label>
                <span id="fluidCurrentStrengthValue" class="slider-value">10.0</span>
                <input type="range" id="fluidCurrentStrength" min="0.0" max="25.0" value="10.0" step="0.1">

                <label for="bodyPushStrength" class="slider-label">Body Push Strength (Manual Drag):</label>
                <span id="bodyPushStrengthValue" class="slider-value">2.0</span>
                <input type="range" id="bodyPushStrength" min="0.0" max="10.0" value="2.0" step="0.1">

                <label for="reproductionCooldown" class="slider-label">Repro. Cooldown (frames):</label>
                <span id="reproductionCooldownValue" class="slider-value">300</span>
                <input type="range" id="reproductionCooldown" min="50" max="1000" value="300" step="10">

                <label for="bodyRepulsionStrength" class="slider-label">Body Repulsion Str:</label>
                <span id="bodyRepulsionStrengthValue" class="slider-value">0.5</span>
                <input type="range" id="bodyRepulsionStrength" min="0.0" max="50.0" value="0.5" step="0.1">

                <label for="bodyRepulsionRadiusFactor" class="slider-label">Body Repulsion Radius Factor:</label>
                <span id="bodyRepulsionRadiusFactorValue" class="slider-value">1.5</span>
                <input type="range" id="bodyRepulsionRadiusFactor" min="0.5" max="3.0" value="1.5" step="0.1">

                <div class="indicator-label">Any Unstable: <span id="instabilityLight" class="indicator-light"></span></div>
                <div id="populationCount">Population: 0</div>
                <button id="resetButton">Reset Population</button>
            </div>
            <div class="control-group">
                <h4>Energy Costs / Frame</h4>
                <label for="baseNodeCost" class="slider-label">Base Node Cost:</label>
                <span id="baseNodeCostValue" class="slider-value">0.0010</span>
                <input type="range" id="baseNodeCost" min="0.0" max="0.01" value="0.001" step="0.0001">

                <label for="eaterNodeCost" class="slider-label">Eater Node Cost:</label>
                <span id="eaterNodeCostValue" class="slider-value">0.0050</span>
                <input type="range" id="eaterNodeCost" min="0.0" max="0.05" value="0.005" step="0.0005">

                <label for="predatorNodeCost" class="slider-label">Predator Node Cost:</label>
                <span id="predatorNodeCostValue" class="slider-value">0.0200</span>
                <input type="range" id="predatorNodeCost" min="0.0" max="100.0" value="0.02" step="0.001">
            </div>
            <div class="control-group">
                <h4>Fluid</h4>
                <label for="fluidDiffusion" class="slider-label">Diffusion:</label>
                <span id="fluidDiffusionValue" class="slider-value">1.0e-5</span>
                <input type="range" id="fluidDiffusion" min="0" max="0.001" value="0.00001" step="0.00001">

                <label for="fluidViscosity" class="slider-label">Viscosity:</label>
                <span id="fluidViscosityValue" class="slider-value">1.0e-6</span>
                <input type="range" id="fluidViscosity" min="0" max="0.0001" value="0.000068" step="0.000001">

                <label for="fluidFade" class="slider-label">Fade Rate:</label>
                <span id="fluidFadeValue" class="slider-value">0.030</span>
                <input type="range" id="fluidFade" min="0.001" max="0.1" value="0.03" step="0.001">
                <button id="clearFluidButton">Clear Fluid</button>
            </div>
            <div class="control-group">
                <h4>Particles</h4>
                <label for="numParticles" class="slider-label">Particles:</label>
                <span id="numParticlesValue" class="slider-value">1110</span>
                <input type="range" id="numParticles" min="0" max="2500" value="1110" step="10">

                <label for="particleFluidInfluence" class.slider-label="slider-label">Fluid Influence:</label>
                <span id="particleFluidInfluenceValue" class="slider-value">1.0</span>
                <input type="range" id="particleFluidInfluence" min="0.0" max="1.0" value="0.97" step="0.01">

                <label for="particleLifeDecay" id="particleLifeDecayLabel" class="slider-label">Life Decay Rate:</label>
                <span id="particleLifeDecayValue" class="slider-value">0.0050</span>
                <input type="range" id="particleLifeDecay" min="0.0001" max="0.02" value="0.005" step="0.0001">

                <label for="infiniteParticleLifeToggle" class="checkbox-label">Infinite Life:
                    <input type="checkbox" id="infiniteParticleLifeToggle">
                </label>

                <button id="resetParticlesButton">Reset Particles</button>
            </div>
            <div class="control-group">
                <h4>Env. Emitters</h4>
                <label for="emitterEditModeToggle" class="checkbox-label">Edit Emitters:
                    <input type="checkbox" id="emitterEditModeToggle">
                </label>
                <label for="emitterStrength" class="slider-label">Emitter Strength:</label>
                <span id="emitterStrengthValue" class="slider-value">1.0</span>
                <input type="range" id="emitterStrength" min="0.0" max="5.0" value="1.0" step="0.1">
                <button id="clearEmittersButton">Clear Emitters</button>
            </div>
            <div class="control-group">
                <h4>Configuration</h4>
                <button id="exportConfigButton">Export Config</button>
                <input type="file" id="importConfigFile" accept=".json" style="display: none;">
                <button id="importConfigButton">Import Config</button>
            </div>
        </div>
        <div id="simulationAndInfoWrapper">
            <div id="infoPanel">
                <button id="closeInfoPanel">X</button>
                <div class="info-section">
                    <h5>Soft Body Info</h5>
                    <p><strong>ID:</strong> <span id="infoBodyId">-</span></p>
                    <p><strong>Stiffness:</strong> <span id="infoBodyStiffness">-</span></p>
                    <p><strong>Damping:</strong> <span id="infoBodyDamping">-</span></p>
                    <p><strong>Motor Impulse Interval:</strong> <span id="infoBodyMotorInterval">-</span></p>
                    <p><strong>Motor Impulse Cap:</strong> <span id="infoBodyMotorCap">-</span></p>
                    <p><strong>Emitter Strength:</strong> <span id="infoBodyEmitterStrength">-</span></p>
                    <p><strong>Emitter Direction:</strong> X: <span id="infoBodyEmitterDirX">-</span>, Y: <span id="infoBodyEmitterDirY">-</span></p>
                    <p><strong>Energy:</strong> <span id="infoBodyEnergy">-</span></p>
                    <p><strong>Ticks Since Birth:</strong> <span id="infoBodyTicksBirth">-</span></p>
                    <p><strong>Can Reproduce:</strong> <span id="infoBodyCanReproduce">-</span></p>
                    <p><strong>Shape Type:</strong> <span id="infoBodyShapeType">-</span></p>
                </div>
                <div class="info-section">
                    <h5>Mass Point Info</h5>
                    <p><strong>Index:</strong> <span id="infoPointIndex">-</span></p>
                    <p><strong>Node Type:</strong> <span id="infoPointNodeType">-</span></p>
                    <p><strong>Mass:</strong> <span id="infoPointMass">-</span></p>
                    <p><strong>Radius:</strong> <span id="infoPointRadius">-</span></p>
                    <p><strong>World Pos:</strong> X: <span id="infoPointPosX">-</span>, Y: <span id="infoPointPosY">-</span></p>
                    <p><strong>Is Eater:</strong> <span id="infoPointIsEater">-</span></p>
                    <p><strong>Is Predator:</strong> <span id="infoPointIsPredator">-</span></p>
                    <p><strong>Emits Dye:</strong> <span id="infoPointEmitsDye">-</span></p>
                    <p><strong>Dye Color:</strong> <span id="infoPointDyeColor">-</span></p>
                </div>
            </div>
            <canvas id="simulationCanvas"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');

        // --- Viewport and World Dimensions ---
        const VIEWPORT_WIDTH = 800;
        const VIEWPORT_HEIGHT = 600;
        const WORLD_WIDTH = 1600;
        const WORLD_HEIGHT = 1200;
        const VIEW_PAN_SPEED = 20;

        canvas.width = VIEWPORT_WIDTH;
        canvas.height = VIEWPORT_HEIGHT;

        let viewOffsetX = 0;
        let viewOffsetY = 0;

        // --- Controls ---
        const worldWrapToggle = document.getElementById('worldWrapToggle');
        const maxTimestepSlider = document.getElementById('maxTimestep');
        const maxTimestepValueSpan = document.getElementById('maxTimestepValue');
        const pauseResumeButton = document.getElementById('pauseResumeButton');

        const bodyFluidEntrainmentSlider = document.getElementById('bodyFluidEntrainment');
        const fluidCurrentStrengthSlider = document.getElementById('fluidCurrentStrength');
        const bodyPushStrengthSlider = document.getElementById('bodyPushStrength');
        const reproductionCooldownSlider = document.getElementById('reproductionCooldown');
        const bodyRepulsionStrengthSlider = document.getElementById('bodyRepulsionStrength');
        const bodyRepulsionRadiusFactorSlider = document.getElementById('bodyRepulsionRadiusFactor');
        const baseNodeCostSlider = document.getElementById('baseNodeCost');
        // const motorNodeCostSlider = document.getElementById('motorNodeCost'); // Removed
        const eaterNodeCostSlider = document.getElementById('eaterNodeCost');
        const predatorNodeCostSlider = document.getElementById('predatorNodeCost');
        const instabilityLight = document.getElementById('instabilityLight');
        const populationCountDisplay = document.getElementById('populationCount');
        const resetButton = document.getElementById('resetButton');
        const bodyFluidEntrainmentValueSpan = document.getElementById('bodyFluidEntrainmentValue');
        const fluidCurrentStrengthValueSpan = document.getElementById('fluidCurrentStrengthValue');
        const bodyPushStrengthValueSpan = document.getElementById('bodyPushStrengthValue');
        const reproductionCooldownValueSpan = document.getElementById('reproductionCooldownValue');
        const bodyRepulsionStrengthValueSpan = document.getElementById('bodyRepulsionStrengthValue');
        const bodyRepulsionRadiusFactorValueSpan = document.getElementById('bodyRepulsionRadiusFactorValue');
        const baseNodeCostValueSpan = document.getElementById('baseNodeCostValue');
        // const motorNodeCostValueSpan = document.getElementById('motorNodeCostValue'); // Removed
        const eaterNodeCostValueSpan = document.getElementById('eaterNodeCostValue');
        const predatorNodeCostValueSpan = document.getElementById('predatorNodeCostValue');


        const fluidDiffusionSlider = document.getElementById('fluidDiffusion');
        const fluidViscositySlider = document.getElementById('fluidViscosity');
        const fluidFadeSlider = document.getElementById('fluidFade');
        const clearFluidButton = document.getElementById('clearFluidButton');
        const fluidDiffusionValueSpan = document.getElementById('fluidDiffusionValue');
        const fluidViscosityValueSpan = document.getElementById('fluidViscosityValue');
        const fluidFadeValueSpan = document.getElementById('fluidFadeValue');

        const numParticlesSlider = document.getElementById('numParticles');
        const numParticlesValueSpan = document.getElementById('numParticlesValue');
        const particleFluidInfluenceSlider = document.getElementById('particleFluidInfluence');
        const particleFluidInfluenceValueSpan = document.getElementById('particleFluidInfluenceValue');
        const particleLifeDecaySlider = document.getElementById('particleLifeDecay');
        const particleLifeDecayValueSpan = document.getElementById('particleLifeDecayValue');
        const infiniteParticleLifeToggle = document.getElementById('infiniteParticleLifeToggle');
        const particleLifeDecayLabel = document.getElementById('particleLifeDecayLabel');
        const resetParticlesButton = document.getElementById('resetParticlesButton');

        const exportConfigButton = document.getElementById('exportConfigButton');
        const importConfigFile = document.getElementById('importConfigFile');
        const importConfigButton = document.getElementById('importConfigButton');

        const emitterEditModeToggle = document.getElementById('emitterEditModeToggle');
        const emitterStrengthSlider = document.getElementById('emitterStrength');
        const emitterStrengthValueSpan = document.getElementById('emitterStrengthValue');
        const clearEmittersButton = document.getElementById('clearEmittersButton');

        const infoPanel = document.getElementById('infoPanel');
        const closeInfoPanelButton = document.getElementById('closeInfoPanel');


        // --- Global Variables & Constants ---
        let BODY_FLUID_ENTRAINMENT_FACTOR = parseFloat(bodyFluidEntrainmentSlider.value);
        let FLUID_CURRENT_STRENGTH_ON_BODY = parseFloat(fluidCurrentStrengthSlider.value);
        let SOFT_BODY_PUSH_STRENGTH = parseFloat(bodyPushStrengthSlider.value);
        let REPRODUCTION_COOLDOWN_TICKS = parseInt(reproductionCooldownSlider.value);
        let BODY_REPULSION_STRENGTH = parseFloat(bodyRepulsionStrengthSlider.value);
        let BODY_REPULSION_RADIUS_FACTOR = parseFloat(bodyRepulsionRadiusFactorSlider.value);
        let MAX_DELTA_TIME_MS = parseInt(maxTimestepSlider.value);
        let IS_SIMULATION_PAUSED = false;
        let IS_EMITTER_EDIT_MODE = emitterEditModeToggle.checked;
        let EMITTER_STRENGTH = parseFloat(emitterStrengthSlider.value);
        const EMITTER_MOUSE_DRAG_SCALE = 0.05;

        let BASE_NODE_EXISTENCE_COST = parseFloat(baseNodeCostSlider.value);
        // let MOTOR_NODE_ENERGY_COST = parseFloat(motorNodeCostSlider.value); // Removed
        let EATER_NODE_ENERGY_COST = parseFloat(eaterNodeCostSlider.value);
        let PREDATOR_NODE_ENERGY_COST = parseFloat(predatorNodeCostSlider.value);


        let FLUID_DIFFUSION = parseFloat(fluidDiffusionSlider.value);
        let FLUID_VISCOSITY = parseFloat(fluidViscositySlider.value);
        let FLUID_FADE_RATE = parseFloat(fluidFadeSlider.value);
        let IS_WORLD_WRAPPING = worldWrapToggle.checked;
        let NUM_PARTICLES = parseInt(numParticlesSlider.value);
        let PARTICLE_FLUID_INFLUENCE = parseFloat(particleFluidInfluenceSlider.value);
        let PARTICLE_BASE_LIFE_DECAY = parseFloat(particleLifeDecaySlider.value);
        let IS_PARTICLE_LIFE_INFINITE = infiniteParticleLifeToggle.checked;
        const PARTICLE_LIFE_DECAY_RANDOM_FACTOR = 0.002;

        const EATING_RADIUS_MULTIPLIER = 3.5;
        const PREDATION_RADIUS_MULTIPLIER = 2.5;
        const ENERGY_PER_PARTICLE = 25;
        const ENERGY_SAPPED_PER_PREDATION = 5;
        const MAX_CREATURE_ENERGY = 100;
        const OFFSPRING_INITIAL_ENERGY_SHARE = 0.25;
        const REPRODUCTION_ADDITIONAL_COST_FACTOR = 0.1;
        const OFFSPRING_SPAWN_RADIUS = 70;
        const OFFSPRING_PLACEMENT_ATTEMPTS = 10;
        const OFFSPRING_PLACEMENT_CLEARANCE_RADIUS = 50;
        const MUTATION_RATE_PERCENT = 0.1;
        const MUTATION_CHANCE_BOOL = 0.05;
        const MUTATION_CHANCE_NODE_TYPE = 0.1;

        let isAnySoftBodyUnstable = false;
        const MAX_DISPLACEMENT_SQ_THRESHOLD = (WORLD_WIDTH / 5) * (WORLD_WIDTH / 5);
        const INITIAL_POPULATION_SIZE = 10;

        let velocityEmitters = [];
        let currentEmitterPreview = null;
        let emitterDragStartCell = null;
        let selectedInspectBody = null;
        let selectedInspectPoint = null;
        let selectedInspectPointIndex = -1;

        const NodeType = {
            NEUTRAL: 0,
            FLOATING: 1,
            FIXED_ROOT: 2,
            EMITTER_SWIMMER: 3
        };
        const DYE_COLORS = {
            RED: [200, 50, 50],
            GREEN: [50, 200, 50],
            BLUE: [50, 50, 200]
        };


        // Function to update slider value display
        function updateSliderDisplay(slider, span) {
            let value = parseFloat(slider.value);
            if (!slider || !span) return;

            if (slider.id === 'fluidDiffusion' || slider.id === 'fluidViscosity') {
                span.textContent = value.toExponential(1);
            } else if (slider.id === 'particleFluidInfluence' || slider.id === 'fluidCurrentStrength' ||
                       slider.id === 'bodyPushStrength' ||
                       slider.id === 'bodyRepulsionStrength' || slider.id === 'bodyRepulsionRadiusFactor' ||
                       slider.id === 'emitterStrength') {
                 span.textContent = value.toFixed(1);
            } else if (slider.id === 'bodyFluidEntrainment') {
                span.textContent = value.toFixed(2);
            } else if (slider.id === 'particleLifeDecay' ||
                       slider.id === 'baseNodeCost' || /*slider.id === 'motorNodeCost' ||*/ // Removed
                       slider.id === 'eaterNodeCost' || slider.id === 'predatorNodeCost') {
                span.textContent = value.toFixed(4);
            } else if (slider.id === 'fluidFade') {
                span.textContent = value.toFixed(3);
            }
            else {
                span.textContent = Math.floor(value);
            }
        }

        // --- Event Listeners ---
        document.addEventListener('keydown', (e) => {
            if (IS_SIMULATION_PAUSED && e.key.toLowerCase() !== 'p') return;
            switch(e.key.toLowerCase()) {
                case 'w': viewOffsetY = Math.max(0, viewOffsetY - VIEW_PAN_SPEED); break;
                case 's': viewOffsetY = Math.min(WORLD_HEIGHT - VIEWPORT_HEIGHT, viewOffsetY + VIEW_PAN_SPEED); break;
                case 'a': viewOffsetX = Math.max(0, viewOffsetX - VIEW_PAN_SPEED); break;
                case 'd': viewOffsetX = Math.min(WORLD_WIDTH - VIEWPORT_WIDTH, viewOffsetX + VIEW_PAN_SPEED); break;
                case 'p':
                    IS_SIMULATION_PAUSED = !IS_SIMULATION_PAUSED;
                    pauseResumeButton.textContent = IS_SIMULATION_PAUSED ? "Resume" : "Pause";
                    if (!IS_SIMULATION_PAUSED) {
                        lastTime = performance.now();
                        requestAnimationFrame(gameLoop);
                    }
                    break;
            }
        });


        worldWrapToggle.onchange = function() {
            IS_WORLD_WRAPPING = this.checked;
            if (fluidField) fluidField.useWrapping = IS_WORLD_WRAPPING;
        }
        maxTimestepSlider.oninput = function() { MAX_DELTA_TIME_MS = parseInt(this.value); updateSliderDisplay(this, maxTimestepValueSpan); }
        pauseResumeButton.onclick = function() {
            IS_SIMULATION_PAUSED = !IS_SIMULATION_PAUSED;
            this.textContent = IS_SIMULATION_PAUSED ? "Resume" : "Pause";
            if (!IS_SIMULATION_PAUSED) {
                lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            }
        }
        emitterEditModeToggle.onchange = function() {
            IS_EMITTER_EDIT_MODE = this.checked;
            canvas.classList.toggle('emitter-edit-mode', IS_EMITTER_EDIT_MODE);
            if (!IS_EMITTER_EDIT_MODE) {
                currentEmitterPreview = null;
                emitterDragStartCell = null;
            }
        }
        emitterStrengthSlider.oninput = function() { EMITTER_STRENGTH = parseFloat(this.value); updateSliderDisplay(this, emitterStrengthValueSpan); }
        clearEmittersButton.onclick = function() { velocityEmitters = []; }


        bodyFluidEntrainmentSlider.oninput = function() { BODY_FLUID_ENTRAINMENT_FACTOR = parseFloat(this.value); updateSliderDisplay(this, bodyFluidEntrainmentValueSpan); }
        fluidCurrentStrengthSlider.oninput = function() { FLUID_CURRENT_STRENGTH_ON_BODY = parseFloat(this.value); updateSliderDisplay(this, fluidCurrentStrengthValueSpan); }
        bodyPushStrengthSlider.oninput = function() { SOFT_BODY_PUSH_STRENGTH = parseFloat(this.value); updateSliderDisplay(this, bodyPushStrengthValueSpan); }
        reproductionCooldownSlider.oninput = function() { REPRODUCTION_COOLDOWN_TICKS = parseInt(this.value); updateSliderDisplay(this, reproductionCooldownValueSpan); }
        bodyRepulsionStrengthSlider.oninput = function() { BODY_REPULSION_STRENGTH = parseFloat(this.value); updateSliderDisplay(this, bodyRepulsionStrengthValueSpan); }
        bodyRepulsionRadiusFactorSlider.oninput = function() { BODY_REPULSION_RADIUS_FACTOR = parseFloat(this.value); updateSliderDisplay(this, bodyRepulsionRadiusFactorValueSpan); }

        baseNodeCostSlider.oninput = function() { BASE_NODE_EXISTENCE_COST = parseFloat(this.value); updateSliderDisplay(this, baseNodeCostValueSpan); }
        // motorNodeCostSlider.oninput = function() { MOTOR_NODE_ENERGY_COST = parseFloat(this.value); updateSliderDisplay(this, motorNodeCostValueSpan); } // Removed
        eaterNodeCostSlider.oninput = function() { EATER_NODE_ENERGY_COST = parseFloat(this.value); updateSliderDisplay(this, eaterNodeCostValueSpan); }
        predatorNodeCostSlider.oninput = function() { PREDATOR_NODE_ENERGY_COST = parseFloat(this.value); updateSliderDisplay(this, predatorNodeCostValueSpan); }

        resetButton.onclick = function() {
            initializePopulation();
            isAnySoftBodyUnstable = false;
            updateInstabilityIndicator();
        }

        fluidDiffusionSlider.oninput = function() { FLUID_DIFFUSION = parseFloat(this.value); updateSliderDisplay(this, fluidDiffusionValueSpan); if(fluidField) fluidField.diffusion = FLUID_DIFFUSION;}
        fluidViscositySlider.oninput = function() { FLUID_VISCOSITY = parseFloat(this.value); updateSliderDisplay(this, fluidViscosityValueSpan); if(fluidField) fluidField.viscosity = FLUID_VISCOSITY;}
        fluidFadeSlider.oninput = function() { FLUID_FADE_RATE = parseFloat(this.value); updateSliderDisplay(this, fluidFadeValueSpan);}
        clearFluidButton.onclick = function() { if(fluidField) fluidField.clear(); }

        numParticlesSlider.oninput = function() { NUM_PARTICLES = parseInt(this.value); updateSliderDisplay(this, numParticlesValueSpan); initParticles(); }
        particleFluidInfluenceSlider.oninput = function() { PARTICLE_FLUID_INFLUENCE = parseFloat(this.value); updateSliderDisplay(this, particleFluidInfluenceValueSpan); }
        particleLifeDecaySlider.oninput = function() { PARTICLE_BASE_LIFE_DECAY = parseFloat(this.value); updateSliderDisplay(this, particleLifeDecayValueSpan); }
        infiniteParticleLifeToggle.onchange = function() {
            IS_PARTICLE_LIFE_INFINITE = this.checked;
            particleLifeDecaySlider.disabled = IS_PARTICLE_LIFE_INFINITE;
            particleLifeDecayLabel.style.color = IS_PARTICLE_LIFE_INFINITE ? '#777' : '#ddd';
            particleLifeDecayValueSpan.style.color = IS_PARTICLE_LIFE_INFINITE ? '#777' : '#00aeff';
            initParticles();
        }
        resetParticlesButton.onclick = function() { initParticles(); }

        exportConfigButton.onclick = handleExportConfig;
        importConfigButton.onclick = () => importConfigFile.click();
        importConfigFile.onchange = handleImportConfig;
        closeInfoPanelButton.onclick = () => { infoPanel.style.display = 'none'; selectedInspectBody = null; selectedInspectPoint = null; }


        function initializeAllSliderDisplays() {
            updateSliderDisplay(maxTimestepSlider, maxTimestepValueSpan);
            updateSliderDisplay(bodyFluidEntrainmentSlider, bodyFluidEntrainmentValueSpan);
            updateSliderDisplay(fluidCurrentStrengthSlider, fluidCurrentStrengthValueSpan);
            updateSliderDisplay(bodyPushStrengthSlider, bodyPushStrengthValueSpan);
            updateSliderDisplay(reproductionCooldownSlider, reproductionCooldownValueSpan);
            updateSliderDisplay(bodyRepulsionStrengthSlider, bodyRepulsionStrengthValueSpan);
            updateSliderDisplay(bodyRepulsionRadiusFactorSlider, bodyRepulsionRadiusFactorValueSpan);
            updateSliderDisplay(baseNodeCostSlider, baseNodeCostValueSpan);
            // updateSliderDisplay(motorNodeCostSlider, motorNodeCostValueSpan); // Removed
            updateSliderDisplay(eaterNodeCostSlider, eaterNodeCostValueSpan);
            updateSliderDisplay(predatorNodeCostSlider, predatorNodeCostValueSpan);
            updateSliderDisplay(emitterStrengthSlider, emitterStrengthValueSpan);
            updateSliderDisplay(fluidDiffusionSlider, fluidDiffusionValueSpan);
            updateSliderDisplay(fluidViscositySlider, fluidViscosityValueSpan);
            updateSliderDisplay(fluidFadeSlider, fluidFadeValueSpan);
            updateSliderDisplay(numParticlesSlider, numParticlesValueSpan);
            updateSliderDisplay(particleFluidInfluenceSlider, particleFluidInfluenceValueSpan);
            updateSliderDisplay(particleLifeDecaySlider, particleLifeDecayValueSpan);

            particleLifeDecaySlider.disabled = IS_PARTICLE_LIFE_INFINITE;
            particleLifeDecayLabel.style.color = IS_PARTICLE_LIFE_INFINITE ? '#777' : '#ddd';
            particleLifeDecayValueSpan.style.color = IS_PARTICLE_LIFE_INFINITE ? '#777' : '#00aeff';

            canvas.classList.toggle('emitter-edit-mode', IS_EMITTER_EDIT_MODE);
        }

        function updateInstabilityIndicator() {
            if (isAnySoftBodyUnstable) {
                instabilityLight.classList.add('unstable');
            } else {
                instabilityLight.classList.remove('unstable');
            }
        }
        function updatePopulationCount() {
            populationCountDisplay.textContent = `Population: ${softBodyPopulation.length}`;
        }

        function getNodeTypeString(nodeType) {
            switch(nodeType) {
                case NodeType.FLOATING: return "Floating";
                case NodeType.FIXED_ROOT: return "Fixed Root";
                case NodeType.EMITTER_SWIMMER: return "Emitter/Swimmer";
                case NodeType.NEUTRAL: return "Neutral";
                default: return "Unknown";
            }
        }

        function updateInfoPanel() {
            if (selectedInspectBody && selectedInspectPoint) {
                document.getElementById('infoBodyId').textContent = selectedInspectBody.id;
                document.getElementById('infoBodyStiffness').textContent = selectedInspectBody.stiffness.toFixed(2);
                document.getElementById('infoBodyDamping').textContent = selectedInspectBody.springDamping.toFixed(2);
                document.getElementById('infoBodyMotorInterval').textContent = selectedInspectBody.motorImpulseInterval;
                document.getElementById('infoBodyMotorCap').textContent = selectedInspectBody.motorImpulseMagnitudeCap.toFixed(2);
                document.getElementById('infoBodyEmitterStrength').textContent = selectedInspectBody.emitterStrength.toFixed(2);
                document.getElementById('infoBodyEmitterDirX').textContent = selectedInspectBody.emitterDirection.x.toFixed(2);
                document.getElementById('infoBodyEmitterDirY').textContent = selectedInspectBody.emitterDirection.y.toFixed(2);
                document.getElementById('infoBodyEnergy').textContent = selectedInspectBody.creatureEnergy.toFixed(2);
                document.getElementById('infoBodyTicksBirth').textContent = selectedInspectBody.ticksSinceBirth;
                document.getElementById('infoBodyCanReproduce').textContent = selectedInspectBody.canReproduce;
                document.getElementById('infoBodyShapeType').textContent = selectedInspectBody.shapeType === 0 ? "Grid" : (selectedInspectBody.shapeType === 1 ? "Line" : "Circle");

                document.getElementById('infoPointIndex').textContent = selectedInspectPointIndex;
                document.getElementById('infoPointNodeType').textContent = getNodeTypeString(selectedInspectPoint.nodeType);
                document.getElementById('infoPointMass').textContent = selectedInspectPoint.mass.toFixed(2);
                document.getElementById('infoPointRadius').textContent = selectedInspectPoint.radius.toFixed(2);
                document.getElementById('infoPointPosX').textContent = selectedInspectPoint.pos.x.toFixed(2);
                document.getElementById('infoPointPosY').textContent = selectedInspectPoint.pos.y.toFixed(2);
                // document.getElementById('infoPointIsMotor').textContent = selectedInspectPoint.isMotor; // Removed
                document.getElementById('infoPointIsEater').textContent = selectedInspectPoint.isEater;
                document.getElementById('infoPointIsPredator').textContent = selectedInspectPoint.isPredator;
                document.getElementById('infoPointEmitsDye').textContent = selectedInspectPoint.emitsDye;
                document.getElementById('infoPointDyeColor').textContent = selectedInspectPoint.emitsDye ? `R:${selectedInspectPoint.dyeColor[0]} G:${selectedInspectPoint.dyeColor[1]} B:${selectedInspectPoint.dyeColor[2]}` : "N/A";

                infoPanel.style.display = 'block';
            } else {
                infoPanel.style.display = 'none';
            }
        }


        // --- Simulation Parameters ---
        const restitution = 0.4;

        let softBodyPopulation = [];
        let fluidField;
        let particles = [];

        let lastTime = 0;
        let deltaTime = 0;
        let nextSoftBodyId = 0;


        // --- Mouse Interaction ---
        let selectedSoftBodyPoint = null;
        let mouse = { x: 0, y: 0, prevX: 0, prevY: 0, isDown: false, dx:0, dy:0 };

        function updateMouse(e) {
            const rect = canvas.getBoundingClientRect();
            mouse.prevX = mouse.x;
            mouse.prevY = mouse.y;
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
            mouse.dx = mouse.x - mouse.prevX;
            mouse.dy = mouse.y - mouse.prevY;
        }

        canvas.addEventListener('mousedown', (e) => {
            mouse.isDown = true;
            updateMouse(e);

            const simMouseX = mouse.x + viewOffsetX;
            const simMouseY = mouse.y + viewOffsetY;

            if (IS_EMITTER_EDIT_MODE && fluidField) {
                const gridX = Math.floor(simMouseX / fluidField.scale);
                const gridY = Math.floor(simMouseY / fluidField.scale);
                emitterDragStartCell = { gridX, gridY, mouseStartX: simMouseX, mouseStartY: simMouseY };
                currentEmitterPreview = {
                    startX: (gridX + 0.5) * fluidField.scale,
                    startY: (gridY + 0.5) * fluidField.scale,
                    endX: simMouseX,
                    endY: simMouseY
                };
                selectedInspectBody = null; selectedInspectPoint = null; updateInfoPanel(); // Hide panel
                return;
            }

            let clickedOnPoint = false;
            for (let body of softBodyPopulation) {
                if (body.isUnstable) continue;
                for (let i = 0; i < body.massPoints.length; i++) {
                    const point = body.massPoints[i];
                    const dist = Math.sqrt((point.pos.x - simMouseX)**2 + (point.pos.y - simMouseY)**2);
                    if (dist < point.radius * 2.5) {
                        selectedSoftBodyPoint = { body: body, point: point }; // For dragging
                        selectedInspectBody = body; // For inspection
                        selectedInspectPoint = point;
                        selectedInspectPointIndex = i;
                        updateInfoPanel();
                        point.isFixed = true;
                        point.prevPos.x = point.pos.x;
                        point.prevPos.y = point.pos.y;
                        clickedOnPoint = true;
                        return;
                    }
                }
            }
            if (!clickedOnPoint) { // Clicked on empty space
                selectedInspectBody = null; selectedInspectPoint = null; updateInfoPanel();
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            updateMouse(e);
            const simMouseX = mouse.x + viewOffsetX;
            const simMouseY = mouse.y + viewOffsetY;

            if (mouse.isDown) {
                if (IS_EMITTER_EDIT_MODE && emitterDragStartCell) {
                    currentEmitterPreview.endX = simMouseX;
                    currentEmitterPreview.endY = simMouseY;
                } else if (selectedSoftBodyPoint) {
                    const point = selectedSoftBodyPoint.point;
                    point.prevPos.x = point.pos.x;
                    point.prevPos.y = point.pos.y;
                    point.pos.x = simMouseX;
                    point.pos.y = simMouseY;
                    if(selectedInspectPoint === point) updateInfoPanel(); // Update panel if dragging inspected point

                } else if (fluidField) {
                    const fluidGridX = Math.floor(simMouseX / fluidField.scale);
                    const fluidGridY = Math.floor(simMouseY / fluidField.scale);
                    const r1 = Math.random() * 100 + 155;
                    const g1 = Math.random() * 50 + 25;
                    const b1 = Math.random() * 100 + 100;
                    fluidField.addDensity(fluidGridX, fluidGridY, r1, g1, b1, 150 + Math.random()*50);

                    const r2 = Math.random() * 50 + 25;
                    const g2 = Math.random() * 100 + 155;
                    const b2 = Math.random() * 100 + 155;
                    fluidField.addDensity(fluidGridX, fluidGridY, r2, g2, b2, 150 + Math.random()*50);

                    fluidField.addVelocity(fluidGridX, fluidGridY, mouse.dx * 10, mouse.dy * 10);
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (IS_EMITTER_EDIT_MODE && emitterDragStartCell && fluidField) {
                const simMouseX = mouse.x + viewOffsetX;
                const simMouseY = mouse.y + viewOffsetY;

                const forceX = (simMouseX - emitterDragStartCell.mouseStartX) * EMITTER_MOUSE_DRAG_SCALE;
                const forceY = (simMouseY - emitterDragStartCell.mouseStartY) * EMITTER_MOUSE_DRAG_SCALE;

                const existingEmitter = velocityEmitters.find(em => em.gridX === emitterDragStartCell.gridX && em.gridY === emitterDragStartCell.gridY);
                if (existingEmitter) {
                    existingEmitter.forceX = forceX;
                    existingEmitter.forceY = forceY;
                } else {
                    velocityEmitters.push({
                        gridX: emitterDragStartCell.gridX,
                        gridY: emitterDragStartCell.gridY,
                        forceX: forceX,
                        forceY: forceY
                    });
                }
                emitterDragStartCell = null;
                currentEmitterPreview = null;
            }

            mouse.isDown = false;
            if (selectedSoftBodyPoint) {
                const point = selectedSoftBodyPoint.point;
                point.isFixed = false;
                point.prevPos.x = point.pos.x - mouse.dx * 1.0;
                point.prevPos.y = point.pos.y - mouse.dy * 1.0;
                selectedSoftBodyPoint = null; // Clear dragging reference
            }
        });
         canvas.addEventListener('mouseleave', () => {
            if (IS_EMITTER_EDIT_MODE && emitterDragStartCell) {
                emitterDragStartCell = null;
                currentEmitterPreview = null;
            }
            if (selectedSoftBodyPoint) {
                const point = selectedSoftBodyPoint.point;
                point.isFixed = false;
                point.prevPos.x = point.pos.x - mouse.dx * 1.0;
                point.prevPos.y = point.pos.y - mouse.dy * 1.0;
                selectedSoftBodyPoint = null;
            }
            mouse.isDown = false;
        });


        // --- Vector2D Class ---
        class Vec2 {
            constructor(x = 0, y = 0) { this.x = x; this.y = y; }
            add(other) { return new Vec2(this.x + other.x, this.y + other.y); }
            sub(other) { return new Vec2(this.x - other.x, this.y - other.y); }
            mul(scalar) { return new Vec2(this.x * scalar, this.y * scalar); }
            div(scalar) { return scalar !== 0 ? new Vec2(this.x / scalar, this.y / scalar) : new Vec2(); }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            magSq() { return this.x * this.x + this.y * this.y; }
            normalize() { const m = this.mag(); return m > 0 ? this.div(m) : new Vec2(); }
            static dot(v1, v2) { return v1.x * v2.x + v1.y * v2.y; }
            clone() { return new Vec2(this.x, this.y); }
        }

        // --- MassPoint Class (Soft Body with Verlet Integration) ---
        class MassPoint {
            constructor(x, y, mass = 0.5, radius = 5, color = 'rgba(0,150,255,0.8)') {
                this.pos = new Vec2(x, y);
                this.prevPos = new Vec2(x, y);
                this.force = new Vec2();
                this.mass = mass;
                this.invMass = this.mass !== 0 ? 1 / this.mass : 0;
                this.radius = radius;
                this.color = color;
                this.isFixed = false;
                this.nodeType = NodeType.NEUTRAL;
                // this.isMotor = false; // Removed
                this.isEater = false;
                this.isPredator = false;
                this.emitsDye = false;
                this.dyeColor = [0,0,0];
            }
            applyForce(f) { this.force = this.force.add(f); }

            update(dt) {
                if (this.isFixed || this.invMass === 0 || this.nodeType === NodeType.FIXED_ROOT) {
                    this.force = new Vec2();
                    return;
                }

                const acceleration = this.force.mul(this.invMass);

                const tempX = this.pos.x;
                const tempY = this.pos.y;

                this.pos.x = 2 * this.pos.x - this.prevPos.x + acceleration.x * dt * dt;
                this.pos.y = 2 * this.pos.y - this.prevPos.y + acceleration.y * dt * dt;

                this.prevPos.x = tempX;
                this.prevPos.y = tempY;

                this.force = new Vec2();
            }

            draw(ctx) {
                // Draw interaction radii first (underneath the point)
                if (this.isEater) {
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius * EATING_RADIUS_MULTIPLIER, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 165, 0, 0.05)';
                    ctx.fill();
                }
                if (this.isPredator) {
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius * PREDATION_RADIUS_MULTIPLIER, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 50, 50, 0.05)';
                    ctx.fill();
                }


                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
                if (this.isPredator) {
                    ctx.fillStyle = 'rgba(255, 50, 50, 0.9)';
                } else if (this.nodeType === NodeType.EMITTER_SWIMMER && this.isEater) { // Check nodeType for emitter
                     ctx.fillStyle = 'rgba(200,255,0,0.9)';
                } else if (this.nodeType === NodeType.EMITTER_SWIMMER) { // Check nodeType for emitter
                    ctx.fillStyle = 'rgba(0,255,100,0.9)';
                } else if (this.isEater) {
                    ctx.fillStyle = 'rgba(255,165,0,0.9)';
                } else if (this.nodeType === NodeType.FIXED_ROOT) {
                    ctx.fillStyle = 'rgba(100, 70, 30, 0.9)';
                }
                else {
                    ctx.fillStyle = this.isFixed ? 'rgba(255,0,0,0.9)' : this.color;
                }
                ctx.fill();
                ctx.closePath();
            }
        }

        // --- Spring Class (Soft Body) ---
        class Spring {
            constructor(p1, p2, stiffness, dampingFactor, restLength = null) {
                this.p1 = p1; this.p2 = p2;
                this.stiffness = stiffness;
                this.dampingFactor = dampingFactor;
                this.restLength = restLength === null ? p1.pos.sub(p2.pos).mag() : restLength;
            }
            applyForce() {
                const diffPos = this.p1.pos.sub(this.p2.pos);
                const currentLength = diffPos.mag();
                if (currentLength === 0) return;
                const displacement = currentLength - this.restLength;
                const direction = diffPos.normalize();

                const springForceMagnitude = -this.stiffness * displacement;
                const springForce = direction.mul(springForceMagnitude);

                const p1_vel_implicit = this.p1.pos.sub(this.p1.prevPos);
                const p2_vel_implicit = this.p2.pos.sub(this.p2.prevPos);
                const relVel_implicit = p1_vel_implicit.sub(p2_vel_implicit);

                const velAlongSpring = Vec2.dot(relVel_implicit, direction);
                const dampingForceMagnitude = -this.dampingFactor * velAlongSpring;
                const dampingForce = direction.mul(dampingForceMagnitude);

                const totalForce = springForce.add(dampingForce);
                this.p1.applyForce(totalForce);
                this.p2.applyForce(totalForce.mul(-1));
            }
            draw(ctx) {
                ctx.beginPath();
                ctx.moveTo(this.p1.pos.x, this.p1.pos.y);
                ctx.lineTo(this.p2.pos.x, this.p2.pos.y);
                ctx.strokeStyle = 'rgba(150,150,150,0.6)';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.closePath();
            }
        }

        // --- SoftBody Class ---
        class SoftBody {
            constructor(id, initialX, initialY, parentBody = null) {
                this.id = id;
                this.massPoints = [];
                this.springs = [];
                this.isUnstable = false;
                this.creatureEnergy = MAX_CREATURE_ENERGY * OFFSPRING_INITIAL_ENERGY_SHARE;
                this.ticksSinceBirth = 0;
                this.canReproduce = false;
                this.shapeType = parentBody ? parentBody.shapeType : Math.floor(Math.random() * 3);

                this.motorImpulseInterval = 30 + Math.floor(Math.random() * 90);
                this.motorImpulseMagnitudeCap = 0.5 + Math.random() * 2.0;
                this.emitterStrength = 0.2 + Math.random() * 1.0;
                this.emitterDirection = new Vec2(Math.random()*2-1, Math.random()*2-1).normalize();


                if (parentBody) {
                    this.stiffness = parentBody.stiffness * (1 + (Math.random() - 0.5) * 2 * MUTATION_RATE_PERCENT);
                    this.springDamping = parentBody.springDamping * (1 + (Math.random() - 0.5) * 2 * MUTATION_RATE_PERCENT);
                    this.motorImpulseInterval = Math.max(10, Math.floor(parentBody.motorImpulseInterval * (1 + (Math.random() - 0.5) * 2 * MUTATION_RATE_PERCENT)));
                    this.motorImpulseMagnitudeCap = parentBody.motorImpulseMagnitudeCap * (1 + (Math.random() - 0.5) * 2 * MUTATION_RATE_PERCENT);
                    this.emitterStrength = parentBody.emitterStrength * (1 + (Math.random() - 0.5) * 2 * MUTATION_RATE_PERCENT);

                    const angleMutation = (Math.random() - 0.5) * Math.PI * 0.2;
                    const cosA = Math.cos(angleMutation);
                    const sinA = Math.sin(angleMutation);
                    this.emitterDirection = new Vec2(
                        parentBody.emitterDirection.x * cosA - parentBody.emitterDirection.y * sinA,
                        parentBody.emitterDirection.x * sinA + parentBody.emitterDirection.y * cosA
                    ).normalize();

                } else {
                    this.stiffness = 500 + Math.random() * 2500;
                    this.springDamping = 5 + Math.random() * 20;
                }
                this.stiffness = Math.max(100, Math.min(this.stiffness, 10000));
                this.springDamping = Math.max(0.1, Math.min(this.springDamping, 50));
                this.motorImpulseMagnitudeCap = Math.max(0, Math.min(this.motorImpulseMagnitudeCap, 5.0));
                this.motorImpulseInterval = Math.max(10, Math.min(this.motorImpulseInterval, 300));
                this.emitterStrength = Math.max(0, Math.min(this.emitterStrength, 3.0));


                this.fluidEntrainment = BODY_FLUID_ENTRAINMENT_FACTOR;
                this.fluidCurrentStrength = FLUID_CURRENT_STRENGTH_ON_BODY;
                this.bodyPushStrength = SOFT_BODY_PUSH_STRENGTH;

                this.createShape(initialX, initialY, parentBody);
            }

            createShape(startX, startY, parentBody = null) {
                this.massPoints = [];
                this.springs = [];

                const basePointDist = 20 + Math.random() * 10;
                const baseRadius = 3 + Math.random() * 3;

                // const motorChance = 0.25; // Not used for isMotor flag anymore
                const eaterChance = 0.25;
                const predatorChance = 0.15;
                const dyeEmitterChance = 0.2;

                const nodeTypeChoices = [NodeType.NEUTRAL, NodeType.FLOATING, NodeType.FIXED_ROOT, NodeType.EMITTER_SWIMMER];
                const dyeColorChoices = [DYE_COLORS.RED, DYE_COLORS.GREEN, DYE_COLORS.BLUE];


                if (this.shapeType === 0) {
                    const numPointsX = 3;
                    const numPointsY = 3;
                    let gridPoints = [];
                    for (let i = 0; i < numPointsY; i++) {
                        gridPoints[i] = [];
                        for (let j = 0; j < numPointsX; j++) {
                            let mass = 0.3 + Math.random() * 0.4;
                            let nodeType = nodeTypeChoices[Math.floor(Math.random() * nodeTypeChoices.length)];
                            // let isMotor = Math.random() < motorChance; // Removed
                            let isEater = Math.random() < eaterChance;
                            let isPredator = Math.random() < predatorChance;
                            let emitsDye = Math.random() < dyeEmitterChance;
                            let dyeColor = dyeColorChoices[Math.floor(Math.random() * dyeColorChoices.length)];


                            if (parentBody && parentBody.massPoints[i*numPointsX + j]) {
                                const parentPoint = parentBody.massPoints[i*numPointsX + j];
                                mass = parentPoint.mass * (1 + (Math.random() - 0.5) * 2 * MUTATION_RATE_PERCENT);
                                nodeType = Math.random() < MUTATION_CHANCE_NODE_TYPE ? nodeTypeChoices[Math.floor(Math.random() * nodeTypeChoices.length)] : parentPoint.nodeType;
                                // isMotor = Math.random() < MUTATION_CHANCE_NODE_TYPE ? !parentPoint.isMotor : parentPoint.isMotor; // Removed
                                isEater = Math.random() < MUTATION_CHANCE_NODE_TYPE ? !parentPoint.isEater : parentPoint.isEater;
                                isPredator = Math.random() < MUTATION_CHANCE_NODE_TYPE ? !parentPoint.isPredator : parentPoint.isPredator;
                                emitsDye = Math.random() < MUTATION_CHANCE_BOOL ? !parentPoint.emitsDye : parentPoint.emitsDye;
                                dyeColor = Math.random() < MUTATION_CHANCE_BOOL ? dyeColorChoices[Math.floor(Math.random() * dyeColorChoices.length)] : parentPoint.dyeColor;
                            }
                            mass = Math.max(0.1, Math.min(mass, 1.0));
                            const point = new MassPoint(startX + j * basePointDist, startY + i * basePointDist, mass, baseRadius);
                            point.nodeType = nodeType;
                            // point.isMotor = isMotor; // Removed
                            point.isEater = isEater;
                            point.isPredator = isPredator;
                            point.emitsDye = emitsDye;
                            point.dyeColor = dyeColor;
                            if(point.nodeType === NodeType.FIXED_ROOT) point.isFixed = true;
                            this.massPoints.push(point);
                            gridPoints[i][j] = point;
                        }
                    }
                    for (let i = 0; i < numPointsY; i++) for (let j = 0; j < numPointsX - 1; j++) this.springs.push(new Spring(gridPoints[i][j], gridPoints[i][j+1], this.stiffness, this.springDamping));
                    for (let j = 0; j < numPointsX; j++) for (let i = 0; i < numPointsY - 1; i++) this.springs.push(new Spring(gridPoints[i][j], gridPoints[i+1][j], this.stiffness, this.springDamping));
                    for (let i = 0; i < numPointsY - 1; i++) for (let j = 0; j < numPointsX - 1; j++) {
                        this.springs.push(new Spring(gridPoints[i][j], gridPoints[i+1][j+1], this.stiffness * 0.7, this.springDamping));
                        this.springs.push(new Spring(gridPoints[i+1][j], gridPoints[i][j+1], this.stiffness * 0.7, this.springDamping));
                    }
                } else if (this.shapeType === 1) {
                    const numLinePoints = parentBody ? parentBody.massPoints.length : Math.floor(3 + Math.random() * 3);
                    const isHorizontal = Math.random() < 0.5;
                    let linePoints = [];
                    for (let i = 0; i < numLinePoints; i++) {
                        const x = startX + (isHorizontal ? i * basePointDist : 0);
                        const y = startY + (isHorizontal ? 0 : i * basePointDist);
                        let mass = 0.3 + Math.random() * 0.4;
                        let nodeType = nodeTypeChoices[Math.floor(Math.random() * nodeTypeChoices.length)];
                        // let isMotor = Math.random() < motorChance; // Removed
                        let isEater = Math.random() < eaterChance;
                        let isPredator = false;
                        let emitsDye = Math.random() < dyeEmitterChance;
                        let dyeColor = dyeColorChoices[Math.floor(Math.random() * dyeColorChoices.length)];
                        if(parentBody && parentBody.massPoints[i]) {
                             mass = parentBody.massPoints[i].mass * (1 + (Math.random() - 0.5) * 2 * MUTATION_RATE_PERCENT);
                             nodeType = Math.random() < MUTATION_CHANCE_NODE_TYPE ? nodeTypeChoices[Math.floor(Math.random() * nodeTypeChoices.length)] : parentBody.massPoints[i].nodeType;
                             // isMotor = Math.random() < MUTATION_CHANCE_NODE_TYPE ? !parentBody.massPoints[i].isMotor : parentBody.massPoints[i].isMotor; // Removed
                             isEater = Math.random() < MUTATION_CHANCE_NODE_TYPE ? !parentBody.massPoints[i].isEater : parentBody.massPoints[i].isEater;
                             isPredator = Math.random() < MUTATION_CHANCE_NODE_TYPE ? !parentBody.massPoints[i].isPredator : parentBody.massPoints[i].isPredator;
                             emitsDye = Math.random() < MUTATION_CHANCE_BOOL ? !parentBody.massPoints[i].emitsDye : parentBody.massPoints[i].emitsDye;
                             dyeColor = Math.random() < MUTATION_CHANCE_BOOL ? dyeColorChoices[Math.floor(Math.random() * dyeColorChoices.length)] : parentBody.massPoints[i].dyeColor;
                        }

                        mass = Math.max(0.1, Math.min(mass, 1.0));
                        const point = new MassPoint(x, y, mass, baseRadius);
                        point.nodeType = nodeType;
                        // point.isMotor = isMotor; // Removed
                        point.isEater = isEater;
                        point.isPredator = isPredator;
                        point.emitsDye = emitsDye;
                        point.dyeColor = dyeColor;
                        if(point.nodeType === NodeType.FIXED_ROOT) point.isFixed = true;
                        this.massPoints.push(point);
                        linePoints.push(point);
                    }
                    for (let i = 0; i < numLinePoints - 1; i++) {
                        this.springs.push(new Spring(linePoints[i], linePoints[i+1], this.stiffness, this.springDamping));
                    }
                    if (numLinePoints > 2) {
                         this.springs.push(new Spring(linePoints[0], linePoints[numLinePoints-1], this.stiffness * 0.5, this.springDamping));
                    }
                } else {
                    const numOuterPoints = parentBody ? parentBody.massPoints.length -1 : Math.floor(4 + Math.random() * 3);
                    let centerMass = (0.3 + Math.random() * 0.4) * 1.5;
                    let centerNodeType = nodeTypeChoices[Math.floor(Math.random() * nodeTypeChoices.length)];
                    // let centerIsMotor = Math.random() < motorChance * 1.5; // Removed
                    let centerIsEater = Math.random() < eaterChance * 1.5;
                    let centerIsPredator = false;
                    let centerEmitsDye = Math.random() < dyeEmitterChance;
                    let centerDyeColor = dyeColorChoices[Math.floor(Math.random() * dyeColorChoices.length)];

                    if(parentBody && parentBody.massPoints[0]) {
                        const parentPoint = parentBody.massPoints[0];
                        centerMass = parentPoint.mass * (1 + (Math.random() - 0.5) * 2 * MUTATION_RATE_PERCENT);
                        centerNodeType = Math.random() < MUTATION_CHANCE_NODE_TYPE ? nodeTypeChoices[Math.floor(Math.random() * nodeTypeChoices.length)] : parentPoint.nodeType;
                        // centerIsMotor = Math.random() < MUTATION_CHANCE_NODE_TYPE ? !parentPoint.isMotor : parentPoint.isMotor; // Removed
                        centerIsEater = Math.random() < MUTATION_CHANCE_NODE_TYPE ? !parentPoint.isEater : parentPoint.isEater;
                        centerIsPredator = Math.random() < MUTATION_CHANCE_NODE_TYPE ? !parentPoint.isPredator : parentPoint.isPredator;
                        centerEmitsDye = Math.random() < MUTATION_CHANCE_BOOL ? !parentPoint.emitsDye : parentPoint.emitsDye;
                        centerDyeColor = Math.random() < MUTATION_CHANCE_BOOL ? dyeColorChoices[Math.floor(Math.random() * dyeColorChoices.length)] : parentPoint.dyeColor;
                    }
                    centerMass = Math.max(0.1, Math.min(centerMass, 1.5));
                    const centralPoint = new MassPoint(startX, startY, centerMass, baseRadius * 1.2);
                    centralPoint.nodeType = centerNodeType;
                    // centralPoint.isMotor = centerIsMotor; // Removed
                    centralPoint.isEater = centerIsEater;
                    centralPoint.isPredator = centerIsPredator;
                    centralPoint.emitsDye = centerEmitsDye;
                    centralPoint.dyeColor = centerDyeColor;
                    if(centralPoint.nodeType === NodeType.FIXED_ROOT) centralPoint.isFixed = true;
                    this.massPoints.push(centralPoint);

                    const circleRadius = basePointDist * 1.5;
                    for (let i = 0; i < numOuterPoints; i++) {
                        const angle = (i / numOuterPoints) * Math.PI * 2;
                        const x = startX + Math.cos(angle) * circleRadius;
                        const y = startY + Math.sin(angle) * circleRadius;
                        let mass = 0.3 + Math.random() * 0.4;
                        let nodeType = nodeTypeChoices[Math.floor(Math.random() * nodeTypeChoices.length)];
                        // let isMotor = Math.random() < motorChance; // Removed
                        let isEater = Math.random() < eaterChance;
                        let isPredator = false;
                        let emitsDye = Math.random() < dyeEmitterChance;
                        let dyeColor = dyeColorChoices[Math.floor(Math.random() * dyeColorChoices.length)];
                        if(parentBody && parentBody.massPoints[i+1]) {
                             const parentPoint = parentBody.massPoints[i+1];
                             mass = parentPoint.mass * (1 + (Math.random() - 0.5) * 2 * MUTATION_RATE_PERCENT);
                             nodeType = Math.random() < MUTATION_CHANCE_NODE_TYPE ? nodeTypeChoices[Math.floor(Math.random() * nodeTypeChoices.length)] : parentPoint.nodeType;
                             // isMotor = Math.random() < MUTATION_CHANCE_NODE_TYPE ? !parentPoint.isMotor : parentPoint.isMotor; // Removed
                             isEater = Math.random() < MUTATION_CHANCE_NODE_TYPE ? !parentPoint.isEater : parentPoint.isEater;
                             isPredator = Math.random() < MUTATION_CHANCE_NODE_TYPE ? !parentPoint.isPredator : parentPoint.isPredator;
                             emitsDye = Math.random() < MUTATION_CHANCE_BOOL ? !parentPoint.emitsDye : parentPoint.emitsDye;
                             dyeColor = Math.random() < MUTATION_CHANCE_BOOL ? dyeColorChoices[Math.floor(Math.random() * dyeColorChoices.length)] : parentPoint.dyeColor;
                        }
                        mass = Math.max(0.1, Math.min(mass, 1.0));
                        const point = new MassPoint(x, y, mass, baseRadius);
                        point.nodeType = nodeType;
                        // point.isMotor = isMotor; // Removed
                        point.isEater = isEater;
                        point.isPredator = isPredator;
                        point.emitsDye = emitsDye;
                        point.dyeColor = dyeColor;
                        if(point.nodeType === NodeType.FIXED_ROOT) point.isFixed = true;
                        this.massPoints.push(point);
                        this.springs.push(new Spring(centralPoint, point, this.stiffness, this.springDamping));
                        if (i > 0) {
                            this.springs.push(new Spring(this.massPoints[this.massPoints.length-2], point, this.stiffness * 0.8, this.springDamping));
                        }
                    }
                    if (numOuterPoints > 1) {
                         this.springs.push(new Spring(this.massPoints[1], this.massPoints[this.massPoints.length-1], this.stiffness * 0.8, this.springDamping));
                    }
                }
            }


            updateSelf(dt, fluidFieldRef) {
                if (this.isUnstable) return;

                // Calculate and apply energy cost
                let currentFrameEnergyCost = 0;
                for (const point of this.massPoints) {
                    currentFrameEnergyCost += BASE_NODE_EXISTENCE_COST;
                    // if (point.isMotor) { // Removed direct motor cost, now tied to EMITTER_SWIMMER or internal impulse
                    //     currentFrameEnergyCost += MOTOR_NODE_ENERGY_COST;
                    // }
                    if (point.nodeType === NodeType.EMITTER_SWIMMER && this.emitterStrength > 0.0001) { // Cost for active emitters
                         currentFrameEnergyCost += MOTOR_NODE_ENERGY_COST; // Re-purpose motor cost for emitters
                    }
                    if (point.isEater) {
                        currentFrameEnergyCost += EATER_NODE_ENERGY_COST;
                    }
                    if (point.isPredator) {
                        currentFrameEnergyCost += PREDATOR_NODE_ENERGY_COST;
                    }
                }
                this.creatureEnergy -= currentFrameEnergyCost * dt;


                this.ticksSinceBirth++;
                if (this.ticksSinceBirth > REPRODUCTION_COOLDOWN_TICKS) {
                    this.canReproduce = true;
                }

                if (this.creatureEnergy <= 0) {
                    this.isUnstable = true;
                    console.log(`Soft body ID ${this.id} died from energy depletion.`);
                    return;
                }

                // Internal Motor Impulse (for any node *that has motor capability*, now tied to EMITTER_SWIMMER for simplicity or a new flag if needed)
                // For now, let's assume only EMITTER_SWIMMER nodes have the *potential* for internal impulses if we re-add that.
                // Or, we can keep the old `isMotor` flag on points for this specific internal kick, separate from fluid emission.
                // Current implementation: No internal impulse logic, only fluid emission by EMITTER_SWIMMER.


                // Fluid Interactions based on NodeType
                if (fluidFieldRef) {
                    for (let point of this.massPoints) {
                        if (point.isFixed || point.nodeType === NodeType.FIXED_ROOT) continue;

                        const fluidGridX = Math.floor(point.pos.x / fluidFieldRef.scale);
                        const fluidGridY = Math.floor(point.pos.y / fluidFieldRef.scale);
                        const idx = fluidFieldRef.IX(fluidGridX, fluidGridY);

                        if (point.nodeType === NodeType.FLOATING) {
                            const rawFluidVx = fluidFieldRef.Vx[idx];
                            const rawFluidVy = fluidFieldRef.Vy[idx];
                            let fluidDisplacementPx = new Vec2(rawFluidVx * fluidFieldRef.scale * dt, rawFluidVy * fluidFieldRef.scale * dt);
                            let effectiveFluidDisplacementPx = fluidDisplacementPx.mul(this.fluidCurrentStrength);
                            let currentPointDisplacementPx = point.pos.sub(point.prevPos);
                            let blendedDisplacementPx = currentPointDisplacementPx.mul(1.0 - this.fluidEntrainment)
                                                             .add(effectiveFluidDisplacementPx.mul(this.fluidEntrainment));
                            point.prevPos = point.pos.clone().sub(blendedDisplacementPx);
                        } else if (point.nodeType === NodeType.EMITTER_SWIMMER && this.emitterStrength > 0.0001) {
                            const emitterPushVx = this.emitterDirection.x * this.emitterStrength;
                            const emitterPushVy = this.emitterDirection.y * this.emitterStrength;
                            fluidFieldRef.addVelocity(fluidGridX, fluidGridY, emitterPushVx, emitterPushVy);
                        }

                        if (point.emitsDye) {
                            fluidFieldRef.addDensity(fluidGridX, fluidGridY, point.dyeColor[0], point.dyeColor[1], point.dyeColor[2], 50);
                        }
                    }
                }

                for (let spring of this.springs) spring.applyForce();

                // Inter-body repulsion & Predation (combined loop)
                for (let i = 0; i < this.massPoints.length; i++) {
                    const p1 = this.massPoints[i];
                    if (p1.isFixed) continue;

                    for (let otherBody of softBodyPopulation) {
                        if (otherBody === this || otherBody.isUnstable) continue;
                        for (let j = 0; j < otherBody.massPoints.length; j++) {
                            const p2 = otherBody.massPoints[j];
                            if (p2.isFixed) continue;

                            const diff = p1.pos.sub(p2.pos);
                            const distSq = diff.magSq();
                            const interactionRadius = (p1.radius + p2.radius) * BODY_REPULSION_RADIUS_FACTOR;

                            if (distSq < interactionRadius * interactionRadius && distSq > 0.0001) {
                                const dist = Math.sqrt(distSq);
                                const overlap = interactionRadius - dist;
                                const forceDir = diff.normalize();
                                const repulsionForceMag = BODY_REPULSION_STRENGTH * overlap * 0.5;
                                const repulsionForce = forceDir.mul(repulsionForceMag);

                                p1.applyForce(repulsionForce);
                            }

                            if (p1.isPredator) {
                                const predationRadius = p1.radius * PREDATION_RADIUS_MULTIPLIER;
                                if (distSq < predationRadius * predationRadius) {
                                    const energyToSap = Math.min(otherBody.creatureEnergy, ENERGY_SAPPED_PER_PREDATION);
                                    if (energyToSap > 0) {
                                        otherBody.creatureEnergy -= energyToSap;
                                        this.creatureEnergy = Math.min(MAX_CREATURE_ENERGY, this.creatureEnergy + energyToSap);
                                    }
                                }
                            }
                        }
                    }
                }

                for (let point of this.massPoints) point.update(dt);

                for (let point of this.massPoints) {
                    const displacementSq = point.pos.sub(point.prevPos).magSq();
                    if (displacementSq > MAX_DISPLACEMENT_SQ_THRESHOLD ||
                        isNaN(point.pos.x) || isNaN(point.pos.y) ||
                        !isFinite(point.pos.x) || !isFinite(point.pos.y)) {
                        this.isUnstable = true;
                        console.warn(`Soft body ID ${this.id} instability detected!`, point);
                        break;
                    }
                }

                if (!this.isUnstable) {
                    for (let point of this.massPoints) {
                        if (point.isFixed || point.nodeType === NodeType.FIXED_ROOT) continue;

                        if (point.isEater) {
                            const eatingRadius = point.radius * EATING_RADIUS_MULTIPLIER;
                            const eatingRadiusSq = eatingRadius * eatingRadius;
                            for (let particle of particles) {
                                if (particle.life > 0 && !particle.isEaten) {
                                    const distSq = point.pos.sub(particle.pos).magSq();
                                    if (distSq < eatingRadiusSq) {
                                        particle.isEaten = true;
                                        particle.life = 0;
                                        this.creatureEnergy = Math.min(MAX_CREATURE_ENERGY, this.creatureEnergy + ENERGY_PER_PARTICLE);
                                    }
                                }
                            }
                        }
                    }
                }


                if (!this.isUnstable) {
                    for (let point of this.massPoints) {
                        if (point.isFixed || point.nodeType === NodeType.FIXED_ROOT) continue;
                        const implicitVelX = point.pos.x - point.prevPos.x;
                        const implicitVelY = point.pos.y - point.prevPos.y;

                        if (IS_WORLD_WRAPPING) {
                            const avgPos = this.getAveragePosition();
                            const bodyWidth = this.getMaxX() - this.getMinX();
                            const bodyHeight = this.getMaxY() - this.getMinY();

                            if (avgPos.x + bodyWidth/2 < 0) { this.translateBody(WORLD_WIDTH, 0); }
                            else if (avgPos.x - bodyWidth/2 > WORLD_WIDTH) { this.translateBody(-WORLD_WIDTH, 0); }
                            if (avgPos.y + bodyHeight/2 < 0) { this.translateBody(0, WORLD_HEIGHT); }
                            else if (avgPos.y - bodyHeight/2 > WORLD_HEIGHT) { this.translateBody(0, -WORLD_HEIGHT); }

                        } else {
                            if (point.pos.x - point.radius < 0) { point.pos.x = point.radius; point.prevPos.x = point.pos.x + implicitVelX * restitution; }
                            else if (point.pos.x + point.radius > WORLD_WIDTH) { point.pos.x = WORLD_WIDTH - point.radius; point.prevPos.x = point.pos.x + implicitVelX * restitution; }
                            if (point.pos.y - point.radius < 0) { point.pos.y = point.radius; point.prevPos.y = point.pos.y + implicitVelY * restitution; }
                            else if (point.pos.y + point.radius > WORLD_HEIGHT) { point.pos.y = WORLD_HEIGHT - point.radius; point.prevPos.y = point.pos.y + implicitVelY * restitution; }
                        }
                    }
                }
            }

            translateBody(dx, dy) {
                this.massPoints.forEach(p => {
                    p.pos.x += dx;
                    p.pos.y += dy;
                    p.prevPos.x += dx;
                    p.prevPos.y += dy;
                });
            }
            getMinX() { return Math.min(...this.massPoints.map(p => p.pos.x - p.radius)); }
            getMaxX() { return Math.max(...this.massPoints.map(p => p.pos.x + p.radius)); }
            getMinY() { return Math.min(...this.massPoints.map(p => p.pos.y - p.radius)); }
            getMaxY() { return Math.max(...this.massPoints.map(p => p.pos.y + p.radius)); }


            reproduce() {
                if (this.isUnstable || !this.canReproduce) return [];

                const energyForOneOffspring = MAX_CREATURE_ENERGY * OFFSPRING_INITIAL_ENERGY_SHARE;
                const totalEnergyForOffspring = 3 * energyForOneOffspring;

                if (this.creatureEnergy < totalEnergyForOffspring) return [];

                this.creatureEnergy -= totalEnergyForOffspring;
                this.creatureEnergy *= (1 - REPRODUCTION_ADDITIONAL_COST_FACTOR);
                if(this.creatureEnergy < 0) this.creatureEnergy = 0;
                this.ticksSinceBirth = 0;
                this.canReproduce = false;


                let offspring = [];
                const parentAvgPos = this.getAveragePosition();

                for (let i = 0; i < 3; i++) {
                    let spawnX, spawnY, isSpotClear, attempts = 0;

                    do {
                        const angle = Math.random() * Math.PI * 2;
                        const radiusOffset = OFFSPRING_SPAWN_RADIUS * (0.5 + Math.random() * 0.5);
                        const offsetX = Math.cos(angle) * radiusOffset;
                        const offsetY = Math.sin(angle) * radiusOffset;

                        spawnX = parentAvgPos.x + offsetX;
                        spawnY = parentAvgPos.y + offsetY;

                        const margin = 30;
                        spawnX = Math.max(margin, Math.min(spawnX, WORLD_WIDTH - margin));
                        spawnY = Math.max(margin, Math.min(spawnY, WORLD_HEIGHT - margin));

                        isSpotClear = true;
                        for (const otherBody of softBodyPopulation) {
                            if (otherBody.isUnstable) continue;
                            for (const otherPoint of otherBody.massPoints) {
                                const distSq = (spawnX - otherPoint.pos.x)**2 + (spawnY - otherPoint.pos.y)**2;
                                if (distSq < OFFSPRING_PLACEMENT_CLEARANCE_RADIUS * OFFSPRING_PLACEMENT_CLEARANCE_RADIUS) {
                                    isSpotClear = false;
                                    break;
                                }
                            }
                            if (!isSpotClear) break;
                        }
                        attempts++;
                    } while (!isSpotClear && attempts < OFFSPRING_PLACEMENT_ATTEMPTS);

                    const child = new SoftBody(nextSoftBodyId++, spawnX, spawnY, this);
                    child.creatureEnergy = energyForOneOffspring;
                    offspring.push(child);
                }
                return offspring;
            }

            getAveragePosition() {
                if (this.massPoints.length === 0) return new Vec2(WORLD_WIDTH/2, WORLD_HEIGHT/2);
                let sumX = 0, sumY = 0;
                this.massPoints.forEach(p => { sumX += p.pos.x; sumY += p.pos.y; });
                return new Vec2(sumX / this.massPoints.length, sumY / this.massPoints.length);
            }

            drawSelf(ctx) {
                if (this.isUnstable) return;
                for (let spring of this.springs) spring.draw(ctx);
                for (let point of this.massPoints) point.draw(ctx);
            }
        }


        // --- FluidField Class (Simplified) ---
        class FluidField {
            constructor(size, diffusion, viscosity, dt, scale) {
                this.size = size;
                this.dt = dt;
                this.diffusion = diffusion;
                this.viscosity = viscosity;
                this.scale = scale;
                this.useWrapping = false;
                // this.isSolid = new Array(size * size).fill(false); // Removed isSolid array

                this.densityR = new Float32Array(size * size).fill(0);
                this.densityG = new Float32Array(size * size).fill(0);
                this.densityB = new Float32Array(size * size).fill(0);
                this.densityR0 = new Float32Array(size * size).fill(0);
                this.densityG0 = new Float32Array(size * size).fill(0);
                this.densityB0 = new Float32Array(size * size).fill(0);

                this.Vx = new Float32Array(size * size).fill(0);
                this.Vy = new Float32Array(size * size).fill(0);
                this.Vx0 = new Float32Array(size * size).fill(0);
                this.Vy0 = new Float32Array(size * size).fill(0);

                this.iterations = 4;
            }

            IX(x, y) {
                if (this.useWrapping) {
                    x = (Math.floor(x) % this.size + this.size) % this.size;
                    y = (Math.floor(y) % this.size + this.size) % this.size;
                } else {
                    x = Math.max(0, Math.min(x, this.size - 1));
                    y = Math.max(0, Math.min(y, this.size - 1));
                }
                return Math.floor(x) + Math.floor(y) * this.size;
            }

            addDensity(x, y, r, g, b, amount) {
                const idx = this.IX(x,y);
                this.densityR[idx] = Math.min(255, this.densityR[idx] + r * (amount/255));
                this.densityG[idx] = Math.min(255, this.densityG[idx] + g * (amount/255));
                this.densityB[idx] = Math.min(255, this.densityB[idx] + b * (amount/255));
            }

            addVelocity(x, y, amountX, amountY) {
                const idx = this.IX(x, y);
                this.Vx[idx] += amountX;
                this.Vy[idx] += amountY;
            }

            lin_solve(b, x, x0, a, c) {
                const cRecip = 1.0 / c;
                for (let k = 0; k < this.iterations; k++) {
                    for (let j = 1; j < this.size - 1; j++) {
                        for (let i = 1; i < this.size - 1; i++) {
                             const idx = this.IX(i,j);
                             // Removed isSolid check here
                            x[idx] =
                                (x0[idx] +
                                a * ( x[this.IX(i+1,j)] + x[this.IX(i-1,j)] +
                                      x[this.IX(i,j+1)] + x[this.IX(i,j-1)]
                                    )) * cRecip;
                        }
                    }
                    this.set_bnd(b, x);
                }
            }

            diffuse(b, x_out, x_in, diff_rate, dt) {
                const a = dt * diff_rate * (this.size - 2) * (this.size - 2);
                this.lin_solve(b, x_out, x_in, a, 1 + 4 * a);
            }

            project(velocX_in_out, velocY_in_out, p_temp, div_temp) {
                for (let j = 1; j < this.size - 1; j++) {
                    for (let i = 1; i < this.size - 1; i++) {
                        const idx = this.IX(i,j);
                        // Removed isSolid check here
                        div_temp[idx] = -0.5 * (
                            velocX_in_out[this.IX(i+1,j)] - velocX_in_out[this.IX(i-1,j)] +
                            velocY_in_out[this.IX(i,j+1)] - velocY_in_out[this.IX(i,j-1)]
                        ) / this.size;
                        p_temp[idx] = 0;
                    }
                }
                this.set_bnd(0, div_temp);
                this.set_bnd(0, p_temp);
                this.lin_solve(0, p_temp, div_temp, 1, 4);

                for (let j = 1; j < this.size - 1; j++) {
                    for (let i = 1; i < this.size - 1; i++) {
                        const idx = this.IX(i,j);
                        // Removed isSolid check here
                        velocX_in_out[idx] -= 0.5 * (p_temp[this.IX(i+1,j)] - p_temp[this.IX(i-1,j)]) * this.size;
                        velocY_in_out[idx] -= 0.5 * (p_temp[this.IX(i,j+1)] - p_temp[this.IX(i,j-1)]) * this.size;
                    }
                }
                this.set_bnd(1, velocX_in_out);
                this.set_bnd(2, velocY_in_out);
            }

            advect(b, d_out, d_in, velocX_source, velocY_source, dt) {
                let i0, i1, j0, j1;
                const dtx = dt * (this.size - 2);
                const dty = dt * (this.size - 2);
                let s0, s1, t0, t1;
                let tmp1, tmp2, x, y;

                const N = this.size;

                for (let j_cell = 1; j_cell < N - 1; j_cell++) {
                    for (let i_cell = 1; i_cell < N - 1; i_cell++) {
                        const current_idx = this.IX(i_cell, j_cell);
                        // Removed isSolid check here

                        tmp1 = dtx * velocX_source[current_idx];
                        tmp2 = dty * velocY_source[current_idx];
                        x = i_cell - tmp1;
                        y = j_cell - tmp2;

                        if (this.useWrapping) {
                            x = (x % N + N) % N;
                            y = (y % N + N) % N;
                            i0 = Math.floor(x);
                            j0 = Math.floor(y);
                            i1 = (i0 + 1) % N;
                            j1 = (j0 + 1) % N;
                        } else {
                            if (x < 0.5) x = 0.5;
                            if (x > N - 1.5) x = N - 1.5;
                            i0 = Math.floor(x);
                            i1 = i0 + 1.0;

                            if (y < 0.5) y = 0.5;
                            if (y > N - 1.5) y = N - 1.5;
                            j0 = Math.floor(y);
                            j1 = j0 + 1.0;
                        }

                        s1 = x - i0;
                        if (this.useWrapping && i1 === 0 && i0 === N - 1) s0 = 1.0 - s1 + 1; else s0 = 1.0 - s1;

                        t1 = y - j0;
                        if (this.useWrapping && j1 === 0 && j0 === N - 1) t0 = 1.0 - t1 + 1; else t0 = 1.0 - t1;

                        // Removed isSolid checks for sampling, fluid flows through everything
                        d_out[current_idx] = s0 * (t0 * d_in[this.IX(i0,j0)] + t1 * d_in[this.IX(i0,j1)]) +
                                             s1 * (t0 * d_in[this.IX(i1,j0)] + t1 * d_in[this.IX(i1,j1)]);
                    }
                }
                this.set_bnd(b, d_out);
            }

            set_bnd(b, x_arr) {
                if (this.useWrapping) {
                    for (let i = 1; i < this.size - 1; i++) {
                        x_arr[this.IX(i, 0)] = x_arr[this.IX(i, this.size - 2)];
                        x_arr[this.IX(i, this.size - 1)] = x_arr[this.IX(i, 1)];
                    }
                    for (let j = 1; j < this.size - 1; j++) {
                        x_arr[this.IX(0, j)] = x_arr[this.IX(this.size - 2, j)];
                        x_arr[this.IX(this.size - 1, j)] = x_arr[this.IX(1, j)];
                    }
                    x_arr[this.IX(0, 0)] = x_arr[this.IX(this.size - 2, this.size - 2)];
                    x_arr[this.IX(0, this.size - 1)] = x_arr[this.IX(this.size - 2, 1)];
                    x_arr[this.IX(this.size - 1, 0)] = x_arr[this.IX(1, this.size - 2)];
                    x_arr[this.IX(this.size - 1, this.size - 1)] = x_arr[this.IX(1, 1)];

                } else {
                    for (let i = 1; i < this.size - 1; i++) {
                        x_arr[this.IX(i, 0)] = b === 2 ? -x_arr[this.IX(i, 1)] : x_arr[this.IX(i, 1)];
                        x_arr[this.IX(i, this.size - 1)] = b === 2 ? -x_arr[this.IX(i, this.size - 2)] : x_arr[this.IX(i, this.size - 2)];
                    }
                    for (let j = 1; j < this.size - 1; j++) {
                        x_arr[this.IX(0, j)] = b === 1 ? -x_arr[this.IX(1, j)] : x_arr[this.IX(1, j)];
                        x_arr[this.IX(this.size - 1, j)] = b === 1 ? -x_arr[this.IX(this.size - 2, j)] : x_arr[this.IX(this.size - 2, j)];
                    }
                    x_arr[this.IX(0, 0)] = 0.5 * (x_arr[this.IX(1, 0)] + x_arr[this.IX(0, 1)]);
                    x_arr[this.IX(0, this.size - 1)] = 0.5 * (x_arr[this.IX(1, this.size - 1)] + x_arr[this.IX(0, this.size - 2)]);
                    x_arr[this.IX(this.size - 1, 0)] = 0.5 * (x_arr[this.IX(this.size - 2, 0)] + x_arr[this.IX(this.size - 1, 1)]);
                    x_arr[this.IX(this.size - 1, this.size - 1)] = 0.5 * (x_arr[this.IX(this.size - 2, this.size - 1)] + x_arr[this.IX(this.size - 1, this.size - 2)]);
                }
            }

            step() {
                this.diffuse(1, this.Vx0, this.Vx, this.viscosity, this.dt);
                this.diffuse(2, this.Vy0, this.Vy, this.viscosity, this.dt);
                this.project(this.Vx0, this.Vy0, this.Vx, this.Vy);
                this.advect(1, this.Vx, this.Vx0, this.Vx0, this.Vy0, this.dt);
                this.advect(2, this.Vy, this.Vy0, this.Vx0, this.Vy0, this.dt);
                this.project(this.Vx, this.Vy, this.Vx0, this.Vy0);
                this.diffuse(0, this.densityR0, this.densityR, this.diffusion, this.dt);
                this.diffuse(0, this.densityG0, this.densityG, this.diffusion, this.dt);
                this.diffuse(0, this.densityB0, this.densityB, this.diffusion, this.dt);
                this.advect(0, this.densityR, this.densityR0, this.Vx, this.Vy, this.dt);
                this.advect(0, this.densityG, this.densityG0, this.Vx, this.Vy, this.dt);
                this.advect(0, this.densityB, this.densityB0, this.Vx, this.Vy, this.dt);

                for (let i = 0; i < this.densityR.length; i++) {
                    this.densityR[i] = Math.max(0, this.densityR[i] - FLUID_FADE_RATE * 255 * this.dt);
                    this.densityG[i] = Math.max(0, this.densityG[i] - FLUID_FADE_RATE * 255 * this.dt);
                    this.densityB[i] = Math.max(0, this.densityB[i] - FLUID_FADE_RATE * 255 * this.dt);
                }
            }

            draw(ctx) {
                for (let y = 0; y < this.size; y++) {
                    for (let x = 0; x < this.size; x++) {
                        const idx = this.IX(x, y);
                        const r = Math.min(255, Math.max(0, Math.floor(this.densityR[idx])));
                        const g = Math.min(255, Math.max(0, Math.floor(this.densityG[idx])));
                        const b = Math.min(255, Math.max(0, Math.floor(this.densityB[idx])));
                        if (r > 1 || g > 1 || b > 1) {
                             ctx.fillStyle = `rgb(${r},${g},${b})`;
                             ctx.fillRect(x * this.scale, y * this.scale, this.scale, this.scale);
                        }
                    }
                }
            }
            clear() {
                this.densityR.fill(0); this.densityG.fill(0); this.densityB.fill(0);
                this.densityR0.fill(0); this.densityG0.fill(0); this.densityB0.fill(0);
                this.Vx.fill(0); this.Vy.fill(0);
                this.Vx0.fill(0); this.Vy0.fill(0);
            }
        }


        // --- Particle Class (for fluid visualization) ---
        class Particle {
            constructor(x, y, fluidFieldRef) {
                this.pos = new Vec2(x, y);
                this.vel = new Vec2(Math.random() * 0.2 - 0.1, Math.random() * 0.2 - 0.1);
                this.fluidField = fluidFieldRef;
                this.life = 1.0;
                this.lifeDecay = PARTICLE_BASE_LIFE_DECAY + Math.random() * PARTICLE_LIFE_DECAY_RANDOM_FACTOR;
                this.size = Math.random() * 1.5 + 0.5;
                this.isEaten = false;
            }

            update(dt) {
                if (this.isEaten) {
                    this.life -= 0.1 * dt * 60;
                     if (this.life <= 0) this.respawn();
                    return;
                }

                if (!this.fluidField) return;
                const fluidGridX = Math.floor(this.pos.x / this.fluidField.scale);
                const fluidGridY = Math.floor(this.pos.y / this.fluidField.scale);
                const idx = this.fluidField.IX(fluidGridX, fluidGridY);

                const fluidVelX = this.fluidField.Vx[idx];
                const fluidVelY = this.fluidField.Vy[idx];

                this.vel.x = this.vel.x * (1.0 - PARTICLE_FLUID_INFLUENCE) + fluidVelX * PARTICLE_FLUID_INFLUENCE;
                this.vel.y = this.vel.y * (1.0 - PARTICLE_FLUID_INFLUENCE) + fluidVelY * PARTICLE_FLUID_INFLUENCE;
                this.vel.x += (Math.random() - 0.5) * 0.05;
                this.vel.y += (Math.random() - 0.5) * 0.05;

                this.pos = this.pos.add(this.vel.mul(dt * 100));

                if (IS_WORLD_WRAPPING) {
                    if (this.pos.x < 0) this.pos.x += WORLD_WIDTH;
                    if (this.pos.x > WORLD_WIDTH) this.pos.x -= WORLD_WIDTH;
                    if (this.pos.y < 0) this.pos.y += WORLD_HEIGHT;
                    if (this.pos.y > WORLD_HEIGHT) this.pos.y -= WORLD_HEIGHT;
                } else {
                    if (this.pos.x < 0 || this.pos.x > WORLD_WIDTH || this.pos.y < 0 || this.pos.y > WORLD_HEIGHT) {
                        if (!IS_PARTICLE_LIFE_INFINITE) this.life = 0;
                    }
                }

                if (!IS_PARTICLE_LIFE_INFINITE) {
                    this.life -= (PARTICLE_BASE_LIFE_DECAY + Math.random() * PARTICLE_LIFE_DECAY_RANDOM_FACTOR) * dt * 60;
                    if (this.life <=0) {
                       this.respawn();
                    }
                } else {
                    this.life = 1.0;
                }
            }

            respawn() {
                this.pos.x = Math.random() * WORLD_WIDTH;
                this.pos.y = Math.random() * WORLD_HEIGHT;
                this.vel = new Vec2(Math.random() * 0.2 - 0.1, Math.random() * 0.2 - 0.1);
                this.life = 1.0  + Math.random() * 0.5;
                this.isEaten = false;
            }

            draw(ctx) {
                const alpha = IS_PARTICLE_LIFE_INFINITE ? 0.7 : Math.max(0, this.life * 0.7);
                if (alpha <= 0.01 && !IS_PARTICLE_LIFE_INFINITE) return;
                ctx.fillStyle = `rgba(220, 220, 250, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }


        // --- Simulation Setup ---
        function initializePopulation() {
            softBodyPopulation = [];
            isAnySoftBodyUnstable = false;
            updateInstabilityIndicator();
            nextSoftBodyId = 0;

            for (let i = 0; i < INITIAL_POPULATION_SIZE; i++) {
                const margin = 50;
                const randX = margin + Math.random() * (WORLD_WIDTH - margin * 2);
                const randY = margin + Math.random() * (WORLD_HEIGHT - margin * 2);
                softBodyPopulation.push(new SoftBody(nextSoftBodyId++, randX, randY));
            }
            lastTime = performance.now();
            updatePopulationCount();
        }


        function initFluidSimulation() {
            const fluidGridSize = 128;
            const fluidScale = WORLD_WIDTH / fluidGridSize;
            fluidField = new FluidField(fluidGridSize, FLUID_DIFFUSION, FLUID_VISCOSITY, 1/60, fluidScale);
            fluidField.useWrapping = IS_WORLD_WRAPPING;
        }

        function initParticles() {
            particles = [];
            if (!fluidField) {
                console.warn("Fluid field not initialized when trying to create particles. Initializing now.");
                initFluidSimulation();
            }
            for (let i = 0; i < NUM_PARTICLES; i++) {
                particles.push(new Particle(Math.random() * WORLD_WIDTH, Math.random() * WORLD_HEIGHT, fluidField));
            }
        }

        function applyVelocityEmitters() {
            if (!fluidField || EMITTER_STRENGTH <= 0) return;
            for (const emitter of velocityEmitters) {
                fluidField.addVelocity(emitter.gridX, emitter.gridY,
                                       emitter.forceX * EMITTER_STRENGTH,
                                       emitter.forceY * EMITTER_STRENGTH);
            }
        }


        // --- Physics Update ---
        function updatePhysics(dt) {
            if (IS_SIMULATION_PAUSED) {
                requestAnimationFrame(gameLoop);
                return;
            }

            // Removed fluidField.isSolid update logic here

            applyVelocityEmitters();

            if (selectedSoftBodyPoint && selectedSoftBodyPoint.point.isFixed && fluidField) {
                const activeBody = selectedSoftBodyPoint.body;
                const point = selectedSoftBodyPoint.point;
                const displacementX = point.pos.x - point.prevPos.x;
                const displacementY = point.pos.y - point.prevPos.y;
                const movementMagnitudeSq = displacementX*displacementX + displacementY*displacementY;
                const movementThresholdSq = 0.01 * 0.01;

                if (movementMagnitudeSq > movementThresholdSq) {
                    const fluidGridX = Math.floor(point.pos.x / fluidField.scale);
                    const fluidGridY = Math.floor(point.pos.y / fluidField.scale);

                    fluidField.addVelocity(fluidGridX, fluidGridY,
                                           displacementX * SOFT_BODY_PUSH_STRENGTH,
                                           displacementY * SOFT_BODY_PUSH_STRENGTH);
                    fluidField.addDensity(fluidGridX, fluidGridY, 60, 60, 80, 15);
                }
            }

            if (fluidField) {
                fluidField.dt = dt;
                fluidField.step();
            }

            let currentAnyUnstable = false;
            let newOffspring = [];

            for (let i = softBodyPopulation.length - 1; i >= 0; i--) {
                const body = softBodyPopulation[i];
                if (!body.isUnstable) {
                    body.updateSelf(dt, fluidField);
                    if (body.isUnstable) {
                        currentAnyUnstable = true;
                    } else if (body.creatureEnergy >= MAX_CREATURE_ENERGY && body.canReproduce) {
                        newOffspring.push(...body.reproduce());
                    }
                }
            }
            softBodyPopulation.push(...newOffspring);

            for (let particle of particles) {
                particle.update(dt);
            }

            if(currentAnyUnstable && !isAnySoftBodyUnstable) {
                isAnySoftBodyUnstable = true;
            } else if (!currentAnyUnstable && isAnySoftBodyUnstable && !softBodyPopulation.some(b => b.isUnstable)) {
                isAnySoftBodyUnstable = false;
            }
            updateInstabilityIndicator();

            let removedCount = 0;
            for (let i = softBodyPopulation.length - 1; i >= 0; i--) {
                if (softBodyPopulation[i].isUnstable) {
                    softBodyPopulation.splice(i, 1);
                    removedCount++;
                }
            }

            const neededToMaintainTarget = INITIAL_POPULATION_SIZE - softBodyPopulation.length;
            if (removedCount > 0 && neededToMaintainTarget > 0) {
                 for (let i = 0; i < neededToMaintainTarget; i++) {
                     if (softBodyPopulation.length < INITIAL_POPULATION_SIZE * 2) {
                         const margin = 50;
                         const randX = margin + Math.random() * (WORLD_WIDTH - margin * 2);
                         const randY = margin + Math.random() * (WORLD_HEIGHT - margin * 2);
                         softBodyPopulation.push(new SoftBody(nextSoftBodyId++, randX, randY));
                     }
                 }
            }
            updatePopulationCount();


            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- Drawing ---
        function draw() {
            ctx.fillStyle = '#222';
            ctx.fillRect(0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);

            ctx.save();
            ctx.translate(-viewOffsetX, -viewOffsetY);

            if (fluidField) {
                fluidField.draw(ctx);
            }
            for (let particle of particles) {
                particle.draw(ctx);
            }
            for (let body of softBodyPopulation) {
                body.drawSelf(ctx);
            }

            // Draw current emitter preview arrow if it exists
            if (IS_EMITTER_EDIT_MODE && currentEmitterPreview && fluidField) {
                ctx.beginPath();
                ctx.moveTo(currentEmitterPreview.startX, currentEmitterPreview.startY);
                ctx.lineTo(currentEmitterPreview.endX, currentEmitterPreview.endY);
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)'; // Yellow preview
                ctx.lineWidth = 2;
                ctx.stroke();
                // Arrowhead
                const angle = Math.atan2(currentEmitterPreview.endY - currentEmitterPreview.startY, currentEmitterPreview.endX - currentEmitterPreview.startX);
                ctx.lineTo(currentEmitterPreview.endX - 10 * Math.cos(angle - Math.PI / 6), currentEmitterPreview.endY - 10 * Math.sin(angle - Math.PI / 6));
                ctx.moveTo(currentEmitterPreview.endX, currentEmitterPreview.endY);
                ctx.lineTo(currentEmitterPreview.endX - 10 * Math.cos(angle + Math.PI / 6), currentEmitterPreview.endY - 10 * Math.sin(angle + Math.PI / 6));
                ctx.stroke();
            }

            // Draw existing emitters
            if (fluidField && velocityEmitters.length > 0) {
                 for (const emitter of velocityEmitters) {
                    const startX = (emitter.gridX + 0.5) * fluidField.scale;
                    const startY = (emitter.gridY + 0.5) * fluidField.scale;
                    const endX = startX + emitter.forceX * EMITTER_STRENGTH * 20; // Scale for visibility
                    const endY = startY + emitter.forceY * EMITTER_STRENGTH * 20;

                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = 'rgba(0, 200, 255, 0.5)'; // Cyan
                    ctx.lineWidth = 1 + Math.sqrt(emitter.forceX**2 + emitter.forceY**2) * EMITTER_STRENGTH * 0.5;
                    ctx.stroke();
                     // Arrowhead
                    const angle = Math.atan2(endY - startY, endX - startX);
                    if (Math.abs(endX-startX) > 0.1 || Math.abs(endY-startY) > 0.1) { // Only draw arrowhead if not zero vector
                        ctx.lineTo(endX - 8 * Math.cos(angle - Math.PI / 6), endY - 8 * Math.sin(angle - Math.PI / 6));
                        ctx.moveTo(endX, endY);
                        ctx.lineTo(endX - 8 * Math.cos(angle + Math.PI / 6), endY - 8 * Math.sin(angle + Math.PI / 6));
                        ctx.stroke();
                    }
                }
            }


            ctx.restore();
        }

        // --- Game Loop ---
        let animationFrameId = null;
        function gameLoop(timestamp) {
            if (IS_SIMULATION_PAUSED) {
                animationFrameId = requestAnimationFrame(gameLoop);
                return;
            }

            deltaTime = (timestamp - lastTime) / 1000;
            if (isNaN(deltaTime) || deltaTime <= 0) deltaTime = 1/60;
            lastTime = timestamp;

            const currentMaxDeltaTime = MAX_DELTA_TIME_MS / 1000.0;
            deltaTime = Math.min(deltaTime, currentMaxDeltaTime);

            updatePhysics(deltaTime);
        }

        // --- Config Import/Export ---
        function handleExportConfig() {
            const config = {
                bodyFluidEntrainment: BODY_FLUID_ENTRAINMENT_FACTOR,
                fluidCurrentStrength: FLUID_CURRENT_STRENGTH_ON_BODY,
                softBodyPushStrength: SOFT_BODY_PUSH_STRENGTH,
                baseNodeCost: BASE_NODE_EXISTENCE_COST,
                motorNodeCost: MOTOR_NODE_ENERGY_COST,
                eaterNodeCost: EATER_NODE_ENERGY_COST,
                predatorNodeCost: PREDATOR_NODE_ENERGY_COST,
                reproductionCooldown: REPRODUCTION_COOLDOWN_TICKS,
                bodyRepulsionStrength: BODY_REPULSION_STRENGTH,
                bodyRepulsionRadiusFactor: BODY_REPULSION_RADIUS_FACTOR,
                maxTimestepMs: MAX_DELTA_TIME_MS,
                fluidDiffusion: FLUID_DIFFUSION,
                fluidViscosity: FLUID_VISCOSITY,
                fluidFadeRate: FLUID_FADE_RATE,
                isWorldWrapping: IS_WORLD_WRAPPING,
                numParticles: NUM_PARTICLES,
                particleFluidInfluence: PARTICLE_FLUID_INFLUENCE,
                particleBaseLifeDecay: PARTICLE_BASE_LIFE_DECAY,
                isParticleLifeInfinite: IS_PARTICLE_LIFE_INFINITE,
                emitterStrength: EMITTER_STRENGTH,
                velocityEmitters: velocityEmitters
            };
            const jsonString = JSON.stringify(config, null, 2);
            const blob = new Blob([jsonString], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sim_config.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log("Config exported.");
        }

        function handleImportConfig(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedConfig = JSON.parse(e.target.result);
                    applyImportedConfig(importedConfig);
                    console.log("Config imported successfully.");
                } catch (error) {
                    console.error("Error parsing imported config:", error);
                    alert("Failed to import config. Make sure it's a valid JSON file.");
                }
            };
            reader.readAsText(file);
            importConfigFile.value = '';
        }

        function applyImportedConfig(config) {
            if (config.bodyFluidEntrainment !== undefined) BODY_FLUID_ENTRAINMENT_FACTOR = config.bodyFluidEntrainment;
            if (config.fluidCurrentStrength !== undefined) FLUID_CURRENT_STRENGTH_ON_BODY = config.fluidCurrentStrength;
            if (config.softBodyPushStrength !== undefined) SOFT_BODY_PUSH_STRENGTH = config.softBodyPushStrength;
            if (config.reproductionCooldown !== undefined) REPRODUCTION_COOLDOWN_TICKS = config.reproductionCooldown;
            if (config.bodyRepulsionStrength !== undefined) BODY_REPULSION_STRENGTH = config.bodyRepulsionStrength;
            if (config.bodyRepulsionRadiusFactor !== undefined) BODY_REPULSION_RADIUS_FACTOR = config.bodyRepulsionRadiusFactor;
            if (config.maxTimestepMs !== undefined) MAX_DELTA_TIME_MS = config.maxTimestepMs;

            if (config.baseNodeCost !== undefined) BASE_NODE_EXISTENCE_COST = config.baseNodeCost;
            if (config.motorNodeCost !== undefined) MOTOR_NODE_ENERGY_COST = config.motorNodeCost;
            if (config.eaterNodeCost !== undefined) EATER_NODE_ENERGY_COST = config.eaterNodeCost;
            if (config.predatorNodeCost !== undefined) PREDATOR_NODE_ENERGY_COST = config.predatorNodeCost;
            if (config.emitterStrength !== undefined) EMITTER_STRENGTH = config.emitterStrength;
            if (config.velocityEmitters !== undefined) velocityEmitters = config.velocityEmitters;

            if (config.fluidDiffusion !== undefined) FLUID_DIFFUSION = config.fluidDiffusion;
            if (config.fluidViscosity !== undefined) FLUID_VISCOSITY = config.fluidViscosity;
            if (config.fluidFadeRate !== undefined) FLUID_FADE_RATE = config.fluidFadeRate;
            if (config.isWorldWrapping !== undefined) IS_WORLD_WRAPPING = config.isWorldWrapping;

            if (config.numParticles !== undefined) NUM_PARTICLES = config.numParticles;
            if (config.particleFluidInfluence !== undefined) PARTICLE_FLUID_INFLUENCE = config.particleFluidInfluence;
            if (config.particleBaseLifeDecay !== undefined) PARTICLE_BASE_LIFE_DECAY = config.particleBaseLifeDecay;
            if (config.isParticleLifeInfinite !== undefined) IS_PARTICLE_LIFE_INFINITE = config.isParticleLifeInfinite;

            bodyFluidEntrainmentSlider.value = BODY_FLUID_ENTRAINMENT_FACTOR;
            fluidCurrentStrengthSlider.value = FLUID_CURRENT_STRENGTH_ON_BODY;
            bodyPushStrengthSlider.value = SOFT_BODY_PUSH_STRENGTH;
            baseNodeCostSlider.value = BASE_NODE_EXISTENCE_COST;
            motorNodeCostSlider.value = MOTOR_NODE_ENERGY_COST;
            eaterNodeCostSlider.value = EATER_NODE_ENERGY_COST;
            predatorNodeCostSlider.value = PREDATOR_NODE_ENERGY_COST;
            emitterStrengthSlider.value = EMITTER_STRENGTH;

            reproductionCooldownSlider.value = REPRODUCTION_COOLDOWN_TICKS;
            bodyRepulsionStrengthSlider.value = BODY_REPULSION_STRENGTH;
            bodyRepulsionRadiusFactorSlider.value = BODY_REPULSION_RADIUS_FACTOR;
            maxTimestepSlider.value = MAX_DELTA_TIME_MS;
            fluidDiffusionSlider.value = FLUID_DIFFUSION;
            fluidViscositySlider.value = FLUID_VISCOSITY;
            fluidFadeSlider.value = FLUID_FADE_RATE;
            worldWrapToggle.checked = IS_WORLD_WRAPPING;
            emitterEditModeToggle.checked = IS_EMITTER_EDIT_MODE;
            numParticlesSlider.value = NUM_PARTICLES;
            particleFluidInfluenceSlider.value = PARTICLE_FLUID_INFLUENCE;
            particleLifeDecaySlider.value = PARTICLE_BASE_LIFE_DECAY;
            infiniteParticleLifeToggle.checked = IS_PARTICLE_LIFE_INFINITE;

            initializeAllSliderDisplays();

            if (fluidField) {
                fluidField.diffusion = FLUID_DIFFUSION;
                fluidField.viscosity = FLUID_VISCOSITY;
                fluidField.useWrapping = IS_WORLD_WRAPPING;
            }
            initParticles();

            console.log("Applied imported config. Reset population if needed for full effect on creatures.");
        }


        // Start the simulation
        initializeAllSliderDisplays();
        initFluidSimulation();
        initParticles();
        initializePopulation();
        updateInstabilityIndicator();
        animationFrameId = requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
