<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Tiny 2-Head Transformer Playground</title>

    <!-- ─── LIBRARIES ──────────────────────────────────────────────────────────── -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.21.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis@1.5.1/dist/tfjs-vis.umd.min.js"></script>

    <!-- ─── STYLES ────────────────────────────────────────────────────────────── -->
    <style>
        body {
            font-family: sans-serif;
            margin: 1.2rem;
            line-height: 1.4;
            max-width: 900px;
        }

        textarea, input[type=text] {
            width: 100%;
            box-sizing: border-box;
        }

        button {
            margin: .4rem .6rem .4rem 0;
            padding: .5rem 1rem;
        }

        #tokenViz {
            margin-top: 1rem;
            font-family: monospace;
        }

        .token {
            display: inline-block;
            padding: 4px 6px;
            margin: 1px;
            border-radius: 4px;
            color: #000;
        }

        #genOutput {
            margin-top: .8rem;
            white-space: pre-wrap;
            background: #f7f7f7;
            padding: .6rem;
            border-radius: 4px;
            min-height: 3rem;
        }

        #probViz table {
            border-collapse: collapse;
            margin-top: .6rem;
        }

        #probViz th, #probViz td {
            border: 1px solid #ccc;
            padding: 4px 6px;
            text-align: center;
        }

        #status {
            display: inline-block;
            min-width: 6rem;
        }
    </style>
</head>

<body>
<h2>Tiny 2-Head Transformer Playground</h2>

<label><strong>Training corpus (plain text, ≤ 1 kB):</strong></label><br>
<textarea id="inputText" rows="4">
hello world! this is a tiny transformer demo.
have fun teaching it character-level next-token prediction!
</textarea><br>

<!-- TRAINING -->
<button id="initBtn">① Reset Model</button>
<button id="trainStepBtn" disabled>② Train 1 Step</button>
<button id="trainEpochBtn" disabled>③ Train N Steps</button>
<input id="numSteps" type="number" value="200" min="1" style="width:6rem">
<label for="numSteps">steps</label>
<span id="status"></span>

<div id="lossVis" style="margin-top:1rem;"></div>
<div id="tokenViz">(Start training to see attention weights)</div>

<!-- GENERATION -->
<hr>
<h3>Generate text</h3>
<label for="promptInput">Prompt:</label>
<input id="promptInput" type="text" value="hello ">
<label for="genLen">Length:</label>
<input id="genLen" type="number" min="1" value="100" style="width:6rem">
<button id="genBtn" disabled>Generate block</button>
<button id="stepGenBtn" disabled>➜ Step-by-step</button>

<div id="genOutput"></div>
<div id="probViz"></div>

<!-- ─── SCRIPT ──────────────────────────────────────────────────────────────── -->
<script>
    (async () => {

        /* ───────── CONSTANTS ───────── */
        const MAX_SEQ_LEN = 32;
        const D_MODEL = 64;
        const HEADS = 2;                    // NEW
        const HEAD_DIM = D_MODEL / HEADS;
        const LR = 5e-3;
        const OPTIMIZER = tf.train.adam(LR);
        const TEMPERATURE = 0.3;                  // friendlier than 0.1
        const PAD_TOKEN = '_';

        /* ───────── TOKENISER ───────── */
        const CHARS = Array.from(new Set(
            Array(128).fill(0).map((_, i) => String.fromCharCode(i)).filter(c => c >= ' ' && c <= '~')
        ));
        const PAD = '_';
        if (!CHARS.includes(PAD)) CHARS.push(PAD);
        const stoi = Object.fromEntries(CHARS.map((c, i) => [c, i]));
        const itos = CHARS;
        const VOCAB_SIZE = CHARS.length;

        function textToTensor(text) {
            const ids = [...text].slice(0, MAX_SEQ_LEN).map(ch => stoi[ch] ?? stoi['?']);
            while (ids.length < MAX_SEQ_LEN) ids.push(stoi[PAD]);     // RIGHT-pad (fixes label clash)
            return tf.tensor1d(ids, 'int32');
        }

        /* ───────── MODEL ───────── */
        class TinyTransformer {
            constructor() {
                this.embed = tf.variable(tf.randomNormal([VOCAB_SIZE, D_MODEL]).mul(0.1));
                this.posEmbed = tf.variable(tf.randomNormal([MAX_SEQ_LEN, D_MODEL]).mul(0.1));
                this.ff1 = tf.variable(tf.randomNormal([D_MODEL, 4 * D_MODEL]).mul(0.1));
                this.ff2 = tf.variable(tf.randomNormal([4 * D_MODEL, D_MODEL]).mul(0.1));
                this.outW = tf.variable(tf.randomNormal([D_MODEL, VOCAB_SIZE]).mul(0.1));
                this.outB = tf.variable(tf.zeros([VOCAB_SIZE]));
            }

            forward(x) {
                return tf.tidy(() => {
                    const [batch, s] = x.shape;
                    const tok = tf.gather(this.embed, x);
                    const pos = this.posEmbed.slice([0, 0], [s, D_MODEL]).expandDims(0).tile([batch, 1, 1]);
                    const emb = tok.add(pos);

                    const mask = tf.cast(tf.notEqual(x, stoi[PAD_TOKEN]), 'float32'); // [b,s]
                    const maskAdd = mask.reshape([batch, 1, s]).sub(1).mul(1e4);     // 0 → -1e4

                    const ctxs = [], attns = [];
                    tf.split(emb, HEADS, -1).forEach(h => {
                        const q = h.slice([0, s - 1, 0], [batch, 1, HEAD_DIM]);
                        const k = h, scores = tf.matMul(q, k, false, true).div(Math.sqrt(HEAD_DIM)).add(maskAdd);
                        const a = tf.softmax(scores, -1);
                        attns.push(a.reshape([batch, s]));
                        ctxs.push(tf.matMul(a, k).reshape([batch, HEAD_DIM]));
                    });
                    const context = tf.concat(ctxs, 1), attnAvg = tf.addN(attns).div(HEADS);

                    const hidden = tf.relu(tf.matMul(context, this.ff1));
                    const logits = tf.add(tf.matMul(tf.matMul(hidden, this.ff2), this.outW), this.outB);
                    return {logits, attn: attnAvg};
                });
            }

            async trainStep(input, target) {
                const lossT = OPTIMIZER.minimize(() => {
                    const {logits} = this.forward(input.expandDims(0));
                    return tf.losses.softmaxCrossEntropy(
                        tf.oneHot(tf.tensor1d([target], 'int32'), VOCAB_SIZE), logits);
                }, true, [this.embed, this.posEmbed, this.ff1, this.ff2, this.outW, this.outB]);
                const v = await lossT.data();
                lossT.dispose();
                return v[0];
            }

            /** returns [id, probsArray] */
            sampleWithProbs(ctxTensor, temp = TEMPERATURE) {
                return tf.tidy(() => {
                    const {logits} = this.forward(ctxTensor.expandDims(0));             // [1,V]
                    const probs = tf.softmax(logits.div(temp)).flatten();
                    const id = tf.multinomial(probs, 1, null, true).arraySync()[0];
                    const arr = probs.arraySync();
                    logits.dispose();
                    probs.dispose();
                    return [id, arr];
                });
            }
        }

        /* ───────── DATA ───────── */
        function* makeCharDataset(text) {
            const clean = [...text].filter(ch => ch >= ' ' && ch <= '~');
            for (let i = 1; i < clean.length; ++i) {
                const window = clean.slice(Math.max(0, i - (MAX_SEQ_LEN - 1)), i);
                yield {inputTensor: textToTensor(window.join('')), targetId: stoi[clean[i]]};
            }
        }

        /* ───────── VISUALS ───────── */
        const lossDiv = document.getElementById('lossVis');
        const tokenDiv = document.getElementById('tokenViz');
        let lossValues = [];

        function chart() {
            tfvis.render.linechart(lossDiv,
                {values: [lossValues], series: ['loss']}, {width: 500, height: 300, yLabel: 'x-ent', xLabel: 'step'});
        }

        function renderAttention(toks, wts) {
            tokenDiv.innerHTML = '';
            const m = Math.max(...wts);
            toks.forEach((t, i) => {
                const s = document.createElement('span');
                s.textContent = t;
                s.className = 'token';
                s.style.backgroundColor = `rgba(255,165,0,${m ? wts[i] / m : 0})`;
                tokenDiv.appendChild(s);
            });
        }

        function probTable(arr) {
            const top = [...arr.map((p, i) => ({c: itos[i], p}))].sort((a, b) => b.p - a.p).slice(0, 10);
            probDiv.innerHTML =
                `<table><thead><tr><th>#</th><th>tok</th><th>p%</th></tr></thead><tbody>` +
                top.map((t, i) => `<tr><td>${i + 1}</td><td>${t.c === ' ' ? '␣' : t.c}</td><td>${(t.p * 100).toFixed(1)}</td></tr>`).join('')
                + `</tbody></table>`;
        }

        /* ───────── UI ELEMENTS ───────── */
        const initBtn = document.getElementById('initBtn');
        const stepBtn = document.getElementById('trainStepBtn');
        const epochBtn = document.getElementById('trainEpochBtn');
        const nStepsIn = document.getElementById('numSteps');
        const statusSp = document.getElementById('status');
        const textArea = document.getElementById('inputText');
        const genBtn = document.getElementById('genBtn');
        const stepGen = document.getElementById('stepGenBtn');
        const genLenIn = document.getElementById('genLen');
        const promptIn = document.getElementById('promptInput');
        const genOut = document.getElementById('genOutput');
        const probDiv = document.getElementById('probViz');

        /* ───────── STATE ───────── */
        let model, dataset, idx, ctxArr = null, generated = '';

        /* ───────── FUNCTIONS ───────── */
        function reset() {
            model = new TinyTransformer();
            dataset = [...makeCharDataset(textArea.value)];
            idx = 0;
            ctxArr = null;
            generated = '';
            lossValues = [];
            lossDiv.innerHTML = '';
            tokenDiv.textContent = '…';
            genOut.textContent = '';
            probDiv.innerHTML = '';
            statusSp.textContent = '';
            stepBtn.disabled = epochBtn.disabled = genBtn.disabled = stepGen.disabled = false;
        }

        async function trainOne() {
            if (idx >= dataset.length) idx = 0;
            const s = dataset[idx++];
            const loss = await model.trainStep(s.inputTensor, s.targetId);
            const {attn} = model.forward(s.inputTensor.expandDims(0));
            renderAttention(s.inputTensor.arraySync().map(i => itos[i]), attn.arraySync());
            attn.dispose();
            return loss;
        }

        function genBlock(prompt, len) {
            let ctx = [...prompt].map(ch => stoi[ch] ?? stoi['?']);
            let out = prompt;
            for (let i = 0; i < len; i++) {
                const ids = ctx.slice(-MAX_SEQ_LEN);
                while (ids.length < MAX_SEQ_LEN) ids.push(stoi[PAD]);
                const t = tf.tensor1d(ids, 'int32');
                const [id] = model.sampleWithProbs(t);
                t.dispose();
                ctx.push(id);
                out += itos[id];
            }
            return out;
        }

        function stepGenerate() {
            if (ctxArr === null) {
                ctxArr = [...promptIn.value].map(ch => stoi[ch] ?? stoi['?']);
                generated = promptIn.value;
                genOut.textContent = generated;
            }
            const ids = ctxArr.slice(-MAX_SEQ_LEN);
            while (ids.length < MAX_SEQ_LEN) ids.push(stoi[PAD]);
            const t = tf.tensor1d(ids, 'int32');
            const [id, arr] = model.sampleWithProbs(t);
            t.dispose();
            ctxArr.push(id);
            generated += itos[id];
            genOut.textContent = generated;
            probTable(arr);
        }

        /* ───────── BUTTONS ───────── */
        initBtn.onclick = reset;
        stepBtn.onclick = async () => {
            const l = await trainOne();
            lossValues.push({x: lossValues.length, y: l});
            chart();
        };
        epochBtn.onclick = async () => {
            const N = parseInt(nStepsIn.value);
            stepBtn.disabled = epochBtn.disabled = true;
            statusSp.textContent = `(0 / ${N})`;
            for (let i = 0; i < N; i++) {
                const l = await trainOne();
                lossValues.push({x: lossValues.length, y: l});
                if (i % 10 === 0) {
                    chart();
                    await tf.nextFrame();
                }
                if (i % 20 === 0) statusSp.textContent = `(${i + 1} / ${N})`;
            }
            chart();
            statusSp.textContent = '';
            stepBtn.disabled = epochBtn.disabled = false;
        };
        genBtn.onclick = () => {
            genOut.textContent = genBlock(promptIn.value, parseInt(genLenIn.value));
        };
        stepGen.onclick = stepGenerate;

        /* ─── AUTO-INIT ─── */
        reset();
    })();
</script>
</body>
</html>
