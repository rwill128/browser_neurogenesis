<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Soft Body Evolution - Neural Network Overhaul Phase 1</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            font-family: sans-serif;
            color: #eee;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #pageContainer {
            display: flex;
            flex-direction: row;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }

        #simulationAndInfoWrapper {
            display: flex;
            flex-direction: row;
            justify-content: flex-start;
            align-items: stretch;
            gap: 10px;
            flex-grow: 1;
            padding: 10px;
            box-sizing: border-box;
            height: 100%;
            position: relative;
        }
        #infoPanel {
            position: fixed;
            top: 15px;
            left: -330px;
            width: 300px;
            max-height: calc(100vh - 30px);
            background-color: rgba(30,30,30,0.95);
            border: 1px solid #555;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            z-index: 1000;
            color: #eee;
            font-size: 0.8em;
            display: block;
            opacity: 0;
            visibility: hidden;
            transition: left 0.3s ease-in-out, opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
            overflow-y: auto;
            box-sizing: border-box;
        }
        #infoPanel.open {
            left: 15px;
            opacity: 1;
            visibility: visible;
        }
        #canvasContainer {
            flex-grow: 1;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            background-color: #000;
            border: 1px solid #444;
            border-radius: 8px;
        }
        canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            cursor: default;
        }
        canvas.emitter-edit-mode {
            cursor: crosshair;
        }

        .ui-button-top-right {
            position: fixed;
            padding: 8px 12px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 1002;
        }
        .ui-button-top-right:hover {
            background-color: #0056b3;
        }

        #toggleControlsButton {
            top: 15px;
            right: 15px;
        }
        #screensaverButton {
            top: 15px;
            right: 100px;
        }


        #controls {
            position: fixed;
            top: 0;
            right: -360px;
            width: 330px;
            height: 100vh;
            background-color: rgba(40,40,40,0.95);
            padding: 15px;
            border-left: 1px solid #555;
            box-shadow: -5px 0 15px rgba(0,0,0,0.3);
            overflow-y: auto;
            z-index: 1001;
            transition: right 0.3s ease-in-out;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-sizing: border-box;
        }
        #controls.open {
            right: 0;
        }
        #controls div.control-group {
            padding: 10px;
            border: 1px solid #555;
            border-radius: 6px;
            background-color: rgba(50,50,50,0.8);
            min-width: auto;
            max-width: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        #controls label.slider-label, #controls label.checkbox-label, #controls label.input-label { display: block; margin-bottom: 2px; font-size: 0.85em; font-weight: bold; color: #ddd; text-align: left; }
        #controls label.checkbox-label { margin-top: 8px; display: flex; align-items: center; }
        #controls input[type="checkbox"] { margin-left: 5px; }
        #controls input[type="number"] { width: 100%; padding: 5px; margin-top: 2px; margin-bottom: 5px; box-sizing: border-box; background-color: #333; color: #eee; border: 1px solid #555; border-radius: 3px;}
        #controls span.slider-value { display: block; font-size: 0.8em; text-align: right; color: #00aeff; margin-bottom: 3px; min-height: 1em; }
        #controls input[type="range"] { width: 100%; margin-top: 0; box-sizing: border-box; }
        #controls input[type="range"]:disabled + span.slider-value, #controls input[type="range"]:disabled ~ label.slider-label, #controls input[type="range"]:disabled { color: #777; opacity: 0.6; }
        #controls button { padding: 8px 12px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 8px; width: 100%; box-sizing: border-box; }
        #controls button:hover { background-color: #0056b3; }
        .control-group h4 { margin-top: 0; margin-bottom: 10px; text-align: center; color: #00aeff; width: 100%; font-size: 1em; }
        .indicator-label { font-size: 0.85em; color: #ddd; margin-top: 8px; }
        .indicator-light { display: inline-block; width: 12px; height: 12px; border-radius: 50%; background-color: #4CAF50; margin-left: 5px; vertical-align: middle; border: 1px solid #222; transition: background-color 0.3s; }
        .indicator-light.unstable { background-color: #F44336; }
        #populationCount { margin-top: 10px; font-size: 0.9em; color: #ccc; text-align: center; width: 100%; }
        .viewport-instructions { font-size: 0.8em; color: #bbb; text-align: center; margin-top: 5px; }
        #infoPanel h5 { margin-top: 0; margin-bottom: 8px; color: #00aeff; border-bottom: 1px solid #444; padding-bottom: 5px; }
        #infoPanel p { margin: 3px 0; line-height: 1.4; }
        #infoPanel strong { color: #bbb; }
        #infoPanel .info-section { margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px dashed #333; }
        #infoPanel .info-section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }

        #allPointsInfoContainer .point-info-entry {
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
            margin-bottom: 8px;
        }
        #allPointsInfoContainer .point-info-entry:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
         #allPointsInfoContainer .point-info-entry h6 {
            margin: 5px 0 3px 0;
            color: #7fdbff; /* A lighter blue for sub-headings */
            font-size: 0.9em;
        }


        #closeInfoPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #555;
            color: white;
            border: none;
            padding: 3px 7px;
            cursor: pointer;
            border-radius: 3px;
        }

        /* Screensaver Mode Styles */
        body.screensaver-active #controls,
        body.screensaver-active #infoPanel,
        body.screensaver-active #toggleControlsButton,
        body.screensaver-active #screensaverButton.in-screensaver { /* Hide button when in screensaver via CSS */
            display: none !important;
        }

        body.css-screensaver-active #pageContainer {
             position: fixed !important;
             top: 0 !important;
             left: 0 !important;
             width: 100vw !important;
             height: 100vh !important;
             padding: 0 !important;
             margin: 0 !important;
             z-index: 2000 !important;
             display: flex !important;
             flex-direction: column !important;
        }
         body.css-screensaver-active #simulationAndInfoWrapper {
            flex-grow: 1 !important;
            width: 100% !important;
            height: 100% !important;
            padding: 0 !important;
            gap: 0 !important;
            display: flex !important;
        }
        body.css-screensaver-active #canvasContainer {
            flex-grow: 1 !important;
            width: 100% !important;
            height: 100% !important;
            border-radius: 0 !important;
            border: none !important;
            background-color: #000 !important; /* Make background black */
        }
    </style>
</head>
<body>
    <div id="pageContainer">
        <div id="simulationAndInfoWrapper">
            <div id="infoPanel"> <button id="closeInfoPanel">X</button>
                <div class="info-section">
                    <h5>Soft Body Info</h5>
                    <p><strong>ID:</strong> <span id="infoBodyId">-</span></p>
                    <p><strong>Stiffness:</strong> <span id="infoBodyStiffness">-</span></p>
                    <p><strong>Damping:</strong> <span id="infoBodyDamping">-</span></p>
                    <p><strong>Motor Impulse Interval:</strong> <span id="infoBodyMotorInterval">-</span></p>
                    <p><strong>Motor Impulse Cap:</strong> <span id="infoBodyMotorCap">-</span></p>
                    <p><strong>Emitter Strength:</strong> <span id="infoBodyEmitterStrength">-</span></p>
                    <p><strong>Emitter Direction:</strong> X: <span id="infoBodyEmitterDirX">-</span>, Y: <span id="infoBodyEmitterDirY">-</span></p>
                    <p><strong>Num Offspring:</strong> <span id="infoBodyNumOffspring">-</span></p>
                    <p><strong>Offspring Spawn Radius:</strong> <span id="infoBodyOffspringRadius">-</span></p>
                    <p><strong>Point Add Chance:</strong> <span id="infoBodyPointAddChance">-</span></p>
                    <p><strong>Spring Connection Radius:</strong> <span id="infoBodySpringConnectionRadius">-</span></p>
                    <p><strong>Energy:</strong> <span id="infoBodyEnergy">-</span></p>
                    <p><strong>Ticks Since Birth:</strong> <span id="infoBodyTicksBirth">-</span></p>
                    <p><strong>Can Reproduce:</strong> <span id="infoBodyCanReproduce">-</span></p>
                </div>

                <div id="allPointsInfoContainer" class="info-section">
                    </div>
            </div>
            <div id="canvasContainer">
                <canvas id="simulationCanvas"></canvas>
            </div>
        </div>

        <button id="toggleControlsButton" class="ui-button-top-right">Controls</button>
        <button id="screensaverButton" class="ui-button-top-right">Enter Screensaver</button>

        <div id="controls">
            <div class="control-group">
                <h4>Viewport & Sim</h4>
                <div class="viewport-instructions">WASD/Right-Drag to Pan, Scroll to Zoom</div>
                <label for="worldWidthInput" class="input-label">World Width:</label>
                <input type="number" id="worldWidthInput" value="8000" step="100">
                <label for="worldHeightInput" class="input-label">World Height:</label>
                <input type="number" id="worldHeightInput" value="6000" step="100">
                <button id="resizeWorldButton">Resize World & Reset Sim</button>

                <label for="worldWrapToggle" class="checkbox-label">Wrap Edges:
                    <input type="checkbox" id="worldWrapToggle">
                </label>
                <label for="maxTimestep" class="slider-label">Max Timestep (ms):</label>
                <span id="maxTimestepValue" class="slider-value">10</span>
                <input type="range" id="maxTimestep" min="1" max="50" value="10" step="1">
                <label for="zoomSensitivitySlider" class="slider-label">Zoom Sensitivity:</label>
                <span id="zoomSensitivityValueSpan" class="slider-value">0.0200</span>
                <input type="range" id="zoomSensitivitySlider" min="0.005" max="0.03" value="0.02" step="0.0005">
                <button id="pauseResumeButton">Pause</button>
            </div>
            <div class="control-group">
                <h4>Soft Body (Global)</h4>
                <label for="creaturePopulationFloorSlider" class="slider-label">Creature Pop. Floor:</label>
                <span id="creaturePopulationFloorValueSpan" class="slider-value">10</span>
                <input type="range" id="creaturePopulationFloorSlider" min="1" max="1000" value="10" step="10">

                <label for="creaturePopulationCeilingSlider" class="slider-label">Creature Pop. Ceiling:</label>
                <span id="creaturePopulationCeilingValueSpan" class="slider-value">1000</span>
                <input type="range" id="creaturePopulationCeilingSlider" min="10" max="2000" value="1000" step="10">

                <label for="globalMutationRate" class="slider-label">Global Mutation Rate:</label>
                <span id="globalMutationRateValue" class="slider-value">0.25</span>
                <input type="range" id="globalMutationRate" min="0.1" max="3.0" value="0.25" step="0.05">

                <label for="bodyFluidEntrainment" class="slider-label">Fluid Entrainment (Floaters):</label>
                <span id="bodyFluidEntrainmentValue" class="slider-value">0.47</span>
                <input type="range" id="bodyFluidEntrainment" min="0.0" max="0.7" value="0.465" step="0.005">

                <label for="fluidCurrentStrength" class="slider-label">Fluid Current Str (Floaters):</label>
                <span id="fluidCurrentStrengthValue" class="slider-value">19.7</span>
                <input type="range" id="fluidCurrentStrength" min="0.0" max="30.0" value="19.7" step="0.1">

                <label for="bodyPushStrength" class="slider-label">Body Push Strength (Manual Drag):</label>
                <span id="bodyPushStrengthValue" class="slider-value">0.10</span>
                <input type="range" id="bodyPushStrength" min="0.0" max="2.0" value="0.10" step="0.05">

                <label for="reproductionCooldown" class="slider-label">Repro. Cooldown (frames):</label>
                <span id="reproductionCooldownValue" class="slider-value">1000</span>
                <input type="range" id="reproductionCooldown" min="100" max="5000" value="1000" step="50">

                <label for="bodyRepulsionStrength" class="slider-label">Body Repulsion Str:</label>
                <span id="bodyRepulsionStrengthValue" class="slider-value">100.0</span>
                <input type="range" id="bodyRepulsionStrength" min="0.0" max="200.0" value="100.0" step="0.5">

                <label for="bodyRepulsionRadiusFactor" class="slider-label">Body Repulsion Radius Factor:</label>
                <span id="bodyRepulsionRadiusFactorValue" class="slider-value">5.0</span>
                <input type="range" id="bodyRepulsionRadiusFactor" min="0.0" max="10.0" value="5.0" step="0.1">

                <div class="indicator-label">Any Unstable: <span id="instabilityLight" class="indicator-light"></span></div>
                <div id="populationCount">Population: 0</div>
                <button id="resetButton">Reset Population</button>
            </div>
            <div class="control-group">
                <h4>Energy Costs / Frame</h4>
                <label for="baseNodeCost" class="slider-label">Base Node Cost:</label>
                <span id="baseNodeCostValue" class="slider-value">0.3</span>
                <input type="range" id="baseNodeCost" min="0.0" max="50.0" value="0.3" step="0.1">

                <label for="emitterNodeCost" class="slider-label">Emitter Node Cost:</label>
                <span id="emitterNodeCostValue" class="slider-value">1.0000</span>
                <input type="range" id="emitterNodeCost" min="0.0" max="50.0" value="1.0" step="0.1">

                <label for="eaterNodeCost" class="slider-label">Eater Node Cost:</label>
                <span id="eaterNodeCostValue" class="slider-value">0.3</span>
                <input type="range" id="eaterNodeCost" min="0.0" max="50.0" value="0.3" step="0.1">

                <label for="predatorNodeCost" class="slider-label">Predator Node Cost:</label>
                <span id="predatorNodeCostValue" class="slider-value">0.8</span>
                <input type="range" id="predatorNodeCost" min="0.0" max="100.0" value="0.8" step="0.1">

                <label for="neuronNodeCost" class="slider-label">Neuron Node Cost:</label>
                <span id="neuronNodeCostValue" class="slider-value">0.0100</span>
                <input type="range" id="neuronNodeCost" min="0.0" max="0.5" value="0.01" step="0.001">
            </div>
            <div class="control-group">
                <h4>Fluid</h4>
                <label for="fluidGridSize" class="slider-label">Fluid Grid Resolution:</label>
                <span id="fluidGridSizeValue" class="slider-value">128</span>
                <input type="range" id="fluidGridSize" min="32" max="256" value="128" step="16">

                <label for="fluidDiffusion" class="slider-label">Diffusion:</label>
                <span id="fluidDiffusionValue" class="slider-value">4.7e-4</span>
                <input type="range" id="fluidDiffusion" min="0" max="0.001" value="0.00047" step="0.00001">

                <label for="fluidViscosity" class="slider-label">Viscosity:</label>
                <span id="fluidViscosityValue" class="slider-value">6.8e-5</span>
                <input type="range" id="fluidViscosity" min="0" max="0.00015" value="0.000068" step="0.000001">

                <label for="fluidFade" class="slider-label">Fade Rate:</label>
                <span id="fluidFadeValue" class="slider-value">0.002</span>
                <input type="range" id="fluidFade" min="0.0" max="1.0" value="0.002" step="0.001">

                <label for="maxFluidVelocityComponentSlider" class="slider-label">Max Fluid Vel. Component:</label>
                <span id="maxFluidVelocityComponentValueSpan" class="slider-value">0.5</span>
                <input type="range" id="maxFluidVelocityComponentSlider" min="0.1" max="10.0" value="0.5" step="0.1">

                <button id="clearFluidButton">Clear Fluid</button>
            </div>
            <div class="control-group">
                <h4>Particles</h4>
                <label for="particlePopulationFloorSlider" class="slider-label">Particle Pop. Floor:</label>
                <span id="particlePopulationFloorValueSpan" class="slider-value">5000</span>
                <input type="range" id="particlePopulationFloorSlider" min="0" max="10000" value="5000" step="50">

                <label for="particlePopulationCeilingSlider" class="slider-label">Particle Pop. Ceiling:</label>
                <span id="particlePopulationCeilingValueSpan" class="slider-value">20000</span>
                <input type="range" id="particlePopulationCeilingSlider" min="0" max="40000" value="20000" step="50">

                <label for="particlesPerSecondSlider" class="slider-label">Particles / Sec (if between floor/ceil):</label>
                <span id="particlesPerSecondValueSpan" class="slider-value">500</span>
                <input type="range" id="particlesPerSecondSlider" min="0" max="1000" value="500" step="1">

                <label for="particleFluidInfluence" class.slider-label="slider-label">Fluid Influence:</label>
                <span id="particleFluidInfluenceValue" class="slider-value">2.00</span>
                <input type="range" id="particleFluidInfluence" min="0.0" max="3.0" value="2.0" step="0.01">

                <label for="particleLifeDecay" id="particleLifeDecayLabel" class="slider-label">Life Decay Rate:</label>
                <span id="particleLifeDecayValue" class="slider-value">0.0010</span>
                <input type="range" id="particleLifeDecay" min="0.0001" max="0.02" value="0.001" step="0.0001">

                <label for="infiniteParticleLifeToggle" class="checkbox-label">Infinite Life:
                    <input type="checkbox" id="infiniteParticleLifeToggle">
                </label>

                <button id="resetParticlesButton">Reset Particles</button>
            </div>
            <div class="control-group">
                <h4>Env. Emitters</h4>
                <label for="emitterEditModeToggle" class="checkbox-label">Edit Emitters:
                    <input type="checkbox" id="emitterEditModeToggle">
                </label>
                <label for="emitterStrength" class="slider-label">Emitter Strength:</label>
                <span id="emitterStrengthValue" class="slider-value">3.0</span>
                <input type="range" id="emitterStrength" min="0.0" max="10.0" value="3.0" step="0.1">
                <button id="clearEmittersButton">Clear Emitters</button>
            </div>
            <div class="control-group">
                <h4>Configuration</h4>
                <button id="exportConfigButton">Export Config</button>
                <input type="file" id="importConfigFile" accept=".json" style="display: none;">
                <button id="importConfigButton">Import Config</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        let offscreenFluidCanvas, offscreenFluidCtx; // For smoother fluid rendering

        // --- Viewport and World Dimensions ---
        let WORLD_WIDTH = 8000;
        let WORLD_HEIGHT = 6000;
        const VIEW_PAN_SPEED = 80;

        canvas.width = WORLD_WIDTH;
        canvas.height = WORLD_HEIGHT;

        let viewOffsetX = 0;
        let viewOffsetY = 0;
        let viewZoom = 1.0;
        let ZOOM_SENSITIVITY; // Will be set by slider_config.json
        const MAX_ZOOM = 8.0;
        let MIN_ZOOM = 0.1;

        // Spatial Grid for optimization
        const GRID_CELL_SIZE = 100;
        let GRID_COLS = Math.ceil(WORLD_WIDTH / GRID_CELL_SIZE);
        let GRID_ROWS = Math.ceil(WORLD_HEIGHT / GRID_CELL_SIZE);
        let spatialGrid = [];

        // Critical Simulation Constants
        const MUTATION_CHANCE_REASSIGN_NEURON_LINK = 0.02;
        const NEURON_CHANCE = 0.1; // Chance for a point to become a neuron initially
        const ADD_POINT_MUTATION_CHANCE = 0.03;
        const NEW_POINT_OFFSET_RADIUS = 15;
        const MAX_PIXELS_PER_FRAME_DISPLACEMENT = 100;
        const MAX_SPRING_STRETCH_FACTOR = 4.0;
        const MAX_SPAN_PER_POINT_FACTOR = GRID_CELL_SIZE * 2;
        const DYE_PULL_RATE = 0.05;
        const PARTICLE_LIFE_DECAY_RANDOM_FACTOR = 0.002;
        const EATING_RADIUS_MULTIPLIER = 3.5;
        const PREDATION_RADIUS_MULTIPLIER = 2.5;
        const ENERGY_PER_PARTICLE = 25;
        const ENERGY_SAPPED_PER_PREDATION = 5;
        const MAX_CREATURE_ENERGY = 100;
        const OFFSPRING_INITIAL_ENERGY_SHARE = 0.25;
        const REPRODUCTION_ADDITIONAL_COST_FACTOR = 0.1;
        const OFFSPRING_PLACEMENT_ATTEMPTS = 10;
        const MUTATION_RATE_PERCENT = 0.1;
        const MUTATION_CHANCE_BOOL = 0.05;
        const MUTATION_CHANCE_NODE_TYPE = 0.1;
        const EMITTER_MOUSE_DRAG_SCALE = 0.1;
        const FLUID_MOUSE_DRAG_VELOCITY_SCALE = 0.1;

        // Neural Network Specific Constants
        const NEURAL_INPUT_SIZE = 8; // dyeR, dyeG, dyeB, energy, relComX, relComY, relComVelX, relComVelY
        const NEURAL_OUTPUTS_PER_EMITTER_SWIMMER = 6; // Fx, Fy, targetR, targetG, targetB, emissionStrength
        const DEFAULT_HIDDEN_LAYER_SIZE_MIN = 10;
        const DEFAULT_HIDDEN_LAYER_SIZE_MAX = 24; // Reduced from 30 for initial balance
        const MAX_NEURAL_FORCE_COMPONENT = 1.0; // Max force component from a neural output
        const MAX_NEURAL_EMISSION_PULL_STRENGTH = 1.0; // Max multiplier for DYE_PULL_RATE


        function initializeSpatialGrid() {
            GRID_COLS = Math.max(1, Math.ceil(WORLD_WIDTH / GRID_CELL_SIZE));
            GRID_ROWS = Math.max(1, Math.ceil(WORLD_HEIGHT / GRID_CELL_SIZE));
            spatialGrid = new Array(GRID_COLS * GRID_ROWS);
            for (let i = 0; i < spatialGrid.length; i++) {
                spatialGrid[i] = [];
            }
        }


        function populateSpatialGrid() {
            for (let i = 0; i < spatialGrid.length; i++) {
                spatialGrid[i] = [];
            }
            // Add soft body mass points to the grid
            softBodyPopulation.forEach(body => {
                if (body.isUnstable) return;
                body.massPoints.forEach(point => {
                    if (isNaN(point.pos.x) || isNaN(point.pos.y) || !isFinite(point.pos.x) || !isFinite(point.pos.y)) {
                        return;
                    }
                    const gx = Math.max(0, Math.min(GRID_COLS - 1, Math.floor(point.pos.x / GRID_CELL_SIZE)));
                    const gy = Math.max(0, Math.min(GRID_ROWS - 1, Math.floor(point.pos.y / GRID_CELL_SIZE)));

                    const gridIndex = gx + gy * GRID_COLS;
                    if(spatialGrid[gridIndex] && Number.isFinite(gridIndex) && gridIndex < spatialGrid.length) {
                        spatialGrid[gridIndex].push({ type: 'softbody_point', pointRef: point, bodyRef: body });
                    }
                });
            });
            // Add particles to the grid
            particles.forEach(particle => {
                if (particle.life <= 0) return; // Don't add dead/eaten particles
                 if (isNaN(particle.pos.x) || isNaN(particle.pos.y) || !isFinite(particle.pos.x) || !isFinite(particle.pos.y)) {
                    return;
                }
                const gx = Math.max(0, Math.min(GRID_COLS - 1, Math.floor(particle.pos.x / GRID_CELL_SIZE)));
                const gy = Math.max(0, Math.min(GRID_ROWS - 1, Math.floor(particle.pos.y / GRID_CELL_SIZE)));
                const gridIndex = gx + gy * GRID_COLS;
                 if(spatialGrid[gridIndex] && Number.isFinite(gridIndex) && gridIndex < spatialGrid.length) {
                    spatialGrid[gridIndex].push({ type: 'particle', particleRef: particle });
                }
            });
        }


        // --- Controls ---
        const worldWidthInput = document.getElementById('worldWidthInput');
        const worldHeightInput = document.getElementById('worldHeightInput');
        const resizeWorldButton = document.getElementById('resizeWorldButton');

        const worldWrapToggle = document.getElementById('worldWrapToggle');
        const maxTimestepSlider = document.getElementById('maxTimestep');
        const maxTimestepValueSpan = document.getElementById('maxTimestepValue');
        const zoomSensitivitySlider = document.getElementById('zoomSensitivitySlider');
        const zoomSensitivityValueSpan = document.getElementById('zoomSensitivityValueSpan');
        const pauseResumeButton = document.getElementById('pauseResumeButton');
        const toggleControlsButton = document.getElementById('toggleControlsButton');
        const screensaverButton = document.getElementById('screensaverButton');
        const controlsPanel = document.getElementById('controls');

        const creaturePopulationFloorSlider = document.getElementById('creaturePopulationFloorSlider');
        const creaturePopulationFloorValueSpan = document.getElementById('creaturePopulationFloorValueSpan');
        const creaturePopulationCeilingSlider = document.getElementById('creaturePopulationCeilingSlider');
        const creaturePopulationCeilingValueSpan = document.getElementById('creaturePopulationCeilingValueSpan');

        const bodyFluidEntrainmentSlider = document.getElementById('bodyFluidEntrainment');
        const fluidCurrentStrengthSlider = document.getElementById('fluidCurrentStrength');
        const bodyPushStrengthSlider = document.getElementById('bodyPushStrength');
        const reproductionCooldownSlider = document.getElementById('reproductionCooldown');
        const bodyRepulsionStrengthSlider = document.getElementById('bodyRepulsionStrength');
        const bodyRepulsionRadiusFactorSlider = document.getElementById('bodyRepulsionRadiusFactor');
        const globalMutationRateSlider = document.getElementById('globalMutationRate');
        const baseNodeCostSlider = document.getElementById('baseNodeCost');
        const emitterNodeCostSlider = document.getElementById('emitterNodeCost');
        const eaterNodeCostSlider = document.getElementById('eaterNodeCost');
        const predatorNodeCostSlider = document.getElementById('predatorNodeCost');
        const neuronNodeCostSlider = document.getElementById('neuronNodeCost');
        const instabilityLight = document.getElementById('instabilityLight');
        const populationCountDisplay = document.getElementById('populationCount');
        const resetButton = document.getElementById('resetButton');
        const bodyFluidEntrainmentValueSpan = document.getElementById('bodyFluidEntrainmentValue');
        const fluidCurrentStrengthValueSpan = document.getElementById('fluidCurrentStrengthValue');
        const bodyPushStrengthValueSpan = document.getElementById('bodyPushStrengthValue');
        const reproductionCooldownValueSpan = document.getElementById('reproductionCooldownValue');
        const bodyRepulsionStrengthValueSpan = document.getElementById('bodyRepulsionStrengthValue');
        const bodyRepulsionRadiusFactorValueSpan = document.getElementById('bodyRepulsionRadiusFactorValue');
        const globalMutationRateValueSpan = document.getElementById('globalMutationRateValue');
        const baseNodeCostValueSpan = document.getElementById('baseNodeCostValue');
        const emitterNodeCostValueSpan = document.getElementById('emitterNodeCostValue');
        const eaterNodeCostValueSpan = document.getElementById('eaterNodeCostValue');
        const predatorNodeCostValueSpan = document.getElementById('predatorNodeCostValue');
        const neuronNodeCostValueSpan = document.getElementById('neuronNodeCostValue');


        const fluidGridSizeSlider = document.getElementById('fluidGridSize');
        const fluidGridSizeValueSpan = document.getElementById('fluidGridSizeValue');
        const fluidDiffusionSlider = document.getElementById('fluidDiffusion');
        const fluidViscositySlider = document.getElementById('fluidViscosity');
        const fluidFadeSlider = document.getElementById('fluidFade');
        const clearFluidButton = document.getElementById('clearFluidButton');
        const fluidDiffusionValueSpan = document.getElementById('fluidDiffusionValue');
        const fluidViscosityValueSpan = document.getElementById('fluidViscosityValue');
        const fluidFadeValueSpan = document.getElementById('fluidFadeValue');
        const maxFluidVelocityComponentSlider = document.getElementById('maxFluidVelocityComponentSlider');
        const maxFluidVelocityComponentValueSpan = document.getElementById('maxFluidVelocityComponentValueSpan');


        const particlePopulationFloorSlider = document.getElementById('particlePopulationFloorSlider');
        const particlePopulationFloorValueSpan = document.getElementById('particlePopulationFloorValueSpan');
        const particlePopulationCeilingSlider = document.getElementById('particlePopulationCeilingSlider');
        const particlePopulationCeilingValueSpan = document.getElementById('particlePopulationCeilingValueSpan');
        const particlesPerSecondSlider = document.getElementById('particlesPerSecondSlider');
        const particlesPerSecondValueSpan = document.getElementById('particlesPerSecondValueSpan');
        const particleFluidInfluenceSlider = document.getElementById('particleFluidInfluence');
        const particleFluidInfluenceValueSpan = document.getElementById('particleFluidInfluenceValue');
        const particleLifeDecaySlider = document.getElementById('particleLifeDecay');
        const particleLifeDecayValueSpan = document.getElementById('particleLifeDecayValue');
        const infiniteParticleLifeToggle = document.getElementById('infiniteParticleLifeToggle');
        const particleLifeDecayLabel = document.getElementById('particleLifeDecayLabel');
        const resetParticlesButton = document.getElementById('resetParticlesButton');

        const exportConfigButton = document.getElementById('exportConfigButton');
        const importConfigFile = document.getElementById('importConfigFile');
        const importConfigButton = document.getElementById('importConfigButton');

        const emitterEditModeToggle = document.getElementById('emitterEditModeToggle');
        const emitterStrengthSlider = document.getElementById('emitterStrength');
        const emitterStrengthValueSpan = document.getElementById('emitterStrengthValue');
        const clearEmittersButton = document.getElementById('clearEmittersButton');

        const infoPanel = document.getElementById('infoPanel');
        const closeInfoPanelButton = document.getElementById('closeInfoPanel');
        const neuronInfoSection = document.getElementById('neuronInfoSection');
        const allPointsInfoContainer = document.getElementById('allPointsInfoContainer');


        // --- Global Variables (initialized with defaults, then overridden by JSON if loaded) ---
        let CREATURE_POPULATION_FLOOR = 10;
        let CREATURE_POPULATION_CEILING = 1000;
        let PARTICLE_POPULATION_FLOOR = 5000;
        let PARTICLE_POPULATION_CEILING = 20000;
        let canCreaturesReproduceGlobally = true;

        let BODY_FLUID_ENTRAINMENT_FACTOR = 0.465;
        let FLUID_CURRENT_STRENGTH_ON_BODY = 19.7;
        let SOFT_BODY_PUSH_STRENGTH = 0.10;
        let REPRODUCTION_COOLDOWN_TICKS = 1000;
        let BODY_REPULSION_STRENGTH = 100.0;
        let BODY_REPULSION_RADIUS_FACTOR = 5.0;
        let GLOBAL_MUTATION_RATE_MODIFIER = 0.25;
        let MAX_DELTA_TIME_MS = 10;
        // ZOOM_SENSITIVITY has an initial value, will be overridden by JSON
        let IS_SIMULATION_PAUSED = false;
        let IS_EMITTER_EDIT_MODE = false;
        let EMITTER_STRENGTH = 3.0;

        let BASE_NODE_EXISTENCE_COST = 0.3;
        let EMITTER_NODE_ENERGY_COST = 1.0;
        let EATER_NODE_ENERGY_COST = 0.3;
        let PREDATOR_NODE_ENERGY_COST = 0.8;
        let NEURON_NODE_ENERGY_COST = 0.01;


        let FLUID_GRID_SIZE_CONTROL = 128;
        let FLUID_DIFFUSION = 0.00047;
        let FLUID_VISCOSITY = 0.000068;
        let FLUID_FADE_RATE = 0.002;
        let MAX_FLUID_VELOCITY_COMPONENT = 0.5;
        let IS_WORLD_WRAPPING = false;
        let PARTICLES_PER_SECOND = 500;
        let PARTICLE_FLUID_INFLUENCE = 2.0;
        let PARTICLE_BASE_LIFE_DECAY = 0.001;
        let IS_PARTICLE_LIFE_INFINITE = false;
        let particleEmissionDebt = 0;
        let INITIAL_POPULATION_SIZE;

        let velocityEmitters = [];
        let currentEmitterPreview = null;
        let emitterDragStartCell = null;
        let selectedInspectBody = null;
        let selectedInspectPoint = null;
        let selectedInspectPointIndex = -1;
        isRightDragging = false;
        lastPanMouseX = 0;
        lastPanMouseY = 0;

        // --- Math Helper Functions ---
        function sigmoid(x) { return 1 / (1 + Math.exp(-x)); }
        function tanh(x) { return Math.tanh(x); }

        function initializeMatrix(rows, cols) {
            const matrix = [];
            for (let i = 0; i < rows; i++) {
                matrix[i] = [];
                for (let j = 0; j < cols; j++) {
                    matrix[i][j] = (Math.random() * 2 - 1) * 0.5; // Small random weights
                }
            }
            return matrix;
        }

        function initializeVector(size) {
            const vector = [];
            for (let i = 0; i < size; i++) {
                vector[i] = (Math.random() * 2 - 1) * 0.1; // Small random biases
            }
            return vector;
        }

        function multiplyMatrixVector(matrix, vector) {
            const result = [];
            for (let i = 0; i < matrix.length; i++) {
                let sum = 0;
                for (let j = 0; j < vector.length; j++) {
                    sum += matrix[i][j] * vector[j];
                }
                result.push(sum);
            }
            return result;
        }
        function addVectors(vecA, vecB) { // Element-wise addition
            return vecA.map((val, i) => val + vecB[i]);
        }


        // --- Slider Config Loading ---
        async function loadAndApplySliderConfig() {
            try {
                const response = await fetch('https://rwill128.github.io/browser_neurogenesis/slider_config.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}. Using hardcoded defaults.`);
                }
                const sliderConfigs = await response.json();
                window.loadedSliderConfigs = sliderConfigs;

                sliderConfigs.forEach(config => {
                    const slider = document.getElementById(config.id);
                    if (slider) {
                        slider.min = config.min;
                        slider.max = config.max;
                        slider.step = config.step;
                        slider.value = config.defaultValue;

                        if (config.jsVariable) {
                           // Directly assign to the global variable (assuming it's already declared with let)
                            // This requires mapping string names to actual variables or using a global config object.
                            // For now, we'll use a switch for clarity and safety.
                            switch(config.jsVariable) {
                                case "ZOOM_SENSITIVITY": ZOOM_SENSITIVITY = parseFloat(config.defaultValue); break;
                                case "CREATURE_POPULATION_FLOOR": CREATURE_POPULATION_FLOOR = parseInt(config.defaultValue); break;
                                case "CREATURE_POPULATION_CEILING": CREATURE_POPULATION_CEILING = parseInt(config.defaultValue); break;
                                case "GLOBAL_MUTATION_RATE_MODIFIER": GLOBAL_MUTATION_RATE_MODIFIER = parseFloat(config.defaultValue); break;
                                case "BODY_FLUID_ENTRAINMENT_FACTOR": BODY_FLUID_ENTRAINMENT_FACTOR = parseFloat(config.defaultValue); break;
                                case "FLUID_CURRENT_STRENGTH_ON_BODY": FLUID_CURRENT_STRENGTH_ON_BODY = parseFloat(config.defaultValue); break;
                                case "SOFT_BODY_PUSH_STRENGTH": SOFT_BODY_PUSH_STRENGTH = parseFloat(config.defaultValue); break;
                                case "REPRODUCTION_COOLDOWN_TICKS": REPRODUCTION_COOLDOWN_TICKS = parseInt(config.defaultValue); break;
                                case "BODY_REPULSION_STRENGTH": BODY_REPULSION_STRENGTH = parseFloat(config.defaultValue); break;
                                case "BODY_REPULSION_RADIUS_FACTOR": BODY_REPULSION_RADIUS_FACTOR = parseFloat(config.defaultValue); break;
                                case "BASE_NODE_EXISTENCE_COST": BASE_NODE_EXISTENCE_COST = parseFloat(config.defaultValue); break;
                                case "EMITTER_NODE_ENERGY_COST": EMITTER_NODE_ENERGY_COST = parseFloat(config.defaultValue); break;
                                case "EATER_NODE_ENERGY_COST": EATER_NODE_ENERGY_COST = parseFloat(config.defaultValue); break;
                                case "PREDATOR_NODE_ENERGY_COST": PREDATOR_NODE_ENERGY_COST = parseFloat(config.defaultValue); break;
                                case "NEURON_NODE_ENERGY_COST": NEURON_NODE_ENERGY_COST = parseFloat(config.defaultValue); break;
                                case "FLUID_GRID_SIZE_CONTROL": FLUID_GRID_SIZE_CONTROL = parseInt(config.defaultValue); break;
                                case "FLUID_DIFFUSION": FLUID_DIFFUSION = parseFloat(config.defaultValue); break;
                                case "FLUID_VISCOSITY": FLUID_VISCOSITY = parseFloat(config.defaultValue); break;
                                case "FLUID_FADE_RATE": FLUID_FADE_RATE = parseFloat(config.defaultValue); break;
                                case "MAX_FLUID_VELOCITY_COMPONENT": MAX_FLUID_VELOCITY_COMPONENT = parseFloat(config.defaultValue); break;
                                case "PARTICLE_POPULATION_FLOOR": PARTICLE_POPULATION_FLOOR = parseInt(config.defaultValue); break;
                                case "PARTICLE_POPULATION_CEILING": PARTICLE_POPULATION_CEILING = parseInt(config.defaultValue); break;
                                case "PARTICLES_PER_SECOND": PARTICLES_PER_SECOND = parseInt(config.defaultValue); break;
                                case "PARTICLE_FLUID_INFLUENCE": PARTICLE_FLUID_INFLUENCE = parseFloat(config.defaultValue); break;
                                case "PARTICLE_BASE_LIFE_DECAY": PARTICLE_BASE_LIFE_DECAY = parseFloat(config.defaultValue); break;
                                case "EMITTER_STRENGTH": EMITTER_STRENGTH = parseFloat(config.defaultValue); break;
                                case "MAX_DELTA_TIME_MS": MAX_DELTA_TIME_MS = parseInt(config.defaultValue); break; // Added for completeness
                                default: console.warn("Unknown jsVariable in slider_config.json:", config.jsVariable);
                            }
                        }
                    }
                });
                console.log("Slider configuration loaded and applied from URL.");
            } catch (error) {
                console.error("Could not load or apply slider_config.json from URL. Using hardcoded defaults (already set).", error);
            }
        }


        // Function to update slider value display
        function updateSliderDisplay(slider, span) {
            let value = parseFloat(slider.value);
            if (!slider || !span) return;

            const config = window.loadedSliderConfigs?.find(c => c.id === slider.id);

            if (config && config.displayFormat === "toFixed(4)") {
                 span.textContent = value.toFixed(4);
            } else if (config && config.displayFormat === "toFixed(3)") {
                 span.textContent = value.toFixed(3);
            } else if (config && config.displayFormat === "toFixed(2)") {
                 span.textContent = value.toFixed(2);
            } else if (config && config.displayFormat === "toFixed(1)") {
                 span.textContent = value.toFixed(1);
            } else if (config && config.displayFormat === "toExponential(1)") {
                 span.textContent = value.toExponential(1);
            } else if (config && config.displayFormat === "integer"){
                 span.textContent = Math.floor(value);
            }
             else {
                span.textContent = Number.isInteger(Number(slider.step)) && Number(slider.step) === 1 ? Math.floor(value) : value.toFixed(2);
            }
        }

        // --- Event Listeners ---
        document.addEventListener('keydown', (e) => {
            if (IS_SIMULATION_PAUSED && e.key.toLowerCase() !== 'p') return;

            const effectiveViewportWidth = canvas.clientWidth / viewZoom;
            const effectiveViewportHeight = canvas.clientHeight / viewZoom;
            const maxPanX = Math.max(0, WORLD_WIDTH - effectiveViewportWidth);
            const maxPanY = Math.max(0, WORLD_HEIGHT - effectiveViewportHeight);
            const panSpeed = VIEW_PAN_SPEED / viewZoom;


            switch(e.key.toLowerCase()) {
                case 'w': viewOffsetY = Math.max(0, viewOffsetY - panSpeed); break;
                case 's': viewOffsetY = Math.min(maxPanY, viewOffsetY + panSpeed); break;
                case 'a': viewOffsetX = Math.max(0, viewOffsetX - panSpeed); break;
                case 'd': viewOffsetX = Math.min(maxPanX, viewOffsetX + panSpeed); break;
                case 'p':
                    IS_SIMULATION_PAUSED = !IS_SIMULATION_PAUSED;
                    pauseResumeButton.textContent = IS_SIMULATION_PAUSED ? "Resume" : "Pause";
                    if (!IS_SIMULATION_PAUSED) {
                        lastTime = performance.now();
                        requestAnimationFrame(gameLoop);
                    }
                    break;
            }
        });


        worldWrapToggle.onchange = function() {
            IS_WORLD_WRAPPING = this.checked;
            if (fluidField) fluidField.useWrapping = IS_WORLD_WRAPPING;
        }
        maxTimestepSlider.oninput = function() { MAX_DELTA_TIME_MS = parseInt(this.value); updateSliderDisplay(this, maxTimestepValueSpan); }
        zoomSensitivitySlider.oninput = function() { ZOOM_SENSITIVITY = parseFloat(this.value); updateSliderDisplay(this, zoomSensitivityValueSpan); }

        pauseResumeButton.onclick = function() {
            IS_SIMULATION_PAUSED = !IS_SIMULATION_PAUSED;
            this.textContent = IS_SIMULATION_PAUSED ? "Resume" : "Pause";
            if (!IS_SIMULATION_PAUSED) {
                lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            }
        }
        toggleControlsButton.onclick = function() {
            controlsPanel.classList.toggle('open');
        }

        function toggleScreensaverMode(forceOff = false) {
            const isCurrentlyFullscreen = !!document.fullscreenElement;
            const isBodyCssFullscreen = document.body.classList.contains('css-screensaver-active');

            if (forceOff) { // Force exit
                if (isCurrentlyFullscreen) {
                    document.exitFullscreen().catch(err => console.error("Error exiting fullscreen:", err));
                }
                document.body.classList.remove('css-screensaver-active');
                screensaverButton.textContent = "Enter Screensaver";
                screensaverButton.classList.remove('in-screensaver');
                return;
            }

            if (isCurrentlyFullscreen || isBodyCssFullscreen) {
                // Exit fullscreen/screensaver
                if (isCurrentlyFullscreen) {
                    document.exitFullscreen().catch(err => console.error("Error exiting fullscreen:", err));
                }
                document.body.classList.remove('css-screensaver-active');
                screensaverButton.textContent = "Enter Screensaver";
                screensaverButton.classList.remove('in-screensaver');
            } else {
                // Enter fullscreen/screensaver
                if (canvasContainer.requestFullscreen) {
                    canvasContainer.requestFullscreen().then(() => {
                        screensaverButton.textContent = "Exit Screensaver";
                        screensaverButton.classList.add('in-screensaver');
                        document.body.classList.add('css-screensaver-active');
                    }).catch(err => {
                        console.warn("Fullscreen API failed, falling back to CSS mode:", err);
                        document.body.classList.add('css-screensaver-active');
                        screensaverButton.textContent = "Exit Screensaver (CSS)";
                        screensaverButton.classList.add('in-screensaver');
                    });
                } else {
                    document.body.classList.add('css-screensaver-active');
                    screensaverButton.textContent = "Exit Screensaver (CSS)";
                    screensaverButton.classList.add('in-screensaver');
                }
            }
        }

        screensaverButton.onclick = () => toggleScreensaverMode();

        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                document.body.classList.remove('css-screensaver-active');
                screensaverButton.textContent = "Enter Screensaver";
                screensaverButton.classList.remove('in-screensaver');
            } else {
                 document.body.classList.add('css-screensaver-active');
                 screensaverButton.textContent = "Exit Screensaver";
                 screensaverButton.classList.add('in-screensaver');
            }
        });


        creaturePopulationFloorSlider.oninput = function() { CREATURE_POPULATION_FLOOR = parseInt(this.value); updateSliderDisplay(this, creaturePopulationFloorValueSpan); }
        creaturePopulationCeilingSlider.oninput = function() { CREATURE_POPULATION_CEILING = parseInt(this.value); updateSliderDisplay(this, creaturePopulationCeilingValueSpan); }
        particlePopulationFloorSlider.oninput = function() { PARTICLE_POPULATION_FLOOR = parseInt(this.value); updateSliderDisplay(this, particlePopulationFloorValueSpan); }
        particlePopulationCeilingSlider.oninput = function() { PARTICLE_POPULATION_CEILING = parseInt(this.value); updateSliderDisplay(this, particlePopulationCeilingValueSpan); }


        emitterEditModeToggle.onchange = function() {
            IS_EMITTER_EDIT_MODE = this.checked;
            canvas.classList.toggle('emitter-edit-mode', IS_EMITTER_EDIT_MODE);
            if (!IS_EMITTER_EDIT_MODE) {
                currentEmitterPreview = null;
                emitterDragStartCell = null;
            }
        }
        emitterStrengthSlider.oninput = function() { EMITTER_STRENGTH = parseFloat(this.value); updateSliderDisplay(this, emitterStrengthValueSpan); }
        clearEmittersButton.onclick = function() { velocityEmitters = []; }


        bodyFluidEntrainmentSlider.oninput = function() { BODY_FLUID_ENTRAINMENT_FACTOR = parseFloat(this.value); updateSliderDisplay(this, bodyFluidEntrainmentValueSpan); }
        fluidCurrentStrengthSlider.oninput = function() { FLUID_CURRENT_STRENGTH_ON_BODY = parseFloat(this.value); updateSliderDisplay(this, fluidCurrentStrengthValueSpan); }
        bodyPushStrengthSlider.oninput = function() { SOFT_BODY_PUSH_STRENGTH = parseFloat(this.value); updateSliderDisplay(this, bodyPushStrengthValueSpan); }
        reproductionCooldownSlider.oninput = function() { REPRODUCTION_COOLDOWN_TICKS = parseInt(this.value); updateSliderDisplay(this, reproductionCooldownValueSpan); }
        bodyRepulsionStrengthSlider.oninput = function() { BODY_REPULSION_STRENGTH = parseFloat(this.value); updateSliderDisplay(this, bodyRepulsionStrengthValueSpan); }
        bodyRepulsionRadiusFactorSlider.oninput = function() { BODY_REPULSION_RADIUS_FACTOR = parseFloat(this.value); updateSliderDisplay(this, bodyRepulsionRadiusFactorValueSpan); }
        globalMutationRateSlider.oninput = function() { GLOBAL_MUTATION_RATE_MODIFIER = parseFloat(this.value); updateSliderDisplay(this, globalMutationRateValueSpan); }

        baseNodeCostSlider.oninput = function() { BASE_NODE_EXISTENCE_COST = parseFloat(this.value); updateSliderDisplay(this, baseNodeCostValueSpan); }
        emitterNodeCostSlider.oninput = function() { EMITTER_NODE_ENERGY_COST = parseFloat(this.value); updateSliderDisplay(this, emitterNodeCostValueSpan); }
        eaterNodeCostSlider.oninput = function() { EATER_NODE_ENERGY_COST = parseFloat(this.value); updateSliderDisplay(this, eaterNodeCostValueSpan); }
        predatorNodeCostSlider.oninput = function() { PREDATOR_NODE_ENERGY_COST = parseFloat(this.value); updateSliderDisplay(this, predatorNodeCostValueSpan); }
        neuronNodeCostSlider.oninput = function() { NEURON_NODE_ENERGY_COST = parseFloat(this.value); updateSliderDisplay(this, neuronNodeCostValueSpan); }


        resetButton.onclick = function() {
            initializePopulation();
            isAnySoftBodyUnstable = false;
            updateInstabilityIndicator();
        }

        resizeWorldButton.onclick = function() {
            const newWidth = parseInt(worldWidthInput.value);
            const newHeight = parseInt(worldHeightInput.value);

            if (isNaN(newWidth) || isNaN(newHeight) || newWidth < 500 || newHeight < 500 || newWidth > 20000 || newHeight > 20000) {
                showMessageModal("Invalid world dimensions. Min 500x500, Max 20000x20000.");
                worldWidthInput.value = WORLD_WIDTH;
                worldHeightInput.value = WORLD_HEIGHT;
                return;
            }
            WORLD_WIDTH = newWidth;
            WORLD_HEIGHT = newHeight;
            canvas.width = WORLD_WIDTH;
            canvas.height = WORLD_HEIGHT;
            MAX_DISPLACEMENT_SQ_THRESHOLD = (WORLD_WIDTH / 5) * (WORLD_WIDTH / 5);

            viewOffsetX = 0;
            viewOffsetY = 0;

            initializeSpatialGrid();
            initFluidSimulation();
            initParticles();
            initializePopulation();
            isAnySoftBodyUnstable = false;
            updateInstabilityIndicator();
            console.log(`World resized to ${WORLD_WIDTH}x${WORLD_HEIGHT} and simulation reset.`);
        }

        fluidGridSizeSlider.oninput = function() {
            FLUID_GRID_SIZE_CONTROL = parseInt(this.value);
            updateSliderDisplay(this, fluidGridSizeValueSpan);
            velocityEmitters = [];
            initFluidSimulation();
            initParticles();
        }
        fluidDiffusionSlider.oninput = function() { FLUID_DIFFUSION = parseFloat(this.value); updateSliderDisplay(this, fluidDiffusionValueSpan); if(fluidField) fluidField.diffusion = FLUID_DIFFUSION;}
        fluidViscositySlider.oninput = function() { FLUID_VISCOSITY = parseFloat(this.value); updateSliderDisplay(this, fluidViscosityValueSpan); if(fluidField) fluidField.viscosity = FLUID_VISCOSITY;}
        fluidFadeSlider.oninput = function() { FLUID_FADE_RATE = parseFloat(this.value); updateSliderDisplay(this, fluidFadeValueSpan);}
        maxFluidVelocityComponentSlider.oninput = function() { MAX_FLUID_VELOCITY_COMPONENT = parseFloat(this.value); updateSliderDisplay(this, maxFluidVelocityComponentValueSpan); if(fluidField) fluidField.maxVelComponent = MAX_FLUID_VELOCITY_COMPONENT;}
        clearFluidButton.onclick = function() { if(fluidField) fluidField.clear(); }

        particlesPerSecondSlider.oninput = function() {
            PARTICLES_PER_SECOND = parseInt(this.value);
            updateSliderDisplay(this, particlesPerSecondValueSpan);
        }
        particleFluidInfluenceSlider.oninput = function() { PARTICLE_FLUID_INFLUENCE = parseFloat(this.value); updateSliderDisplay(this, particleFluidInfluenceValueSpan); }
        particleLifeDecaySlider.oninput = function() { PARTICLE_BASE_LIFE_DECAY = parseFloat(this.value); updateSliderDisplay(this, particleLifeDecayValueSpan); }
        infiniteParticleLifeToggle.onchange = function() {
            IS_PARTICLE_LIFE_INFINITE = this.checked;
            particleLifeDecaySlider.disabled = IS_PARTICLE_LIFE_INFINITE;
            particleLifeDecayLabel.style.color = IS_PARTICLE_LIFE_INFINITE ? '#777' : '#ddd';
            particleLifeDecayValueSpan.style.color = IS_PARTICLE_LIFE_INFINITE ? '#777' : '#00aeff';
        }
        resetParticlesButton.onclick = function() { initParticles(); }

        exportConfigButton.onclick = handleExportConfig;
        importConfigButton.onclick = () => importConfigFile.click();
        importConfigFile.onchange = handleImportConfig;
        closeInfoPanelButton.onclick = () => { infoPanel.classList.remove('open'); selectedInspectBody = null; selectedInspectPoint = null; }


        function initializeAllSliderDisplays() {
            worldWidthInput.value = WORLD_WIDTH;
            worldHeightInput.value = WORLD_HEIGHT;

            // Iterate through loadedSliderConfigs to set display values
            if (window.loadedSliderConfigs) {
                window.loadedSliderConfigs.forEach(config => {
                    const slider = document.getElementById(config.id);
                    const span = document.getElementById(config.valueSpanId);
                    if (slider && span) {
                         updateSliderDisplay(slider, span);
                    }
                });
            } else { // Fallback if JSON didn't load, update from hardcoded JS values
                const sliders = document.querySelectorAll('input[type="range"]');
                sliders.forEach(slider => {
                    const span = document.getElementById(slider.id.replace("Slider", "ValueSpan"));
                    if(span) updateSliderDisplay(slider, span);
                });
            }
            // Update any displays for controls not in the JSON (like checkboxes)
            particleLifeDecaySlider.disabled = IS_PARTICLE_LIFE_INFINITE;
            particleLifeDecayLabel.style.color = IS_PARTICLE_LIFE_INFINITE ? '#777' : '#ddd';
            particleLifeDecayValueSpan.style.color = IS_PARTICLE_LIFE_INFINITE ? '#777' : '#00aeff';
            worldWrapToggle.checked = IS_WORLD_WRAPPING;
            emitterEditModeToggle.checked = IS_EMITTER_EDIT_MODE;
            infiniteParticleLifeToggle.checked = IS_PARTICLE_LIFE_INFINITE;

            canvas.classList.toggle('emitter-edit-mode', IS_EMITTER_EDIT_MODE);
        }

        function updateInstabilityIndicator() {
            if (isAnySoftBodyUnstable) {
                instabilityLight.classList.add('unstable');
            } else {
                instabilityLight.classList.remove('unstable');
            }
        }
        function updatePopulationCount() {
            populationCountDisplay.textContent = `Population: ${softBodyPopulation.length}`;
        }

        function getNodeTypeString(nodeType) {
            switch(nodeType) {
                case NodeType.FLOATING: return "Floating";
                case NodeType.FIXED_ROOT: return "Fixed Root";
                case NodeType.EMITTER_SWIMMER: return "Emitter/Swimmer";
                case NodeType.NEURON: return "Neuron";
                case NodeType.NEUTRAL: return "Neutral";
                default: return "Unknown";
            }
        }

        function getSensedChannelString(channelId) {
            switch(channelId) {
                case DyeChannel.RED: return "Red";
                case DyeChannel.GREEN: return "Green";
                case DyeChannel.BLUE: return "Blue";
                case DyeChannel.AVERAGE: return "Average Intensity";
                default: return "Unknown";
            }
        }


        function updateInfoPanel() {
            if (selectedInspectBody) { // Check if a body is selected
                document.getElementById('infoBodyId').textContent = selectedInspectBody.id;
                document.getElementById('infoBodyStiffness').textContent = selectedInspectBody.stiffness.toFixed(2);
                document.getElementById('infoBodyDamping').textContent = selectedInspectBody.springDamping.toFixed(2);
                document.getElementById('infoBodyMotorInterval').textContent = selectedInspectBody.motorImpulseInterval;
                document.getElementById('infoBodyMotorCap').textContent = selectedInspectBody.motorImpulseMagnitudeCap.toFixed(2);
                document.getElementById('infoBodyEmitterStrength').textContent = selectedInspectBody.emitterStrength.toFixed(2);
                document.getElementById('infoBodyEmitterDirX').textContent = selectedInspectBody.emitterDirection.x.toFixed(2);
                document.getElementById('infoBodyEmitterDirY').textContent = selectedInspectBody.emitterDirection.y.toFixed(2);
                document.getElementById('infoBodyNumOffspring').textContent = selectedInspectBody.numOffspring;
                document.getElementById('infoBodyOffspringRadius').textContent = selectedInspectBody.offspringSpawnRadius.toFixed(1);
                document.getElementById('infoBodyPointAddChance').textContent = selectedInspectBody.pointAddChance.toFixed(3);
                document.getElementById('infoBodySpringConnectionRadius').textContent = selectedInspectBody.springConnectionRadius.toFixed(1);
                document.getElementById('infoBodyEnergy').textContent = selectedInspectBody.creatureEnergy.toFixed(2);
                document.getElementById('infoBodyTicksBirth').textContent = selectedInspectBody.ticksSinceBirth;
                document.getElementById('infoBodyCanReproduce').textContent = selectedInspectBody.canReproduce;

                allPointsInfoContainer.innerHTML = '<h5>All Mass Points</h5>'; // Clear previous and add title
                selectedInspectBody.massPoints.forEach((point, index) => {
                    const pointEntryDiv = document.createElement('div');
                    pointEntryDiv.className = 'point-info-entry';

                    let content = `<p><strong>Point Index:</strong> ${index}</p>`;
                    content += `<p><strong>Node Type:</strong> ${getNodeTypeString(point.nodeType)}</p>`;
                    content += `<p><strong>Mass:</strong> ${point.mass.toFixed(2)}</p>`;
                    content += `<p><strong>Radius:</strong> ${point.radius.toFixed(2)}</p>`;
                    content += `<p><strong>World Pos:</strong> X: ${point.pos.x.toFixed(2)}, Y: ${point.pos.y.toFixed(2)}</p>`;
                    content += `<p><strong>Is Eater:</strong> ${point.isEater}</p>`;
                    content += `<p><strong>Is Predator:</strong> ${point.isPredator}</p>`;
                    content += `<p><strong>Emits Dye:</strong> ${point.emitsDye}</p>`;
                    content += `<p><strong>Dye Color:</strong> ${point.emitsDye ? `R:${point.dyeColor[0]} G:${point.dyeColor[1]} B:${point.dyeColor[2]}` : "N/A"}</p>`;

                    if (point.nodeType === NodeType.NEURON && point.neuronData) {
                        const nd = point.neuronData;
                        content += `<h6>Neuron Data:</h6>`;
                        if (nd.isBrain) {
                            content += `<p><strong>Role:</strong> Active Brain</p>`;
                            content += `<p><strong>Hidden Size:</strong> ${nd.hiddenLayerSize}</p>`;
                            content += `<p><strong>Inputs:</strong> ${nd.inputVectorSize}, <strong>Outputs:</strong> ${nd.outputVectorSize}</p>`;
                        } else {
                            content += `<p><strong>Role:</strong> Passive Neural Node</p>`;
                            content += `<p><strong>Configured Hidden Size:</strong> ${nd.hiddenLayerSize || 'N/A'}</p>`;
                        }
                        content += `<p><strong>Sensor Idx:</strong> ${nd.sensorPointIndex !== undefined ? nd.sensorPointIndex : 'N/A (Old System)'}</p>`;
                        content += `<p><strong>Effector Idx:</strong> ${nd.effectorPointIndex !== undefined ? nd.effectorPointIndex : 'N/A (Old System)'}</p>`;
                        if(nd.weights && nd.bias) { // Old system check
                            content += `<p><strong>Sensed Ch:</strong> ${getSensedChannelString(nd.sensedChannel)}</p>`;
                            content += `<p><strong>Last Sensed (RGB):</strong> ${nd.lastSensedR?.toFixed(3)}, ${nd.lastSensedG?.toFixed(3)}, ${nd.lastSensedB?.toFixed(3)}</p>`;
                            content += `<p><strong>Weights (RGB):</strong> ${nd.weights[0]?.toFixed(3)}, ${nd.weights[1]?.toFixed(3)}, ${nd.weights[2]?.toFixed(3)}</p>`;
                            content += `<p><strong>Bias:</strong> ${nd.bias?.toFixed(3)}</p>`;
                            content += `<p><strong>Last Output:</strong> ${nd.lastOutput !== undefined ? nd.lastOutput.toFixed(3) : "N/A"}</p>`;
                        }
                    }
                    pointEntryDiv.innerHTML = content;
                    allPointsInfoContainer.appendChild(pointEntryDiv);
                });


                if (!infoPanel.classList.contains('open')) {
                    infoPanel.classList.add('open');
                }
            } else { // No body selected, clear all point info
                allPointsInfoContainer.innerHTML = ''; // Clear the list
                // Optionally hide or clear other body-specific fields if needed
                document.getElementById('infoBodyId').textContent = '-';
                // ... clear other body info spans ...
                infoPanel.classList.remove('open');
            }
        }


        // --- Simulation Parameters ---
        const restitution = 0.4;

        let softBodyPopulation = [];
        let fluidField;
        let particles = [];

        let lastTime = 0;
        let deltaTime = 0;
        let nextSoftBodyId = 0;


        // --- Mouse Interaction ---
        let selectedSoftBodyPoint = null;
        let mouse = { x: 0, y: 0, prevX: 0, prevY: 0, isDown: false, dx:0, dy:0 };
        isRightDragging = false;
        panStartMouseDisplayX = 0;
        panStartMouseDisplayY = 0;
        panInitialViewOffsetX = 0;
        panInitialViewOffsetY = 0;


        function updateMouse(e) {
            const rect = canvas.getBoundingClientRect();
            mouse.prevX = mouse.x;
            mouse.prevY = mouse.y;
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
            mouse.dx = mouse.x - mouse.prevX;
            mouse.dy = mouse.y - mouse.prevY;
        }

        function getMouseWorldCoordinates(displayMouseX, displayMouseY) {
            const rect = canvas.getBoundingClientRect();

            const canvasDisplayRatioX = canvas.clientWidth / WORLD_WIDTH;
            const canvasDisplayRatioY = canvas.clientHeight / WORLD_HEIGHT;
            const effectiveCanvasDisplayRatio = Math.min(canvasDisplayRatioX, canvasDisplayRatioY);

            const renderedWorldWidthInCss = WORLD_WIDTH * effectiveCanvasDisplayRatio;
            const renderedWorldHeightInCss = WORLD_HEIGHT * effectiveCanvasDisplayRatio;
            const letterboxOffsetX = (canvas.clientWidth - renderedWorldWidthInCss) / 2;
            const letterboxOffsetY = (canvas.clientHeight - renderedWorldHeightInCss) / 2;

            const mouseOnRenderedX = displayMouseX - letterboxOffsetX;
            const mouseOnRenderedY = displayMouseY - letterboxOffsetY;

            const worldX = (mouseOnRenderedX / effectiveCanvasDisplayRatio / viewZoom) + viewOffsetX;
            const worldY = (mouseOnRenderedY / effectiveCanvasDisplayRatio / viewZoom) + viewOffsetY;

            return { x: worldX, y: worldY };
        }


        canvas.addEventListener('mousedown', (e) => {
            updateMouse(e);

            if (e.button === 2) { // Right mouse button
                isRightDragging = true;
                mouse.isDown = false; // Ensure left-click drag state is off
                panStartMouseDisplayX = mouse.x;
                panStartMouseDisplayY = mouse.y;
                panInitialViewOffsetX = viewOffsetX;
                panInitialViewOffsetY = viewOffsetY;
                e.preventDefault();
                return;
            } else if (e.button === 0) { // Left mouse button
                mouse.isDown = true;
                isRightDragging = false;

                const worldCoords = getMouseWorldCoordinates(mouse.x, mouse.y);
                const simMouseX = worldCoords.x;
                const simMouseY = worldCoords.y;

                if (IS_EMITTER_EDIT_MODE && fluidField) {
                    const gridX = Math.floor(simMouseX / fluidField.scaleX);
                    const gridY = Math.floor(simMouseY / fluidField.scaleY);
                    emitterDragStartCell = { gridX, gridY, mouseStartX: simMouseX, mouseStartY: simMouseY };
                    currentEmitterPreview = {
                        startX: (gridX + 0.5) * fluidField.scaleX,
                        startY: (gridY + 0.5) * fluidField.scaleY,
                        endX: simMouseX,
                        endY: simMouseY
                    };
                    selectedInspectBody = null; selectedInspectPoint = null; updateInfoPanel();
                    return;
                }

                let clickedOnPoint = false;
                selectedInspectBody = null; // Reset selected body on new click
                selectedInspectPoint = null;

                for (let body of softBodyPopulation) {
                    if (body.isUnstable) continue;
                    for (let i = 0; i < body.massPoints.length; i++) {
                        const point = body.massPoints[i];
                        const dist = Math.sqrt((point.pos.x - simMouseX)**2 + (point.pos.y - simMouseY)**2);
                        if (dist < point.radius * 2.5 ) {
                            selectedSoftBodyPoint = { body: body, point: point };
                            selectedInspectBody = body;
                            selectedInspectPoint = point; // This specific point is the "primary" clicked one
                            selectedInspectPointIndex = i;

                            point.isFixed = true;
                            point.prevPos.x = point.pos.x;
                            point.prevPos.y = point.pos.y;
                            clickedOnPoint = true;
                            break; // Found a point, stop checking this body
                        }
                    }
                    if(clickedOnPoint) break; // Found a point, stop checking other bodies
                }
                updateInfoPanel(); // Update panel based on selection (or lack thereof)
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            updateMouse(e);

            if (isRightDragging) {
                const currentDisplayMouseX = mouse.x;
                const currentDisplayMouseY = mouse.y;

                const displayDx = currentDisplayMouseX - panStartMouseDisplayX;
                const displayDy = currentDisplayMouseY - panStartMouseDisplayY;

                const rect = canvas.getBoundingClientRect();
                const effectiveRenderScale = Math.min(rect.width / WORLD_WIDTH, rect.height / WORLD_HEIGHT);

                const panDeltaX_world = displayDx / (effectiveRenderScale * viewZoom);
                const panDeltaY_world = displayDy / (effectiveRenderScale * viewZoom);

                viewOffsetX = panInitialViewOffsetX - panDeltaX_world;
                viewOffsetY = panInitialViewOffsetY - panDeltaY_world;

                const effectiveViewportWidth = canvas.clientWidth / viewZoom;
                const effectiveViewportHeight = canvas.clientHeight / viewZoom;
                const maxPanX = Math.max(0, WORLD_WIDTH - effectiveViewportWidth);
                const maxPanY = Math.max(0, WORLD_HEIGHT - effectiveViewportHeight);
                viewOffsetX = Math.max(0, Math.min(viewOffsetX, maxPanX));
                viewOffsetY = Math.max(0, Math.min(viewOffsetY, maxPanY));
                return;
            }


            const worldCoords = getMouseWorldCoordinates(mouse.x, mouse.y);
            const simMouseX = worldCoords.x;
            const simMouseY = worldCoords.y;

            const worldPrevCoords = getMouseWorldCoordinates(mouse.prevX, mouse.prevY);
            const worldMouseDx = simMouseX - worldPrevCoords.x;
            const worldMouseDy = simMouseY - worldPrevCoords.y;


            if (mouse.isDown) { // This condition now correctly only applies to left-click drags
                if (IS_EMITTER_EDIT_MODE && emitterDragStartCell) {
                    currentEmitterPreview.endX = simMouseX;
                    currentEmitterPreview.endY = simMouseY;
                } else if (selectedSoftBodyPoint) {
                    const point = selectedSoftBodyPoint.point;
                    point.prevPos.x = point.pos.x;
                    point.prevPos.y = point.pos.y;
                    point.pos.x = simMouseX;
                    point.pos.y = simMouseY;
                } else if (fluidField) { // Fluid emission on left-drag
                    const fluidGridX = Math.floor(simMouseX / fluidField.scaleX);
                    const fluidGridY = Math.floor(simMouseY / fluidField.scaleY);
                    const r1 = Math.random() * 100 + 155;
                    const g1 = Math.random() * 50 + 25;
                    const b1 = Math.random() * 100 + 100;
                    fluidField.addDensity(fluidGridX, fluidGridY, r1, g1, b1, 150 + Math.random()*50);

                    const r2 = Math.random() * 50 + 25;
                    const g2 = Math.random() * 100 + 155;
                    const b2 = Math.random() * 100 + 155;
                    fluidField.addDensity(fluidGridX, fluidGridY, r2, g2, b2, 150 + Math.random()*50);

                    const fluidVelX = worldMouseDx * FLUID_MOUSE_DRAG_VELOCITY_SCALE;
                    const fluidVelY = worldMouseDy * FLUID_MOUSE_DRAG_VELOCITY_SCALE;
                    fluidField.addVelocity(fluidGridX, fluidGridY, fluidVelX, fluidVelY);
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 2) { // Right mouse button up
                isRightDragging = false;
                e.preventDefault();
            } else if (e.button === 0) { // Left mouse button up
                mouse.isDown = false;

                if (IS_EMITTER_EDIT_MODE && emitterDragStartCell && fluidField) {
                    const worldCoords = getMouseWorldCoordinates(mouse.x, mouse.y);
                    const simMouseX = worldCoords.x;
                    const simMouseY = worldCoords.y;

                    const worldForceX = (simMouseX - emitterDragStartCell.mouseStartX) * EMITTER_MOUSE_DRAG_SCALE;
                    const worldForceY = (simMouseY - emitterDragStartCell.mouseStartY) * EMITTER_MOUSE_DRAG_SCALE;

                    const gridForceX = worldForceX / fluidField.scaleX;
                    const gridForceY = worldForceY / fluidField.scaleY;


                    const existingEmitter = velocityEmitters.find(em => em.gridX === emitterDragStartCell.gridX && em.gridY === emitterDragStartCell.gridY);
                    if (existingEmitter) {
                        existingEmitter.forceX = gridForceX;
                        existingEmitter.forceY = gridForceY;
                    } else {
                        velocityEmitters.push({
                            gridX: emitterDragStartCell.gridX,
                            gridY: emitterDragStartCell.gridY,
                            forceX: gridForceX,
                            forceY: gridForceY
                        });
                    }
                    emitterDragStartCell = null;
                    currentEmitterPreview = null;
                }
                if (selectedSoftBodyPoint) {
                    const point = selectedSoftBodyPoint.point;
                    point.isFixed = false;
                    const worldDx = (mouse.dx / Math.min(canvas.clientWidth / WORLD_WIDTH, canvas.clientHeight / WORLD_HEIGHT) / viewZoom);
                    const worldDy = (mouse.dy / Math.min(canvas.clientWidth / WORLD_WIDTH, canvas.clientHeight / WORLD_HEIGHT) / viewZoom);

                    point.prevPos.x = point.pos.x - worldDx * 1.0;
                    point.prevPos.y = point.pos.y - worldDy * 1.0;
                    selectedSoftBodyPoint = null;
                }
            }
        });
         canvas.addEventListener('mouseleave', () => {
            mouse.isDown = false; // Clear left-drag state
            isRightDragging = false; // Clear right-drag state
            if (IS_EMITTER_EDIT_MODE && emitterDragStartCell) { // Finalize emitter if drag was in progress
                const worldCoords = getMouseWorldCoordinates(mouse.x, mouse.y);
                const simMouseX = worldCoords.x;
                const simMouseY = worldCoords.y;
                const worldForceX = (simMouseX - emitterDragStartCell.mouseStartX) * EMITTER_MOUSE_DRAG_SCALE;
                const worldForceY = (simMouseY - emitterDragStartCell.mouseStartY) * EMITTER_MOUSE_DRAG_SCALE;
                const gridForceX = worldForceX / fluidField.scaleX;
                const gridForceY = worldForceY / fluidField.scaleY;
                const existingEmitter = velocityEmitters.find(em => em.gridX === emitterDragStartCell.gridX && em.gridY === emitterDragStartCell.gridY);
                if (existingEmitter) {
                    existingEmitter.forceX = gridForceX;
                    existingEmitter.forceY = gridForceY;
                } else {
                    velocityEmitters.push({
                        gridX: emitterDragStartCell.gridX,
                        gridY: emitterDragStartCell.gridY,
                        forceX: gridForceX,
                        forceY: gridForceY
                    });
                }
            }
            emitterDragStartCell = null;
            currentEmitterPreview = null;

            if (selectedSoftBodyPoint) {
                const point = selectedSoftBodyPoint.point;
                point.isFixed = false;
                 const worldDx = (mouse.dx / Math.min(canvas.clientWidth / WORLD_WIDTH, canvas.clientHeight / WORLD_HEIGHT) / viewZoom);
                const worldDy = (mouse.dy / Math.min(canvas.clientWidth / WORLD_WIDTH, canvas.clientHeight / WORLD_HEIGHT) / viewZoom);
                point.prevPos.x = point.pos.x - worldDx * 1.0;
                point.prevPos.y = point.pos.y - worldDy * 1.0;
                selectedSoftBodyPoint = null;
            }
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault(); // Prevent context menu on canvas
        });


        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const displayMouseX = e.clientX - rect.left;
            const displayMouseY = e.clientY - rect.top;

            const canvasDisplayRatio = Math.min(canvas.clientWidth / WORLD_WIDTH, canvas.clientHeight / WORLD_HEIGHT);
            const renderedWorldWidthInCss = WORLD_WIDTH * canvasDisplayRatio;
            const renderedWorldHeightInCss = WORLD_HEIGHT * canvasDisplayRatio;
            const letterboxOffsetX = (canvas.clientWidth - renderedWorldWidthInCss) / 2;
            const letterboxOffsetY = (canvas.clientHeight - renderedWorldHeightInCss) / 2;

            const mouseOnRenderedX = displayMouseX - letterboxOffsetX;
            const mouseOnRenderedY = displayMouseY - letterboxOffsetY;

            const worldMouseX_beforeZoom = (mouseOnRenderedX / canvasDisplayRatio / viewZoom) + viewOffsetX;
            const worldMouseY_beforeZoom = (mouseOnRenderedY / canvasDisplayRatio / viewZoom) + viewOffsetY;

            const scroll = e.deltaY < 0 ? 1 : -1;
            const newZoom = viewZoom * Math.pow(1 + ZOOM_SENSITIVITY * 10, scroll);

            // Calculate MIN_ZOOM dynamically based on fitting the world into the client view
            let calculatedMinZoomX = canvas.clientWidth / WORLD_WIDTH;
            let calculatedMinZoomY = canvas.clientHeight / WORLD_HEIGHT;
            MIN_ZOOM = Math.min(calculatedMinZoomX, calculatedMinZoomY);
            MIN_ZOOM = Math.max(0.01, MIN_ZOOM); // Absolute minimum bound to prevent division by zero or extreme zoom out

            viewZoom = Math.max(MIN_ZOOM, Math.min(newZoom, MAX_ZOOM));

            viewOffsetX = worldMouseX_beforeZoom - (mouseOnRenderedX / canvasDisplayRatio / viewZoom);
            viewOffsetY = worldMouseY_beforeZoom - (mouseOnRenderedY / canvasDisplayRatio / viewZoom);

            const effectiveViewportWidth = canvas.clientWidth / viewZoom;
            const effectiveViewportHeight = canvas.clientHeight / viewZoom;
            const maxPanX = Math.max(0, WORLD_WIDTH - effectiveViewportWidth);
            const maxPanY = Math.max(0, WORLD_HEIGHT - effectiveViewportHeight);
            viewOffsetX = Math.max(0, Math.min(viewOffsetX, maxPanX));
            viewOffsetY = Math.max(0, Math.min(viewOffsetY, maxPanY));
        });


        // --- Vector2D Class ---
        class Vec2 {
            constructor(x = 0, y = 0) { this.x = x; this.y = y; }
            add(other) { return new Vec2(this.x + other.x, this.y + other.y); }
            sub(other) { return new Vec2(this.x - other.x, this.y - other.y); }
            mul(scalar) { return new Vec2(this.x * scalar, this.y * scalar); }
            div(scalar) { return scalar !== 0 ? new Vec2(this.x / scalar, this.y / scalar) : new Vec2(); }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            magSq() { return this.x * this.x + this.y * this.y; }
            normalize() { const m = this.mag(); return m > 0 ? this.div(m) : new Vec2(); }
            static dot(v1, v2) { return v1.x * v2.x + v1.y * v2.y; }
            clone() { return new Vec2(this.x, this.y); }
        }

        // --- MassPoint Class (Soft Body with Verlet Integration) ---
        class MassPoint {
            constructor(x, y, mass = 0.5, radius = 5, color = 'rgba(0,150,255,0.8)') {
                this.pos = new Vec2(x, y);
                this.prevPos = new Vec2(x, y);
                this.force = new Vec2();
                this.mass = mass;
                this.invMass = this.mass !== 0 ? 1 / this.mass : 0;
                this.radius = radius;
                this.color = color;
                this.isFixed = false;
                this.nodeType = NodeType.NEUTRAL;
                this.isEater = false;
                this.isPredator = false;
                this.emitsDye = false;
                this.dyeColor = [0,0,0];
                this.neuronData = null; // Will be object for neurons: { isBrain, hiddenLayerSize, weightsIH, biasesH, weightsHO, biasesO, inputVectorSize, outputVectorSize }
                this.neuralEffectiveStrength = null; // Deprecated by new neural system for brain-controlled emitters
            }
            applyForce(f) { this.force = this.force.add(f); }

            update(dt) {
                if (this.isFixed || this.invMass === 0 || this.nodeType === NodeType.FIXED_ROOT) {
                    this.force = new Vec2();
                    return;
                }

                const acceleration = this.force.mul(this.invMass);

                const tempX = this.pos.x;
                const tempY = this.pos.y;

                this.pos.x = 2 * this.pos.x - this.prevPos.x + acceleration.x * dt * dt;
                this.pos.y = 2 * this.pos.y - this.prevPos.y + acceleration.y * dt * dt;

                this.prevPos.x = tempX;
                this.prevPos.y = tempY;

                this.force = new Vec2();
            }

            draw(ctx) {
                // Draw interaction radii first (underneath the point)
                if (this.isEater) {
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius * EATING_RADIUS_MULTIPLIER, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 165, 0, 0.05)';
                    ctx.fill();
                }
                if (this.isPredator) {
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius * PREDATION_RADIUS_MULTIPLIER, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 50, 50, 0.05)';
                    ctx.fill();
                }


                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
                let mainColor = this.isFixed ? 'rgba(255,0,0,0.9)' : this.color;
                if (this.nodeType === NodeType.NEURON) {
                    mainColor = (this.neuronData && this.neuronData.isBrain) ? 'rgba(255, 215, 0, 0.95)' : 'rgba(200, 100, 255, 0.9)'; // Gold for brain
                } else if (this.isPredator) {
                    mainColor = 'rgba(255, 50, 50, 0.9)';
                } else if (this.nodeType === NodeType.EMITTER_SWIMMER && this.isEater) {
                     mainColor = 'rgba(200,255,0,0.9)';
                } else if (this.nodeType === NodeType.EMITTER_SWIMMER) {
                    mainColor = 'rgba(0,255,100,0.9)';
                } else if (this.isEater) {
                    mainColor = 'rgba(255,165,0,0.9)';
                } else if (this.nodeType === NodeType.FIXED_ROOT) {
                    mainColor = 'rgba(100, 70, 30, 0.9)';
                }
                ctx.fillStyle = mainColor;
                ctx.fill();

                // Glow effect using shadow
                ctx.save(); // Save context state before applying shadow
                ctx.shadowColor = mainColor;
                ctx.shadowBlur = 7;
                ctx.fill(); // Re-fill to apply shadow as a glow
                ctx.restore(); // Restore context state to remove shadow for subsequent drawings


                if (this.nodeType === NodeType.NEURON) {
                    ctx.beginPath(); // Inner dot for neuron
                    ctx.arc(this.pos.x, this.pos.y, this.radius * ( (this.neuronData && this.neuronData.isBrain) ? 0.6 : 0.5), 0, Math.PI * 2);
                    ctx.fillStyle = (this.neuronData && this.neuronData.isBrain) ? 'rgba(255, 255, 255, 1)' : 'rgba(250, 200, 255, 0.9)';
                    ctx.fill();
                }
                // ctx.closePath(); // Already closed by fill()
            }
        }

        // --- Spring Class (Soft Body) ---
        class Spring {
            constructor(p1, p2, stiffness, dampingFactor, restLength = null) {
                this.p1 = p1; this.p2 = p2;
                this.stiffness = stiffness;
                this.dampingFactor = dampingFactor;
                this.restLength = restLength === null ? p1.pos.sub(p2.pos).mag() : restLength;
            }
            applyForce() {
                const diffPos = this.p1.pos.sub(this.p2.pos);
                const currentLength = diffPos.mag();
                if (currentLength === 0) return;
                const displacement = currentLength - this.restLength;
                const direction = diffPos.normalize();

                const springForceMagnitude = -this.stiffness * displacement;
                const springForce = direction.mul(springForceMagnitude);

                const p1_vel_implicit = this.p1.pos.sub(this.p1.prevPos);
                const p2_vel_implicit = this.p2.pos.sub(this.p2.prevPos);
                const relVel_implicit = p1_vel_implicit.sub(p2_vel_implicit);

                const velAlongSpring = Vec2.dot(relVel_implicit, direction);
                const dampingForceMagnitude = -this.dampingFactor * velAlongSpring;
                const dampingForce = direction.mul(dampingForceMagnitude);

                const totalForce = springForce.add(dampingForce);
                this.p1.applyForce(totalForce);
                this.p2.applyForce(totalForce.mul(-1));
            }
            draw(ctx) {
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.beginPath();
                ctx.moveTo(this.p1.pos.x, this.p1.pos.y);
                ctx.lineTo(this.p2.pos.x, this.p2.pos.y);
                ctx.strokeStyle = 'rgba(150,150,150,0.6)';
                ctx.lineWidth = 2;
                ctx.stroke();
                // ctx.closePath(); // Not needed for lineTo
            }
        }

        // --- SoftBody Class ---
        class SoftBody {
            constructor(id, initialX, initialY, parentBody = null) {
                this.id = id;
                this.massPoints = [];
                this.springs = [];
                this.isUnstable = false;
                this.creatureEnergy = MAX_CREATURE_ENERGY * OFFSPRING_INITIAL_ENERGY_SHARE;
                this.ticksSinceBirth = 0;
                this.canReproduce = false;
                this.shapeType = parentBody ? parentBody.shapeType : Math.floor(Math.random() * 3); // Used for initial generation

                this.motorImpulseInterval = 30 + Math.floor(Math.random() * 90);
                this.motorImpulseMagnitudeCap = 0.5 + Math.random() * 2.0;
                this.emitterStrength = 0.2 + Math.random() * 1.0;
                this.emitterDirection = new Vec2(Math.random()*2-1, Math.random()*2-1).normalize();
                this.numOffspring = parentBody ? parentBody.numOffspring : (1 + Math.floor(Math.random() * 3));
                this.offspringSpawnRadius = parentBody ? parentBody.offspringSpawnRadius : (50 + Math.random() * 50);
                this.pointAddChance = parentBody ? parentBody.pointAddChance : (0.02 + Math.random() * 0.06);
                this.springConnectionRadius = parentBody ? parentBody.springConnectionRadius : (40 + Math.random() * 40);


                if (parentBody) {
                    this.stiffness = parentBody.stiffness * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER));
                    this.springDamping = parentBody.springDamping * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER));
                    this.motorImpulseInterval = Math.max(10, Math.floor(parentBody.motorImpulseInterval * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER))));
                    this.motorImpulseMagnitudeCap = parentBody.motorImpulseMagnitudeCap * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER));
                    this.emitterStrength = parentBody.emitterStrength * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER));

                    let offspringNumChange = 0;
                    if (Math.random() < Math.max(0, Math.min(1, MUTATION_CHANCE_BOOL * GLOBAL_MUTATION_RATE_MODIFIER))) {
                        offspringNumChange = (Math.random() < 0.5 ? -1 : 1);
                    }
                    this.numOffspring = Math.max(1, Math.min(5, Math.floor(parentBody.numOffspring + offspringNumChange)));

                    this.offspringSpawnRadius = Math.max(20, parentBody.offspringSpawnRadius * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER * 0.5)));
                    this.pointAddChance = Math.max(0, Math.min(0.5, parentBody.pointAddChance * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER * 2))));
                    this.springConnectionRadius = Math.max(10, parentBody.springConnectionRadius * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER)));


                    const angleMutation = (Math.random() - 0.5) * Math.PI * 0.2 * GLOBAL_MUTATION_RATE_MODIFIER;
                    const cosA = Math.cos(angleMutation);
                    const sinA = Math.sin(angleMutation);
                    this.emitterDirection = new Vec2(
                        parentBody.emitterDirection.x * cosA - parentBody.emitterDirection.y * sinA,
                        parentBody.emitterDirection.x * sinA + parentBody.emitterDirection.y * cosA
                    ).normalize();

                } else {
                    this.stiffness = 500 + Math.random() * 2500;
                    this.springDamping = 5 + Math.random() * 20;
                }
                this.stiffness = Math.max(100, Math.min(this.stiffness, 10000));
                this.springDamping = Math.max(0.1, Math.min(this.springDamping, 50));
                this.motorImpulseMagnitudeCap = Math.max(0, Math.min(this.motorImpulseMagnitudeCap, 5.0));
                this.motorImpulseInterval = Math.max(10, Math.min(this.motorImpulseInterval, 300));
                this.emitterStrength = Math.max(0, Math.min(this.emitterStrength, 3.0));
                this.numOffspring = Math.max(1, Math.min(this.numOffspring, 5));
                this.offspringSpawnRadius = Math.max(20, Math.min(this.offspringSpawnRadius, 150));
                this.pointAddChance = Math.max(0, Math.min(0.5, this.pointAddChance));
                this.springConnectionRadius = Math.max(10, Math.min(this.springConnectionRadius, 100));


                this.fluidEntrainment = BODY_FLUID_ENTRAINMENT_FACTOR;
                this.fluidCurrentStrength = FLUID_CURRENT_STRENGTH_ON_BODY;
                this.bodyPushStrength = SOFT_BODY_PUSH_STRENGTH;

                this.createShape(initialX, initialY, parentBody);
                this.initializeBrain(); // Initialize brain after shape creation
            }

            initializeBrain() {
                let brainNode = null;
                for(let i = 0; i < this.massPoints.length; i++) {
                    if (this.massPoints[i].nodeType === NodeType.NEURON) {
                        if (!brainNode) { // First neuron found becomes the brain
                            brainNode = this.massPoints[i];
                            brainNode.neuronData.isBrain = true;
                        } else {
                            this.massPoints[i].neuronData.isBrain = false; // Ensure others are not brains
                        }
                    }
                }

                if (brainNode) {
                    brainNode.neuronData.inputVectorSize = NEURAL_INPUT_SIZE;
                    const numEmitterSwimmers = this.massPoints.filter(mp => mp.nodeType === NodeType.EMITTER_SWIMMER).length;
                    brainNode.neuronData.outputVectorSize = numEmitterSwimmers * NEURAL_OUTPUTS_PER_EMITTER_SWIMMER;

                    if (!brainNode.neuronData.hiddenLayerSize || brainNode.neuronData.hiddenLayerSize === 0) { // Initialize if not inherited or zero
                        brainNode.neuronData.hiddenLayerSize = Math.floor(DEFAULT_HIDDEN_LAYER_SIZE_MIN + Math.random() * (DEFAULT_HIDDEN_LAYER_SIZE_MAX - DEFAULT_HIDDEN_LAYER_SIZE_MIN + 1));
                    }

                    // Initialize weights and biases if they don't exist (e.g. new brain)
                    // If inherited, they would already be there from parentBody logic in createShape
                    if (!brainNode.neuronData.weightsIH) {
                        brainNode.neuronData.weightsIH = initializeMatrix(brainNode.neuronData.hiddenLayerSize, brainNode.neuronData.inputVectorSize);
                        brainNode.neuronData.biasesH = initializeVector(brainNode.neuronData.hiddenLayerSize);
                        brainNode.neuronData.weightsHO = initializeMatrix(brainNode.neuronData.outputVectorSize, brainNode.neuronData.hiddenLayerSize);
                        brainNode.neuronData.biasesO = initializeVector(brainNode.neuronData.outputVectorSize);
                    }
                }
            }


            createShape(startX, startY, parentBody = null) {
                this.massPoints = [];
                this.springs = [];

                const baseRadius = 3 + Math.random() * 3;
                const eaterChance = 0.25;
                const predatorChance = 0.15;
                const dyeEmitterChance = 0.2;
                const nodeTypeChoices = [NodeType.NEUTRAL, NodeType.FLOATING, NodeType.FIXED_ROOT, NodeType.EMITTER_SWIMMER, NodeType.NEURON];
                const dyeColorChoices = [DYE_COLORS.RED, DYE_COLORS.GREEN, DYE_COLORS.BLUE];

                if (parentBody) {
                    let parentBrainNodeData = null;
                    const parentBrainNode = parentBody.massPoints.find(p => p.neuronData && p.neuronData.isBrain);
                    if (parentBrainNode) {
                        parentBrainNodeData = JSON.parse(JSON.stringify(parentBrainNode.neuronData)); // Deep copy for mutation
                    }


                    parentBody.massPoints.forEach(parentPoint => {
                        let mass = parentPoint.mass * (1 + (Math.random() - 0.5) * 2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER));
                        mass = Math.max(0.1, Math.min(mass, 1.0));

                        let nodeType = parentPoint.nodeType;
                        if (Math.random() < (MUTATION_CHANCE_NODE_TYPE * GLOBAL_MUTATION_RATE_MODIFIER)) {
                            nodeType = nodeTypeChoices[Math.floor(Math.random() * nodeTypeChoices.length)];
                        }

                        const offspringPoint = new MassPoint(
                            parentPoint.pos.x + (Math.random() - 0.5) * 5,
                            parentPoint.pos.y + (Math.random() - 0.5) * 5,
                            mass,
                            parentPoint.radius * (1 + (Math.random() - 0.5) * 0.2 * (MUTATION_RATE_PERCENT * GLOBAL_MUTATION_RATE_MODIFIER))
                        );
                        offspringPoint.nodeType = nodeType;
                        offspringPoint.isEater = Math.random() < (MUTATION_CHANCE_BOOL * GLOBAL_MUTATION_RATE_MODIFIER) ? !parentPoint.isEater : parentPoint.isEater;
                        offspringPoint.isPredator = Math.random() < (MUTATION_CHANCE_BOOL * GLOBAL_MUTATION_RATE_MODIFIER) ? !parentPoint.isPredator : parentPoint.isPredator;
                        offspringPoint.emitsDye = Math.random() < (MUTATION_CHANCE_BOOL * GLOBAL_MUTATION_RATE_MODIFIER) ? !parentPoint.emitsDye : parentPoint.emitsDye;
                        offspringPoint.dyeColor = Math.random() < (MUTATION_CHANCE_BOOL * GLOBAL_MUTATION_RATE_MODIFIER) ? dyeColorChoices[Math.floor(Math.random() * dyeColorChoices.length)] : [...parentPoint.dyeColor];

                        if (nodeType === NodeType.NEURON) {
                            offspringPoint.neuronData = { isBrain: false }; // Initialize, brain status set by initializeBrain
                            if (parentPoint.neuronData && parentBrainNodeData && parentPoint === parentBrainNode) { // If this point corresponds to parent's brain
                                offspringPoint.neuronData.hiddenLayerSize = parentBrainNodeData.hiddenLayerSize * (1 + (Math.random() - 0.5) * 0.2 * GLOBAL_MUTATION_RATE_MODIFIER);
                                offspringPoint.neuronData.hiddenLayerSize = Math.max(DEFAULT_HIDDEN_LAYER_SIZE_MIN, Math.min(Math.round(offspringPoint.neuronData.hiddenLayerSize), DEFAULT_HIDDEN_LAYER_SIZE_MAX * 2)); // Allow larger brains to evolve
                                // Weights will be re-initialized in initializeBrain if dimensions change, or copied/mutated if not
                                // For simplicity now, let initializeBrain handle fresh init based on new body structure
                                // More advanced: copy and mutate weights if dimensions match.
                            } else {
                                offspringPoint.neuronData.hiddenLayerSize = Math.floor(DEFAULT_HIDDEN_LAYER_SIZE_MIN + Math.random() * (DEFAULT_HIDDEN_LAYER_SIZE_MAX - DEFAULT_HIDDEN_LAYER_SIZE_MIN + 1));
                            }
                        }
                        if(offspringPoint.nodeType === NodeType.FIXED_ROOT) offspringPoint.isFixed = true;
                        this.massPoints.push(offspringPoint);


                        if (Math.random() < this.pointAddChance * GLOBAL_MUTATION_RATE_MODIFIER) {
                            const lastPointPos = this.massPoints[this.massPoints.length-1].pos.clone();
                            const newMass = 0.1 + Math.random() * 0.9;
                            const newNodeType = nodeTypeChoices[Math.floor(Math.random() * nodeTypeChoices.length)];
                            const newPoint = new MassPoint(
                                lastPointPos.x + (Math.random() - 0.5) * NEW_POINT_OFFSET_RADIUS * 2,
                                lastPointPos.y + (Math.random() - 0.5) * NEW_POINT_OFFSET_RADIUS * 2,
                                newMass,
                                baseRadius * (0.8 + Math.random() * 0.4)
                            );
                            newPoint.nodeType = newNodeType;
                            newPoint.isEater = Math.random() < eaterChance;
                            newPoint.isPredator = Math.random() < predatorChance;
                            newPoint.emitsDye = Math.random() < dyeEmitterChance;
                            newPoint.dyeColor = dyeColorChoices[Math.floor(Math.random() * dyeColorChoices.length)];
                            if (newNodeType === NodeType.NEURON) {
                                newPoint.neuronData = {
                                    isBrain: false,
                                    hiddenLayerSize: Math.floor(DEFAULT_HIDDEN_LAYER_SIZE_MIN + Math.random() * (DEFAULT_HIDDEN_LAYER_SIZE_MAX - DEFAULT_HIDDEN_LAYER_SIZE_MIN + 1))
                                };
                            }
                            if(newPoint.nodeType === NodeType.FIXED_ROOT) newPoint.isFixed = true;
                            this.massPoints.push(newPoint);
                        }
                    });

                    if (this.massPoints.length === 0) { // Fallback if parent had no points
                        this.massPoints.push(new MassPoint(startX, startY, 0.5, baseRadius));
                         if (Math.random() < NEURON_CHANCE) {
                            this.massPoints[0].nodeType = NodeType.NEURON;
                            this.massPoints[0].neuronData = {
                                isBrain: false,
                                hiddenLayerSize: Math.floor(DEFAULT_HIDDEN_LAYER_SIZE_MIN + Math.random() * (DEFAULT_HIDDEN_LAYER_SIZE_MAX - DEFAULT_HIDDEN_LAYER_SIZE_MIN + 1))
                            };
                         }
                    }

                } else { // Initial generation
                    const basePointDist = 20 + Math.random() * 10;
                    if (this.shapeType === 0) {
                        const numPointsX = 3; const numPointsY = 3; let gridPoints = [];
                        for (let i = 0; i < numPointsY; i++) { gridPoints[i] = []; for (let j = 0; j < numPointsX; j++) {
                            const point = new MassPoint(startX + j * basePointDist, startY + i * basePointDist, 0.3 + Math.random() * 0.4, baseRadius);
                            point.isEater = Math.random() < eaterChance;
                            point.isPredator = Math.random() < predatorChance;
                            point.emitsDye = Math.random() < dyeEmitterChance;
                            point.dyeColor = dyeColorChoices[Math.floor(Math.random() * dyeColorChoices.length)];
                            this.massPoints.push(point); gridPoints[i][j] = point;
                        }}
                        for (let i=0; i<numPointsY; i++) for (let j=0; j<numPointsX-1; j++) this.springs.push(new Spring(gridPoints[i][j], gridPoints[i][j+1], this.stiffness, this.springDamping));
                        for (let j=0; j<numPointsX; j++) for (let i=0; i<numPointsY-1; i++) this.springs.push(new Spring(gridPoints[i][j], gridPoints[i+1][j], this.stiffness, this.springDamping));
                        for (let i=0; i<numPointsY-1; i++) for (let j=0; j<numPointsX-1; j++) {
                            this.springs.push(new Spring(gridPoints[i][j], gridPoints[i+1][j+1], this.stiffness*0.7, this.springDamping));
                            this.springs.push(new Spring(gridPoints[i+1][j], gridPoints[i][j+1], this.stiffness*0.7, this.springDamping));
                        }
                    } else if (this.shapeType === 1) {
                        const numLinePoints = Math.floor(3 + Math.random() * 3); const isHorizontal = Math.random() < 0.5; let linePoints = [];
                        for (let i=0; i<numLinePoints; i++) {
                            const x = startX + (isHorizontal ? i * basePointDist : 0); const y = startY + (isHorizontal ? 0 : i * basePointDist);
                            const point = new MassPoint(x,y, 0.3+Math.random()*0.4, baseRadius);
                            point.isEater = Math.random() < eaterChance; point.isPredator = Math.random() < predatorChance; point.emitsDye = Math.random() < dyeEmitterChance; point.dyeColor = dyeColorChoices[Math.floor(Math.random() * dyeColorChoices.length)];
                            this.massPoints.push(point); linePoints.push(point);
                        }
                        for (let i=0; i<numLinePoints-1; i++) this.springs.push(new Spring(linePoints[i], linePoints[i+1], this.stiffness, this.springDamping));
                        if (numLinePoints > 2) this.springs.push(new Spring(linePoints[0], linePoints[numLinePoints-1], this.stiffness*0.5, this.springDamping));
                    } else {
                        const numOuterPoints = Math.floor(4 + Math.random()*3); const centralPoint = new MassPoint(startX, startY, (0.3+Math.random()*0.4)*1.5, baseRadius*1.2);
                        centralPoint.isEater = Math.random() < eaterChance; centralPoint.isPredator = Math.random() < predatorChance; centralPoint.emitsDye = Math.random() < dyeEmitterChance; centralPoint.dyeColor = dyeColorChoices[Math.floor(Math.random() * dyeColorChoices.length)];
                        this.massPoints.push(centralPoint); const circleRadius = basePointDist * 1.5;
                        for (let i=0; i<numOuterPoints; i++) {
                            const angle = (i / numOuterPoints) * Math.PI * 2; const x = startX + Math.cos(angle)*circleRadius; const y = startY + Math.sin(angle)*circleRadius;
                            const point = new MassPoint(x,y, 0.3+Math.random()*0.4, baseRadius);
                            point.isEater = Math.random() < eaterChance; point.isPredator = Math.random() < predatorChance; point.emitsDye = Math.random() < dyeEmitterChance; point.dyeColor = dyeColorChoices[Math.floor(Math.random() * dyeColorChoices.length)];
                            this.massPoints.push(point);
                            this.springs.push(new Spring(centralPoint, point, this.stiffness, this.springDamping));
                            if (i>0) this.springs.push(new Spring(this.massPoints[this.massPoints.length-2], point, this.stiffness*0.8, this.springDamping));
                        }
                        if (numOuterPoints > 1) this.springs.push(new Spring(this.massPoints[1], this.massPoints[this.massPoints.length-1], this.stiffness*0.8, this.springDamping));
                    }

                    this.massPoints.forEach((p, idx) => {
                        let currentNodeType = nodeTypeChoices[Math.floor(Math.random() * (nodeTypeChoices.length -1))]; // Default non-neuron
                        if (Math.random() < NEURON_CHANCE && this.massPoints.length > 1) { // Use global NEURON_CHANCE
                            currentNodeType = NodeType.NEURON;
                        }
                        p.nodeType = currentNodeType;

                        if (p.nodeType === NodeType.NEURON) {
                             p.neuronData = {
                                isBrain: false,
                                hiddenLayerSize: Math.floor(DEFAULT_HIDDEN_LAYER_SIZE_MIN + Math.random() * (DEFAULT_HIDDEN_LAYER_SIZE_MAX - DEFAULT_HIDDEN_LAYER_SIZE_MIN + 1))
                            };
                        }
                        if (p.nodeType === NodeType.FIXED_ROOT) p.isFixed = true;
                    });
                }

                // Create springs for copied/mutated points too, if not from a parent (initial generation)
                if (!parentBody && this.massPoints.length > 1 && this.springs.length === 0) {
                     for (let i = 0; i < this.massPoints.length; i++) {
                        for (let j = i + 1; j < this.massPoints.length; j++) {
                            const p1 = this.massPoints[i];
                            const p2 = this.massPoints[j];
                            const dist = p1.pos.sub(p2.pos).mag();
                            if (dist < this.springConnectionRadius && dist > 0.1) {
                                this.springs.push(new Spring(p1, p2, this.stiffness, this.springDamping, dist));
                            }
                        }
                    }
                }
                // The old neuron linking logic is removed as the new brain will handle things.
            }

            getAveragePosition() {
                if (this.massPoints.length === 0) return new Vec2(WORLD_WIDTH/2, WORLD_HEIGHT/2);
                let sumX = 0, sumY = 0, count = 0;
                this.massPoints.forEach(p => {
                    if(p.pos && typeof p.pos.x === 'number' && typeof p.pos.y === 'number'){
                        sumX += p.pos.x;
                        sumY += p.pos.y;
                        count++;
                    }
                });
                return count > 0 ? new Vec2(sumX / count, sumY / count) : new Vec2(WORLD_WIDTH/2, WORLD_HEIGHT/2) ;
            }
            getAverageVelocity() {
                if (this.massPoints.length === 0) return new Vec2(0,0);
                let sumVelX = 0, sumVelY = 0, count = 0;
                 this.massPoints.forEach(p => {
                    if(p.pos && p.prevPos && typeof p.pos.x === 'number' && typeof p.pos.y === 'number' && typeof p.prevPos.x === 'number' && typeof p.prevPos.y === 'number'){
                        sumVelX += (p.pos.x - p.prevPos.x);
                        sumVelY += (p.pos.y - p.prevPos.y);
                        count++;
                    }
                });
                return count > 0 ? new Vec2(sumVelX / count, sumVelY / count) : new Vec2(0,0);
            }


            updateSelf(dt, fluidFieldRef) {
                if (this.isUnstable) return;

                const brainNode = this.massPoints.find(p => p.neuronData && p.neuronData.isBrain);

                if (brainNode && brainNode.neuronData && brainNode.neuronData.weightsIH && brainNode.neuronData.hiddenLayerSize > 0 && brainNode.neuronData.outputVectorSize > 0) {
                    const nd = brainNode.neuronData;
                    const inputVector = [];

                    // 1. Dye at brain node's position
                    const brainGx = Math.floor(brainNode.pos.x / fluidFieldRef.scaleX);
                    const brainGy = Math.floor(brainNode.pos.y / fluidFieldRef.scaleY);
                    const brainFluidIdx = fluidFieldRef.IX(brainGx, brainGy);
                    inputVector.push( (fluidFieldRef.densityR[brainFluidIdx] || 0) / 255.0 );
                    inputVector.push( (fluidFieldRef.densityG[brainFluidIdx] || 0) / 255.0 );
                    inputVector.push( (fluidFieldRef.densityB[brainFluidIdx] || 0) / 255.0 );

                    // 2. Normalized Creature Energy
                    inputVector.push(this.creatureEnergy / MAX_CREATURE_ENERGY);

                    // 3. Relative CoM Position to Brain Node
                    const comPos = this.getAveragePosition();
                    const relComX = (comPos.x - brainNode.pos.x) / WORLD_WIDTH; // Normalize
                    const relComY = (comPos.y - brainNode.pos.y) / WORLD_HEIGHT; // Normalize
                    inputVector.push(tanh(relComX)); // Use tanh to keep it bounded
                    inputVector.push(tanh(relComY));

                    // 4. Relative CoM Velocity to Brain Node's Velocity
                    const comVel = this.getAverageVelocity(); // This is displacement per frame
                    const brainVelX = brainNode.pos.x - brainNode.prevPos.x;
                    const brainVelY = brainNode.pos.y - brainNode.prevPos.y;
                    const relComVelX = (comVel.x - brainVelX) / (MAX_PIXELS_PER_FRAME_DISPLACEMENT * 0.1); // Normalize
                    const relComVelY = (comVel.y - brainVelY) / (MAX_PIXELS_PER_FRAME_DISPLACEMENT * 0.1); // Normalize
                    inputVector.push(tanh(relComVelX));
                    inputVector.push(tanh(relComVelY));

                    // --- Forward Propagation ---
                    // Hidden Layer
                    let hiddenInputs = multiplyMatrixVector(nd.weightsIH, inputVector);
                    let hiddenWithBiases = addVectors(hiddenInputs, nd.biasesH);
                    let hiddenActivations = hiddenWithBiases.map(v => tanh(v));

                    // Output Layer
                    let outputInputs = multiplyMatrixVector(nd.weightsHO, hiddenActivations);
                    let rawOutputs = addVectors(outputInputs, nd.biasesO);

                    // --- Apply Outputs ---
                    let outputIdx = 0;
                    this.massPoints.forEach(point => {
                        if (point.nodeType === NodeType.EMITTER_SWIMMER) {
                            if (outputIdx + NEURAL_OUTPUTS_PER_EMITTER_SWIMMER <= rawOutputs.length) {
                                // Force X & Y (output uses tanh, range [-1, 1])
                                const forceX = tanh(rawOutputs[outputIdx++]) * MAX_NEURAL_FORCE_COMPONENT * point.mass; // Scale by mass
                                const forceY = tanh(rawOutputs[outputIdx++]) * MAX_NEURAL_FORCE_COMPONENT * point.mass;
                                point.applyForce(new Vec2(forceX / dt, forceY / dt)); // Apply as impulse

                                // Target Dye R, G, B (output uses sigmoid, range [0, 1])
                                const targetR = sigmoid(rawOutputs[outputIdx++]) * 255;
                                const targetG = sigmoid(rawOutputs[outputIdx++]) * 255;
                                const targetB = sigmoid(rawOutputs[outputIdx++]) * 255;
                                // Emission Strength (output uses sigmoid, range [0, 1])
                                const emissionPull = sigmoid(rawOutputs[outputIdx++]) * MAX_NEURAL_EMISSION_PULL_STRENGTH;

                                if (emissionPull > 0.01) { // Only emit if strength is significant
                                     const emitterFluidGx = Math.floor(point.pos.x / fluidFieldRef.scaleX);
                                     const emitterFluidGy = Math.floor(point.pos.y / fluidFieldRef.scaleY);
                                     // Use a fraction of DYE_PULL_RATE based on neural output
                                     const effectiveEmissionStrength = DYE_PULL_RATE * emissionPull * 50; // *50 to roughly match original addDensity magnitude
                                     fluidFieldRef.addDensity(emitterFluidGx, emitterFluidGy, targetR, targetG, targetB, effectiveEmissionStrength);
                                }
                                point.dyeColor = [Math.floor(targetR), Math.floor(targetG), Math.floor(targetB)]; // Store for info panel
                            }
                        }
                    });
                } else { // No brain or inoperable brain - fallback to simpler behaviors
                    if (this.motorImpulseMagnitudeCap > 0.0001 && (this.ticksSinceBirth % this.motorImpulseInterval === 0)) {
                        for (let point of this.massPoints) {
                            if (!point.isFixed && point.nodeType !== NodeType.FIXED_ROOT) {
                                const randomAngle = Math.random() * Math.PI * 2;
                                const impulseDir = new Vec2(Math.cos(randomAngle), Math.sin(randomAngle));
                                const impulseMag = Math.random() * this.motorImpulseMagnitudeCap;
                                const impulseForce = impulseDir.mul(impulseMag / dt); // Convert to force for applyForce
                                point.applyForce(impulseForce);
                            }
                        }
                    }
                     // Simpler dye emission for non-brained or brain-fallback creatures with EMITTER_SWIMMER nodes
                    this.massPoints.forEach(point => {
                        if (point.nodeType === NodeType.EMITTER_SWIMMER && point.emitsDye && fluidFieldRef) { // Check point.emitsDye flag
                            const emitterFluidGx = Math.floor(point.pos.x / fluidFieldRef.scaleX);
                            const emitterFluidGy = Math.floor(point.pos.y / fluidFieldRef.scaleY);
                            fluidFieldRef.addDensity(emitterFluidGx, emitterFluidGy, point.dyeColor[0], point.dyeColor[1], point.dyeColor[2], 50); // Default strength
                        }
                    });
                }


                // Calculate and apply energy cost
                let currentFrameEnergyCost = 0;
                for (const point of this.massPoints) {
                    currentFrameEnergyCost += BASE_NODE_EXISTENCE_COST;
                    if (point.nodeType === NodeType.EMITTER_SWIMMER && this.emitterStrength > 0.0001) {
                        currentFrameEnergyCost += EMITTER_NODE_ENERGY_COST;
                    }
                     if (point.nodeType === NodeType.NEURON) {
                        currentFrameEnergyCost += NEURON_NODE_ENERGY_COST;
                    }
                    if (point.isEater) {
                        currentFrameEnergyCost += EATER_NODE_ENERGY_COST;
                    }
                    if (point.isPredator) {
                        currentFrameEnergyCost += PREDATOR_NODE_ENERGY_COST;
                    }
                }
                this.creatureEnergy -= currentFrameEnergyCost * dt;


                this.ticksSinceBirth++;
                if (this.ticksSinceBirth > REPRODUCTION_COOLDOWN_TICKS) {
                    this.canReproduce = true;
                }

                if (this.creatureEnergy <= 0) {
                    this.isUnstable = true;
                    // console.log(`Soft body ID ${this.id} died from energy depletion.`); // Keep console less noisy
                    return;
                }

                if (this.motorImpulseMagnitudeCap > 0.0001 && (this.ticksSinceBirth % this.motorImpulseInterval === 0)) {
                    for (let point of this.massPoints) {
                        if (!point.isFixed && point.nodeType !== NodeType.FIXED_ROOT) {
                            const randomAngle = Math.random() * Math.PI * 2;
                            const impulseDir = new Vec2(Math.cos(randomAngle), Math.sin(randomAngle));
                            const impulseMag = Math.random() * this.motorImpulseMagnitudeCap;
                            const impulseForce = impulseDir.mul(impulseMag / dt);
                            point.applyForce(impulseForce);
                        }
                    }
                }


                if (fluidFieldRef) {
                    for (let point of this.massPoints) {
                        if (point.isFixed || point.nodeType === NodeType.FIXED_ROOT) continue;

                        const fluidGridX = Math.floor(point.pos.x / fluidFieldRef.scaleX);
                        const fluidGridY = Math.floor(point.pos.y / fluidFieldRef.scaleY);
                        const idx = fluidFieldRef.IX(fluidGridX, fluidGridY);

                        if (point.nodeType === NodeType.FLOATING) {
                            const rawFluidVx = fluidFieldRef.Vx[idx];
                            const rawFluidVy = fluidFieldRef.Vy[idx];
                            let fluidDisplacementPx = new Vec2(rawFluidVx * fluidFieldRef.scaleX * dt, rawFluidVy * fluidFieldRef.scaleY * dt);
                            let effectiveFluidDisplacementPx = fluidDisplacementPx.mul(this.fluidCurrentStrength);
                            let currentPointDisplacementPx = point.pos.sub(point.prevPos);
                            let blendedDisplacementPx = currentPointDisplacementPx.mul(1.0 - this.fluidEntrainment)
                                                             .add(effectiveFluidDisplacementPx.mul(this.fluidEntrainment));
                            point.prevPos = point.pos.clone().sub(blendedDisplacementPx);
                        } else if (point.nodeType === NodeType.EMITTER_SWIMMER && this.emitterStrength > 0.0001) {
                            let currentEmitterStrength = this.emitterStrength;
                            if (point.neuralEffectiveStrength !== null && point.neuralEffectiveStrength !== undefined) {
                                currentEmitterStrength *= point.neuralEffectiveStrength;
                            }

                            const emitterPushVx = this.emitterDirection.x * currentEmitterStrength;
                            const emitterPushVy = this.emitterDirection.y * currentEmitterStrength;
                            fluidFieldRef.addVelocity(fluidGridX, fluidGridY, emitterPushVx, emitterPushVy);
                        }

                        if (point.emitsDye) {
                            fluidFieldRef.addDensity(fluidGridX, fluidGridY, point.dyeColor[0], point.dyeColor[1], point.dyeColor[2], 50);
                        }
                    }
                }

                for (let spring of this.springs) spring.applyForce();

                // Inter-body repulsion & Predation (combined loop) - USING SPATIAL GRID
                for (let i_p1 = 0; i_p1 < this.massPoints.length; i_p1++) {
                    const p1 = this.massPoints[i_p1];
                    if (p1.isFixed) continue;

                    const p1Gx = Math.max(0, Math.min(GRID_COLS - 1, Math.floor(p1.pos.x / GRID_CELL_SIZE)));
                    const p1Gy = Math.max(0, Math.min(GRID_ROWS - 1, Math.floor(p1.pos.y / GRID_CELL_SIZE)));

                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const checkGx = p1Gx + dx;
                            const checkGy = p1Gy + dy;

                            if (checkGx >= 0 && checkGx < GRID_COLS && checkGy >= 0 && checkGy < GRID_ROWS) {
                                const cellIndex = checkGx + checkGy * GRID_COLS;
                                if (Array.isArray(spatialGrid[cellIndex])) {
                                    const cellBucket = spatialGrid[cellIndex];
                                    for (const otherItem of cellBucket) {
                                        if (otherItem.type === 'softbody_point') {
                                            if (otherItem.bodyRef === this) continue;

                                            const p2 = otherItem.pointRef;
                                            if (p2.isFixed) continue;

                                            const diff = p1.pos.sub(p2.pos);
                                            const distSq = diff.magSq();
                                            const interactionRadius = (p1.radius + p2.radius) * BODY_REPULSION_RADIUS_FACTOR;

                                            if (distSq < interactionRadius * interactionRadius && distSq > 0.0001) {
                                                const dist = Math.sqrt(distSq);
                                                const overlap = interactionRadius - dist;
                                                const forceDir = diff.normalize();
                                                const repulsionForceMag = BODY_REPULSION_STRENGTH * overlap * 0.5;
                                                const repulsionForce = forceDir.mul(repulsionForceMag);
                                                p1.applyForce(repulsionForce);
                                            }

                                            if (p1.isPredator) {
                                                const predationRadius = p1.radius * PREDATION_RADIUS_MULTIPLIER;
                                                if (distSq < predationRadius * predationRadius) {
                                                    const energyToSap = Math.min(otherItem.bodyRef.creatureEnergy, ENERGY_SAPPED_PER_PREDATION);
                                                    if (energyToSap > 0) {
                                                        otherItem.bodyRef.creatureEnergy -= energyToSap;
                                                        this.creatureEnergy = Math.min(MAX_CREATURE_ENERGY, this.creatureEnergy + energyToSap);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }


                for (let point of this.massPoints) point.update(dt);

                // Instability Checks
                const MAX_PIXELS_PER_FRAME_DISPLACEMENT_SQ = (MAX_PIXELS_PER_FRAME_DISPLACEMENT)**2;
                const localMaxSpringStretchFactor = MAX_SPRING_STRETCH_FACTOR;
                const localMaxSpanPerPointFactor = MAX_SPAN_PER_POINT_FACTOR;

                for (let point of this.massPoints) {
                    const displacementSq = (point.pos.x - point.prevPos.x)**2 + (point.pos.y - point.prevPos.y)**2;
                    if (displacementSq > MAX_PIXELS_PER_FRAME_DISPLACEMENT_SQ ||
                        isNaN(point.pos.x) || isNaN(point.pos.y) ||
                        !isFinite(point.pos.x) || !isFinite(point.pos.y)) {
                        this.isUnstable = true;
                        console.warn(`Soft body ID ${this.id} point instability (displacement/NaN/Infinite)!`, point);
                        break;
                    }
                }
                if (this.isUnstable) return;

                for (const spring of this.springs) {
                    const currentLength = spring.p1.pos.sub(spring.p2.pos).mag();
                    if (currentLength > spring.restLength * localMaxSpringStretchFactor) {
                        this.isUnstable = true;
                        console.warn(`Soft body ID ${this.id} spring instability (over-stretched)! Spring rest: ${spring.restLength.toFixed(1)}, current: ${currentLength.toFixed(1)}`);
                        break;
                    }
                }
                if (this.isUnstable) return;

                if (this.massPoints.length > 2) { // Only check span for bodies with more than 2 points
                    const bbox = this.getBoundingBox();
                    if (bbox.width > this.massPoints.length * localMaxSpanPerPointFactor ||
                        bbox.height > this.massPoints.length * localMaxSpanPerPointFactor) {
                        this.isUnstable = true;
                        console.warn(`Soft body ID ${this.id} span instability! Width: ${bbox.width.toFixed(1)}, Height: ${bbox.height.toFixed(1)}, Points: ${this.massPoints.length}`);
                    }
                }
                if (this.isUnstable) return;


                if (!this.isUnstable) { // Re-check after all instability checks
                    for (let point of this.massPoints) {
                        if (point.isFixed || point.nodeType === NodeType.FIXED_ROOT) continue;

                        if (point.isEater) {
                            const eaterGx = Math.max(0, Math.min(GRID_COLS - 1, Math.floor(point.pos.x / GRID_CELL_SIZE)));
                            const eaterGy = Math.max(0, Math.min(GRID_ROWS - 1, Math.floor(point.pos.y / GRID_CELL_SIZE)));
                            const eatingRadius = point.radius * EATING_RADIUS_MULTIPLIER;
                            const eatingRadiusSq = eatingRadius * eatingRadius;

                            for (let dy = -1; dy <= 1; dy++) { // Check local grid cells for particles
                                for (let dx = -1; dx <= 1; dx++) {
                                    const checkGx = eaterGx + dx;
                                    const checkGy = eaterGy + dy;
                                    if (checkGx >= 0 && checkGx < GRID_COLS && checkGy >= 0 && checkGy < GRID_ROWS) {
                                        const cellIndex = checkGx + checkGy * GRID_COLS;
                                        if (Array.isArray(spatialGrid[cellIndex])) {
                                            const cellBucket = spatialGrid[cellIndex];
                                            for (let k = cellBucket.length - 1; k >= 0; k--) { // Iterate backwards for safe removal
                                                const item = cellBucket[k];
                                                if (item.type === 'particle') {
                                                    const particle = item.particleRef;
                                                    if (particle.life > 0 && !particle.isEaten) {
                                                        const distSq = point.pos.sub(particle.pos).magSq();
                                                        if (distSq < eatingRadiusSq) {
                                                            particle.isEaten = true;
                                                            particle.life = 0; // Mark for removal from main particles array
                                                            this.creatureEnergy = Math.min(MAX_CREATURE_ENERGY, this.creatureEnergy + ENERGY_PER_PARTICLE);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }


                if (!this.isUnstable) {
                    for (let point of this.massPoints) {
                        if (point.isFixed || point.nodeType === NodeType.FIXED_ROOT) continue;
                        const implicitVelX = point.pos.x - point.prevPos.x;
                        const implicitVelY = point.pos.y - point.prevPos.y;

                        if (IS_WORLD_WRAPPING) {
                            if (point.pos.x < 0) { point.pos.x += WORLD_WIDTH; point.prevPos.x += WORLD_WIDTH; }
                            else if (point.pos.x > WORLD_WIDTH) { point.pos.x -= WORLD_WIDTH; point.prevPos.x -= WORLD_WIDTH; }
                            if (point.pos.y < 0) { point.pos.y += WORLD_HEIGHT; point.prevPos.y += WORLD_HEIGHT; }
                            else if (point.pos.y > WORLD_HEIGHT) { point.pos.y -= WORLD_HEIGHT; point.prevPos.y -= WORLD_HEIGHT; }
                        } else {
                            if (point.pos.x - point.radius < 0) {
                                point.pos.x = point.radius;
                                point.prevPos.x = point.pos.x - implicitVelX * restitution;
                            } else if (point.pos.x + point.radius > WORLD_WIDTH) {
                                point.pos.x = WORLD_WIDTH - point.radius;
                                point.prevPos.x = point.pos.x - implicitVelX * restitution;
                            }
                            if (point.pos.y - point.radius < 0) {
                                point.pos.y = point.radius;
                                point.prevPos.y = point.pos.y - implicitVelY * restitution;
                            } else if (point.pos.y + point.radius > WORLD_HEIGHT) {
                                point.pos.y = WORLD_HEIGHT - point.radius;
                                point.prevPos.y = point.pos.y - implicitVelY * restitution;
                            }
                        }
                    }
                }
            }